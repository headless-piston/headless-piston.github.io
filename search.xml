<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DP 题目合集</title>
    <url>/2025/07/04/DP%20%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="osu">OSU!</h3>
<p>之前做过。</p>
<h3 id="春季测试-2023-圣诞树"><a
href="https://www.luogu.com.cn/problem/P9119"
title="[春季测试 2023] 圣诞树">[春季测试 2023] 圣诞树</a></h3>
<p>好题。因为三角形两边和大于第三边，所以路径不交叉一定比路径交叉优。那么考虑区间
DP。首先断环为链，设 <span class="math inline">\(dp_{l,r,0/1}\)</span>
表示当前已经走完了区间 <span
class="math inline">\([l,r]\)</span>，当前在区间最左/右侧。同时记录
<span class="math inline">\(pre_{l,r,0/1}\)</span> 表示对应状态的 <span
class="math inline">\(dp\)</span>
是从上一步的左/右侧转移过来的。输出直接递归或用栈就可以了。注意：由于坐标可以为负，所以一定注意边界条件。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;node[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">double</span> dp[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>][<span class="number">2</span>],ans;</span><br><span class="line"><span class="type">int</span> pre[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dis</span><span class="params">(<span class="type">const</span> Node &amp;a,<span class="type">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x=a.x-b.x,y=a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node[l].id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        <span class="built_in">print</span>(l,r<span class="number">-1</span>,pre[l][r][p]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node[r].id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(l<span class="number">+1</span>,r,pre[l][r][p]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node[l].id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    node[s].y=<span class="number">-0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;node[i].x&gt;&gt;node[i].y;</span><br><span class="line">        node[i].id=i;</span><br><span class="line">        node[i+n]=node[i];</span><br><span class="line">        <span class="keyword">if</span>(node[i].y&gt;node[s].y) s=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=(n&lt;&lt;<span class="number">1</span>);j++)</span><br><span class="line">            dp[i][j][<span class="number">0</span>]=dp[i][j][<span class="number">1</span>]=<span class="number">0x7fffffff</span>;</span><br><span class="line">    dp[s][s][<span class="number">0</span>]=dp[s][s][<span class="number">1</span>]=dp[s+n][s+n][<span class="number">0</span>]=dp[s+n][s+n][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=l+len<span class="number">-1</span>;r&lt;=(n&lt;&lt;<span class="number">1</span>);l++,r++)&#123;</span><br><span class="line">            <span class="comment">//0 left ,1 right</span></span><br><span class="line">            <span class="type">double</span> a=dp[l<span class="number">+1</span>][r][<span class="number">0</span>]+<span class="built_in">dis</span>(node[l],node[l<span class="number">+1</span>]),b=dp[l<span class="number">+1</span>][r][<span class="number">1</span>]+<span class="built_in">dis</span>(node[l],node[r]);</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b) dp[l][r][<span class="number">0</span>]=b,pre[l][r][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[l][r][<span class="number">0</span>]=a,pre[l][r][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            a=dp[l][r<span class="number">-1</span>][<span class="number">1</span>]+<span class="built_in">dis</span>(node[r<span class="number">-1</span>],node[r]),b=dp[l][r<span class="number">-1</span>][<span class="number">0</span>]+<span class="built_in">dis</span>(node[l],node[r]);</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b) dp[l][r][<span class="number">1</span>]=b,pre[l][r][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[l][r][<span class="number">1</span>]=a,pre[l][r][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ans=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">min</span>(&#123;ans,dp[i][i+n<span class="number">-1</span>][<span class="number">0</span>],dp[i][i+n<span class="number">-1</span>][<span class="number">1</span>]&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][i+n<span class="number">-1</span>][<span class="number">0</span>]==ans)&#123;</span><br><span class="line">            <span class="built_in">print</span>(i,i+n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][i+n<span class="number">-1</span>][<span class="number">1</span>]==ans)&#123;</span><br><span class="line">            <span class="built_in">print</span>(i,i+n<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="jsoi2018-潜入行动"><a
href="https://www.luogu.com.cn/problem/P4516"
title="[JSOI2018] 潜入行动">[JSOI2018] 潜入行动</a></h3>
<p>树上背包。朴素的状态不足以表达信息时就考虑加状态。<span
class="math inline">\(dp_{u,i,0/1,0/1}\)</span> 表示以 <span
class="math inline">\(u\)</span> 为根的子树中，放了 <span
class="math inline">\(i\)</span> 个监视器，点 <span
class="math inline">\(u\)</span> 放/不放，点 <span
class="math inline">\(u\)</span>
是/否被覆盖。转移时涉及滚动数组，所以我们记 <span
class="math inline">\(temp_{i,0/1,0/1}\)</span> 表示当前的 <span
class="math inline">\(dp_{u,i,0/1,0/1}\)</span>。<br />
转移有点麻烦：<br />
<span class="math display">\[dp_{u,i+j,0,0}=\sum temp_{i,0,0}\times
dp_{v,j,0,1}\]</span> <span class="math display">\[dp_{u,i+j,1,0}=\sum
temp_{i,1,0}\times dp_{v,j,0,0/1}\]</span> <span
class="math display">\[dp_{u,i+j,0,1}=\sum temp_{i,0,0}\times
dp_{v,j,1,1}+temp_{i,0,1}\times dp_{v,j,0/1,1}\]</span> <span
class="math display">\[dp_{u,i+j,1,1}=\sum temp_{i,1,0}\times
dp_{v,j,1,0/1}+temp_{i,1,1}\times dp_{v,j,0/1,0/1}\]</span></p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>,N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">modint</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">modint</span>(<span class="type">int</span> val=<span class="number">0</span>):<span class="built_in">val</span>(val)&#123;&#125;</span><br><span class="line">    modint <span class="keyword">operator</span>+(<span class="type">const</span> modint &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">modint</span>((val+x.val)%mod);&#125;</span><br><span class="line">    modint &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> modint &amp;x)&#123;val+=x.val;val%=mod;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    modint <span class="keyword">operator</span>*(<span class="type">const</span> modint &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">modint</span>((ll)val*x.val%mod);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> n,k,siz[N];</span><br><span class="line">modint dp[N][<span class="number">110</span>][<span class="number">2</span>][<span class="number">2</span>],temp[<span class="number">110</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    dp[u][<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=dp[u][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            temp[i][<span class="number">0</span>][<span class="number">0</span>]=dp[u][i][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            temp[i][<span class="number">0</span>][<span class="number">1</span>]=dp[u][i][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">            temp[i][<span class="number">1</span>][<span class="number">0</span>]=dp[u][i][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            temp[i][<span class="number">1</span>][<span class="number">1</span>]=dp[u][i][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[u][i][<span class="number">0</span>][<span class="number">0</span>]=dp[u][i][<span class="number">0</span>][<span class="number">1</span>]=dp[u][i][<span class="number">1</span>][<span class="number">0</span>]=dp[u][i][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">min</span>(siz[u],k);i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(siz[v],k-i);j++)&#123;</span><br><span class="line">                dp[u][i+j][<span class="number">0</span>][<span class="number">0</span>]+=temp[i][<span class="number">0</span>][<span class="number">0</span>]*dp[v][j][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">                dp[u][i+j][<span class="number">1</span>][<span class="number">0</span>]+=temp[i][<span class="number">1</span>][<span class="number">0</span>]*(dp[v][j][<span class="number">0</span>][<span class="number">0</span>]+dp[v][j][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[u][i+j][<span class="number">0</span>][<span class="number">1</span>]+=temp[i][<span class="number">0</span>][<span class="number">0</span>]*dp[v][j][<span class="number">1</span>][<span class="number">1</span>]+</span><br><span class="line">                temp[i][<span class="number">0</span>][<span class="number">1</span>]*(dp[v][j][<span class="number">0</span>][<span class="number">1</span>]+dp[v][j][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[u][i+j][<span class="number">1</span>][<span class="number">1</span>]+=temp[i][<span class="number">1</span>][<span class="number">0</span>]*(dp[v][j][<span class="number">1</span>][<span class="number">0</span>]+dp[v][j][<span class="number">1</span>][<span class="number">1</span>])+</span><br><span class="line">                temp[i][<span class="number">1</span>][<span class="number">1</span>]*(dp[v][j][<span class="number">0</span>][<span class="number">0</span>]+dp[v][j][<span class="number">0</span>][<span class="number">1</span>]+dp[v][j][<span class="number">1</span>][<span class="number">0</span>]+dp[v][j][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(dp[<span class="number">1</span>][k][<span class="number">0</span>][<span class="number">1</span>]+dp[<span class="number">1</span>][k][<span class="number">1</span>][<span class="number">1</span>]).val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="at_dp_e-knapsack-2"><a
href="https://atcoder.jp/contests/dp/tasks/dp_e"
title="AT_dp_e Knapsack 2">AT_dp_e Knapsack 2</a></h3>
<p>背包变形。将 <span class="math inline">\(v\)</span> 和 <span
class="math inline">\(w\)</span> 互换一下就行。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,W,w,v,sum;</span><br><span class="line">ll dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,W);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(w,v);</span><br><span class="line">        sum+=v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=v;j--)</span><br><span class="line">            dp[j]=<span class="built_in">Min</span>(dp[j],dp[j-v]+w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=sum;i;i--)</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&lt;=W)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="at_dp_j-sushi"><a
href="https://www.luogu.com.cn/problem/AT_dp_j"
title="AT_dp_j Sushi">AT_dp_j Sushi</a></h3>
<p><span class="math inline">\(dp_{i,j,k}\)</span> 表示有 <span
class="math inline">\(i\)</span> 个装 <span
class="math inline">\(1\)</span> 个寿司，<span
class="math inline">\(j\)</span> 个装 <span
class="math inline">\(2\)</span> 个寿司和 <span
class="math inline">\(k\)</span> 个装 <span
class="math inline">\(3\)</span> 个寿司的盘子的期望次数。<span
class="math inline">\(dp_{i,j,k}\)</span> 为以下四项之和：<br />
- <span class="math inline">\(\dfrac{n-(i+j+k)}{n}\times
(dp_{i,j,k}+1)\)</span>（空盘子）</p>
<ul>
<li><p><span class="math inline">\(\dfrac{i}{n}\times
(dp_{i-1,j,k}+1)\)</span>（放 <span class="math inline">\(1\)</span>
个）</p></li>
<li><p><span class="math inline">\(\dfrac{j}{n}\times
(dp_{i+1,j-1,k}+1)\)</span>（放 <span class="math inline">\(2\)</span>
个）</p></li>
<li><p><span class="math inline">\(\dfrac{k}{n}\times
(dp_{i,j+1,k-1}+1)\)</span>（放 <span class="math inline">\(3\)</span>
个）</p></li>
</ul>
<p>整理，得<br />
<span class="math display">\[dp_{i,j,k}=\frac{n}{i+j+k}+\frac{i\times
dp_{i-1,j,k}}{i+j+k}+\frac{j\times dp_{i+1,j-1,k}}{i+j+k}+\frac{k\times
dp_{i,j+1,k-1}}{i+j+k}\]</span> 显然，应当按 <span
class="math inline">\(k-j-i\)</span> 顺序枚举以消除后效性。边界：<span
class="math inline">\(dp_{0,0,0}=0\)</span>。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n,cnt[<span class="number">4</span>];</span><br><span class="line"><span class="type">double</span> dp[N][N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a;i&lt;=n;i++) <span class="built_in">read</span>(a),++cnt[a];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j&amp;&amp;j==k&amp;&amp;k==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">double</span> inv=i+j+k;</span><br><span class="line">                dp[i][j][k]=n/inv;</span><br><span class="line">                <span class="keyword">if</span>(i) dp[i][j][k]+=dp[i<span class="number">-1</span>][j][k]*i/inv;</span><br><span class="line">                <span class="keyword">if</span>(j) dp[i][j][k]+=dp[i<span class="number">+1</span>][j<span class="number">-1</span>][k]*j/inv;</span><br><span class="line">                <span class="keyword">if</span>(k) dp[i][j][k]+=dp[i][j<span class="number">+1</span>][k<span class="number">-1</span>]*k/inv;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf&quot;</span>,dp[cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]][cnt[<span class="number">3</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <tags>
        <tag>题目合集</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher</title>
    <url>/2025/07/05/Manacher/</url>
    <content><![CDATA[<p>今天讲的字符串哈希题觉得都很水啊，咋一听到 Manacher
题就懵逼了呢？重学一遍……</p>
<h3 id="简介">简介</h3>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的字符串 <span
class="math inline">\(S\)</span>，找到所有回文子串。<br />
最坏情况下有 <span class="math inline">\(O(n^2)\)</span>
个回文串，为了做到线性，我们使用回文半径来表示回文。这样，我们要求的就转化为：对于每个位置
<span class="math inline">\(i\)</span>，求出最长回文半径。<br />
使用字符串哈希可以容易地在 <span class="math inline">\(O(n\log
n)\)</span> 时间内解决，但 Manacher 更为简洁和高效。</p>
<h3 id="实现过程">实现过程</h3>
<p>约定：<span class="math inline">\([l,r]\)</span> 表示下标在 <span
class="math inline">\(l,r\)</span> 之间的子串。<br />
我们只考虑长度为奇数的回文串，可以通过在字符串每个字符间加入无关字符如
<code>#</code>
等来把长度为偶数的串转化为长度为奇数的串。接下来，我们维护 <span
class="math inline">\(p_i\)</span> 表示以 <span
class="math inline">\(i\)</span> 为中心的回文半径，<span
class="math inline">\(r\)</span>
为当前找到的覆盖位置最靠右的回文串能覆盖到的最大下标，<span
class="math inline">\(mid\)</span> 表示它的回文中心的下标。<br />
计算过程考虑分类讨论：</p>
<ul>
<li><p><span class="math inline">\(i&gt;r\)</span>
时，直接暴力一步步向后跳。</p></li>
<li><p><span class="math inline">\(i\le r\)</span> 时，设 <span
class="math inline">\(j\)</span> 为 <span
class="math inline">\(i\)</span> 关于 <span
class="math inline">\(mid\)</span> 的对称点，即 <span
class="math inline">\(mid\times 2-i\)</span>。<br />
由于 <span class="math inline">\([j-p_j,j+p_j]\)</span> 与 <span
class="math inline">\([i-p_i,i+p_i]\)</span> 相等且都是回文串，所以
<span class="math inline">\(p_i\)</span> 可以直接取 <span
class="math inline">\(p_j\)</span> 的值。但这个推论成立当且仅当 <span
class="math inline">\(i+p_j\le r\)</span>，否则 <span
class="math inline">\(p_i\)</span> 只能取到 <span
class="math inline">\(r-i+1\)</span>，然后再暴力扩展。<br />
综上，<span
class="math inline">\(p_i=\min(p_j,r-i+1)\)</span>。</p></li>
</ul>
<p><span class="math inline">\(r\)</span> 只能向右移动，故最多移动 <span
class="math inline">\(O(n)\)</span> 次。其余情况的计算显然是 <span
class="math inline">\(O(1)\)</span> 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,r=<span class="number">0</span>,mid=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">2</span>*mid-i;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=r) p[i]=<span class="built_in">min</span>(r-i<span class="number">+1</span>,p[j]);</span><br><span class="line">    <span class="keyword">else</span> p[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i-p[i]]==s[i+p[i]]) ++p[i];</span><br><span class="line">    <span class="keyword">if</span>(i+p[i]<span class="number">-1</span>&gt;r)&#123;</span><br><span class="line">        r=i+p[i]<span class="number">-1</span>;</span><br><span class="line">        mid=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分引自 <a
href="https://oi-wiki.org/string/manacher/">https://oi-wiki.org/string/manacher/</a></p>
<p>非常感谢<a
href="https://www.luogu.com.cn/article/2fmdma9m">这篇博客</a>，讲的很透彻，帮我彻底弄懂了
Manacher。</p>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT 快速傅里叶变换</title>
    <url>/2025/07/04/FFT%20%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="前置知识">前置知识</h3>
<p>默认你已经学过复数。没有的话右转高中数学 A 版必修二。</p>
<h4 id="多项式">多项式</h4>
<p>形如<br />
<span class="math display">\[F(x)=\sum_{i=0}^n a_i x^i\]</span>
的式子。其中 <span class="math inline">\(n\)</span> 为非负整数，<span
class="math inline">\(a_i\)</span> 属于<a
href="https://baike.baidu.com/item/%E6%95%B0%E5%9F%9F/1259870"
title="数域">数域</a> <span
class="math inline">\(P\)</span>。我们只需知道所有 <span
class="math inline">\(a_i\)</span>，就可以确定一个多项式。这就是多项式的系数表示法。
为了方便运算，我们引入多项式的点值表示法。<br />
对于一个 <span class="math inline">\(n\)</span> 次多项式 <span
class="math inline">\(F(x)\)</span>，我们可以用 <span
class="math inline">\(n+1\)</span> 个互不相同的点 <span
class="math inline">\(\{(x_0,F(x_0)),(x_1,F(x_1)),\cdots,(x_{n+1},F(x_{n+1}))\}\)</span>
来确定这个多项式。我们下文称这个集合为 <span
class="math inline">\(S_{F(x)}\)</span>。<br />
系数表示法转为点值表示法的过程叫做 DFT，反之叫 IDFT。</p>
<h4 id="四则运算">四则运算</h4>
<p>只说乘法。<br />
现有多项式 <span class="math inline">\(F(x)=\sum_{i=0}^n a_i
x^i\)</span> 和 <span class="math inline">\(G(x)=\sum_{j=0}^m b_j
x^j\)</span>。则有<br />
<span class="math display">\[F(x)\times
G(x)=\sum_{i=0}^n\sum_{j=0}^ma_ib_jx^{i+j}\]</span></p>
<h4 id="卷积">卷积</h4>
<p>事实上，卷积运算和多项式乘法在数学上是等价的。<span
class="math inline">\(H(x)=F(x) * G(x)\)</span> 表示 <span
class="math inline">\(H(x)\)</span> 为 <span
class="math inline">\(F(x)\)</span> 和 <span
class="math inline">\(G(x)\)</span> 的卷积。<br />
刚才的多项式乘法求得的式子并不是标准的多项式形式。我们设 <span
class="math inline">\(H(x)=F(x) *
G(x)=\sum_{k=0}^{n+m}c_kx^k\)</span>。则每项的系数 <span
class="math inline">\(c_k=\sum_{i+j=k}a_ib_j\)</span>，变为更容易计算的形式<br />
<span
class="math display">\[c_k=\sum_{i=\max(0,k-m)}^{\min(n,k)}a_ib_{k-i}\]</span>
若使用点值表示法，设<br />
<span class="math display">\[S_{F(x)}=\{(x_i,y_i)\}\]</span> <span
class="math display">\[S_{G(x)}=\{(x_i,y&#39;_i)\}\]</span> 则有<br />
<span class="math display">\[S_{H(x)}=\{(x_i,y_iy&#39;_i)\}\]</span></p>
<h4 id="单位根">单位根</h4>
<p>根据<a
href="https://baike.baidu.com/item/%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/18104?fromModule=lemma_inlink"
title="代数基本定理">代数基本定理</a>，<span
class="math inline">\(x^n=1\)</span> 有 <span
class="math inline">\(n\)</span> 个根，这 <span
class="math inline">\(n\)</span> 个根都称为单位根。记作 <span
class="math inline">\(\{\omega_n^k\mid
k=0,1,\cdots,n-1\}\)</span>，其中，<span
class="math inline">\(\omega_n^0=1\)</span>。在复平面上，它们刚好将单位圆
<span class="math inline">\(n\)</span> 等分。一般说的单位根 <span
class="math inline">\(\omega_n\)</span>，指从 <span
class="math inline">\((1,0)\)</span> 开始逆时针方向上的第一个根。<br />
一些下面会用到的小式子：<br />
- 对于偶数次单位根，有 <span
class="math inline">\(\omega_n^i=-\omega_n^{i+\frac{n}{2}}\)</span>（其实就是在复平面上关于原点中心对称）。
- <span class="math inline">\(\omega_{2n}^{2k}=\omega_n^k\)</span> -
<span class="math inline">\((\omega_n^k)^2=\omega_n^{2k}\)</span></p>
<h3 id="fft"><a href="https://www.luogu.com.cn/problem/P3803"
title="FFT">FFT</a></h3>
<p>显然，朴素算法求解 <span class="math inline">\(F(x) * G(x)\)</span>
的时间复杂度为 <span class="math inline">\(O(nm)\)</span>，而 FFT
可以让我们在 <span class="math inline">\(O(n\log n)\)</span>
的时间复杂度内计算两个 <span class="math inline">\(n\)</span>
次多项式的乘法。基本思想是分治。<br />
我们只需对 <span class="math inline">\(F(x)\)</span> 和 <span
class="math inline">\(G(x)\)</span> 进行 DFT，计算 <span
class="math inline">\(S_{H(x)}=S_{F(x)}*S_{G(x)}\)</span>，最后再对
<span class="math inline">\(S_{H(x)}\)</span> IDFT 即得 <span
class="math inline">\(H(x)\)</span>。<br />
接下来说 DFT 的过程。<br />
对于 <span
class="math inline">\(F(x)\)</span>，将其划分为奇次与偶次两部分。<br />
<span
class="math display">\[F(x)=\sum_{i=0}^{\frac{n}{2}}a_{2i}x^{2i}+\sum_{i=0}^{\frac{n}{2}}a_{2i+1}x^{2i+1}\]</span>
将右半部分提出一个 <span class="math inline">\(x\)</span><br />
<span
class="math display">\[F(x)=\sum_{i=0}^{\frac{n}{2}}a_{2i}x^{2i}+x\sum_{i=0}^{\frac{n}{2}}a_{2i+1}x^{2i}\]</span>
将前后两部分用新的多项式表示<br />
<span
class="math display">\[F_1(x)=\sum_{i=0}^{\frac{n}{2}}a_{2i}x^{i}\]</span>
<span
class="math display">\[F_2(x)=\sum_{i=0}^{\frac{n}{2}}a_{2i+1}x^{i}\]</span>
<span class="math display">\[F(x)=F_1(x^2)+xF_2(x^2)\]</span>
这时我们代入 <span class="math inline">\(\omega_n^k\)</span>，可得<br />
<span class="math display">\[\begin{aligned}
F(\omega_n^k)&amp;=F_1((\omega_n^k)^2)+\omega_n^kF_2((\omega_n^k)^2)\\
&amp;=F_1(\omega_n^{2k})+\omega_n^kF_2(\omega_n^{2k})\\
&amp;=F_1(\omega_\frac{n}{2}^k)+\omega_n^kF_2(\omega_\frac{n}{2}^k)
\end{aligned}\]</span> 同理，代入 <span
class="math inline">\(\omega_n^{k+\frac{n}{2}}=-\omega_n^k\)</span>，得<br />
<span
class="math display">\[F(\omega_n^{k+\frac{n}{2}})=F_1(\omega_\frac{n}{2}^k)-\omega_n^kF_2(\omega_\frac{n}{2}^k)\]</span>
所以，我们可以根据 <span
class="math inline">\(F_1(\omega_\frac{n}{2}^k)\)</span> 和 <span
class="math inline">\(F_2(\omega_\frac{n}{2}^k)\)</span> 求出 <span
class="math inline">\(F(\omega_n^k)\)</span> 和 <span
class="math inline">\(F(\omega_n^{k+\frac{n}{2}})\)</span>。这种做法只能处理长度为
<span class="math inline">\(2\)</span>
的正整次幂的多项式，所以我们要把高次系数补为 <span
class="math inline">\(0\)</span>。<br />
接下来是 IDFT。它的操作与 DFT 极像，就是将 <span
class="math inline">\(\omega_n^k\)</span> 变为 <span
class="math inline">\(\omega_n^{-k}\)</span>，并在最后乘 <span
class="math inline">\(\dfrac{1}{n}\)</span>。<br />
现实计算中，递归处理效率较低，我们使用位逆序置换优化和蝶形运算优化，直接将值排列为特定的顺序，避免了递归和额外的临时数组。</p>
<h4 id="位逆序置换优化">位逆序置换优化</h4>
<p>我们要想避免递归，就要将需要一起计算的部分放在一起。<br />
我们以 <span class="math inline">\(7\)</span> 次多项式为例，有 <span
class="math inline">\(8\)</span> 个 <span
class="math inline">\(a_i\)</span>，具体划分方式如图 <img
src="https://github.com/headless-piston/blog_images/blob/main/FFT.png?raw=true"
alt="image" />
规律：将每个下标的二进制反转，以反转后的数为新下标。例如，<span
class="math inline">\(3\)</span> 的二进制是 <span
class="math inline">\(011\)</span>，反转后为 <span
class="math inline">\(110\)</span>，即 <span
class="math inline">\(6\)</span>，从图上来看，<span
class="math inline">\(a_3\)</span> 确实到了原 <span
class="math inline">\(a_6\)</span> 的位置。</p>
<h4 id="蝶形运算优化">蝶形运算优化</h4>
<p>位逆序置换后，我们可以直接计算 <span
class="math inline">\(F_1(x)\)</span> 和 <span
class="math inline">\(F_2(x)\)</span>
而无需临时数组，因为计算要用到的数与计算完成后的数应当被存在相同的下标内，直接覆盖原数就行了。具体地，计算
<span class="math inline">\(F(\omega_n^k)\)</span> 和 <span
class="math inline">\(F(\omega_n^{k+\frac{n}{2}})\)</span> 时 <span
class="math inline">\(F_1(\omega_\frac{n}{2}^k)\)</span> 的值在下标
<span class="math inline">\(k\)</span>，<span
class="math inline">\(F_2(\omega_\frac{n}{2}^k)\)</span> 的值在下标
<span class="math inline">\(k+\frac{n}{2}\)</span>。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">22</span>;<span class="comment">//要开略大一些因为len可能会大于n+m</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="number">4</span>*<span class="built_in">atan</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> n,m,a[N],b[N],len=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">comp</span>&#123;</span><br><span class="line">	<span class="type">double</span> real,imag;</span><br><span class="line">&#125;fa[N],fb[N],fc[N];</span><br><span class="line">comp <span class="keyword">operator</span>+(<span class="type">const</span> comp &amp;x,<span class="type">const</span> comp &amp;y)&#123;</span><br><span class="line">	<span class="keyword">return</span> comp&#123;x.real+y.real,x.imag+y.imag&#125;;</span><br><span class="line">&#125;</span><br><span class="line">comp <span class="keyword">operator</span>-(<span class="type">const</span> comp &amp;x,<span class="type">const</span> comp &amp;y)&#123;</span><br><span class="line">	<span class="keyword">return</span> comp&#123;x.real-y.real,x.imag-y.imag&#125;;</span><br><span class="line">&#125;</span><br><span class="line">comp <span class="keyword">operator</span>*(<span class="type">const</span> comp &amp;x,<span class="type">const</span> comp &amp;y)&#123;</span><br><span class="line">	<span class="keyword">return</span> comp&#123;x.real*y.real-x.imag*y.imag,x.real*y.imag+y.real*x.imag&#125;;</span><br><span class="line">&#125;</span><br><span class="line">comp <span class="keyword">operator</span>/(<span class="type">const</span> comp &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;</span><br><span class="line">	<span class="keyword">return</span> comp&#123;x.real/(<span class="type">double</span>)y,x.imag/(<span class="type">double</span>)y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(comp *f,<span class="type">int</span> n,<span class="type">int</span> rev)</span></span>&#123;<span class="comment">//rev=1代表DFT，rev=-1代表IDFT</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=n&gt;&gt;<span class="number">1</span>,k;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//位逆序置换，0和n-1不用换</span></span><br><span class="line">		<span class="keyword">if</span>(i&lt;j)<span class="comment">//j即i的二进制反转，判断i&lt;j是为了保证只交换1次</span></span><br><span class="line">			<span class="built_in">swap</span>(f[i],f[j]);</span><br><span class="line">		k=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(j&gt;=k)&#123;<span class="comment">//清除高位</span></span><br><span class="line">			j-=k;</span><br><span class="line">			k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		j+=k;<span class="comment">//更新低位</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">double</span> arg=<span class="number">2</span>*PI*rev/len;</span><br><span class="line">		comp wn=&#123;<span class="built_in">cos</span>(arg),<span class="built_in">sin</span>(arg)&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line">			comp w=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len/<span class="number">2</span>;j++)&#123;</span><br><span class="line">				comp f1=f[i+j];</span><br><span class="line">				comp f2=f[i+j+len/<span class="number">2</span>];</span><br><span class="line">				f[i+j]=f1+w*f2;</span><br><span class="line">				f[i+j+len/<span class="number">2</span>]=f1-w*f2;</span><br><span class="line">				w=w*wn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!~rev)<span class="comment">//IDFT的最后除以n操作</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			f[i]=f[i]/n;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,b+i);</span><br><span class="line">	<span class="keyword">while</span>(len&lt;=n+m)</span><br><span class="line">		len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		fa[i]=&#123;(<span class="type">double</span>)a[i],<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">		fb[i]=&#123;(<span class="type">double</span>)b[i],<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">FFT</span>(fa,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">FFT</span>(fb,len,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		fc[i]=fa[i]*fb[i];</span><br><span class="line">	<span class="built_in">FFT</span>(fc,len,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+m;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,(<span class="type">int</span>)<span class="built_in">round</span>(fc[i].real));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="其他优化">其他优化</h4>
<p>可以预处理单位根，无需在变换过程中计算，以提高效率和精度。</p>
<h3 id="参考资料">参考资料</h3>
<p><a
href="https://www.cnblogs.com/Kenma/p/18813688">https://www.cnblogs.com/Kenma/p/18813688</a></p>
<p><a
href="https://oi-wiki.org/math/poly/fft/">https://oi-wiki.org/math/poly/fft/</a></p>
<p><a href="https://grok.com/"
title="特别鸣谢">特别鸣谢</a>，解决了我在数学上的一些疑惑。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>AC 自动机</title>
    <url>/2025/06/23/AC%20%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>最近集训时将难一些的字符串题时发现自己似乎已经忘了，或者就根本没学懂过
AC 自动机，于是重学一遍。</p>
<h3 id="功能">功能</h3>
<p>AC 自动机可以实现比 KMP 和 Trie
更多的字符串匹配方面的功能。比如求模式串是否在文本串中出现过，出现了多少次等。不同于
KMP，AC 自动机支持<strong>多模式串的匹配</strong>。可以认为，AC
自动机就是在 Trie 上进行
KMP，同样要求最长公共前后缀，只不过前缀可以从<strong>任意模式串</strong>中截取而非
KMP 的单一模式串。类似于 KMP 的 <span class="math inline">\(nxt\)</span>
数组，AC 自动机中称这个指针为 <span
class="math inline">\(fail\)</span>。<br />
我们举个例子：若干模式串组成 Trie<br />
<img
src="https://raw.githubusercontent.com/headless-piston/blog_images/refs/heads/main/AC.png"
alt="image" /> 为了防止过多 <span class="math inline">\(fail\)</span>
弄得图片过乱，我们只取一个例子：<span class="math inline">\(9\)</span>
节点处，我们发现有 <span class="math inline">\(0\)</span> 节点到 <span
class="math inline">\(2\)</span> 节点和 <span
class="math inline">\(7\)</span> 节点到 <span
class="math inline">\(9\)</span> 节点的最长公共前后缀
<code>he</code>。所以，类似 KMP，<span class="math inline">\(9\)</span>
处的 <span class="math inline">\(fail\)</span> 应指向 <span
class="math inline">\(2\)</span>。</p>
<h3 id="建树">建树</h3>
<p>那么，<span class="math inline">\(fail\)</span>
究竟应该如何构建呢？我们使用 BFS 来遍历 Trie，在失配时不断跳 <span
class="math inline">\(fail\)</span>。</p>
<details>
<summary>
build AC automaton
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(nxt[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nxt[u][i])&#123;</span><br><span class="line">                <span class="type">int</span> to=fail[u];</span><br><span class="line">                <span class="keyword">while</span>(to&amp;&amp;!nxt[to][i])</span><br><span class="line">                    to=fail[to];</span><br><span class="line">                fail[nxt[u][i]]=nxt[to][i];</span><br><span class="line">                q.<span class="built_in">push</span>(nxt[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>然而，这样一直跳 <span class="math inline">\(fail\)</span>
效率太低了。我们可以在一开始就预处理出不存在的边的 <span
class="math inline">\(fail\)</span>，将查找 <span
class="math inline">\(fail\)</span> 优化至 <span
class="math inline">\(O(1)\)</span>。此时的 Trie 由树变为了图。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(nxt[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nxt[u][i])&#123;</span><br><span class="line">                fail[nxt[u][i]]=nxt[fail[u]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(nxt[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> nxt[u][i]=nxt[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多模式串匹配">多模式串匹配</h3>
<p>我们以<a href="https://www.luogu.com.cn/problem/P3808"
title="本题">本题</a>的匹配为例，只需每次跳 <span
class="math inline">\(fail\)</span> 并计数，打标记防止记重就好了。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        u=nxt[u][c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=u;j&amp;&amp;ed[j]!=<span class="number">-1</span>;j=fail[j])</span><br><span class="line">            res+=ed[j],ed[j]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="效率优化">效率优化</h3>
<p>我们发现，匹配时一直在跳 <span
class="math inline">\(fail\)</span>，这个操作事实上是可以优化的。<br />
显然，一个 AC 自动机上的 <span class="math inline">\(fail\)</span>
边应当会构成一棵内向树。因此可以进行拓扑排序优化。<br />
按照拓扑序处理节点，累加出现次数。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">26</span>],tot,fail[N],n,ed[N],ans[N],indegree[N],mp[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(string s,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[u][c]) nxt[u][c]=++tot;</span><br><span class="line">        u=nxt[u][c];</span><br><span class="line">    &#125;</span><br><span class="line">    ++ed[u];</span><br><span class="line">    mp[id]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(nxt[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nxt[u][i])&#123;</span><br><span class="line">                fail[nxt[u][i]]=nxt[fail[u]][i];</span><br><span class="line">                ++indegree[nxt[fail[u]][i]];</span><br><span class="line">                q.<span class="built_in">push</span>(nxt[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> nxt[u][i]=nxt[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++) <span class="keyword">if</span>(!indegree[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> v=fail[u];</span><br><span class="line">        ans[v]+=ans[u];</span><br><span class="line">        <span class="keyword">if</span>(!--indegree[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">query</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        u=nxt[u][c];</span><br><span class="line">        ans[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">string s,t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;s,<span class="built_in">insert</span>(s,i);</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">query</span>(t);</span><br><span class="line">    <span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;ans[mp[i]]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="习题">习题</h3>
<h4 id="poi-2000-病毒"><a href="https://www.luogu.com.cn/problem/P2444"
title="[POI 2000] 病毒">[POI 2000] 病毒</a></h4>
<p>建立 AC
自动机时判断，若某串的最长前缀是病毒，则它本身一定不合法。之后 dfs
判环就行，注意使用标记数组保证 dfs
的复杂度正确。<del>代码有点丑陋，为了卡常写了循环展开。</del></p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">3e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">2</span>],tot,n,fail[N];</span><br><span class="line"><span class="type">bool</span> ed[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[p][c^<span class="number">48</span>]) nxt[p][c^<span class="number">48</span>]=++tot;</span><br><span class="line">        p=nxt[p][c^<span class="number">48</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[p]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">if</span>(nxt[<span class="number">0</span>][<span class="number">0</span>]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(nxt[<span class="number">0</span>][<span class="number">1</span>]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(nxt[u][<span class="number">0</span>])&#123;</span><br><span class="line">            fail[nxt[u][<span class="number">0</span>]]=nxt[fail[u]][<span class="number">0</span>];</span><br><span class="line">            q.<span class="built_in">push</span>(nxt[u][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> nxt[u][<span class="number">0</span>]=nxt[fail[u]][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(ed[fail[nxt[u][<span class="number">0</span>]]]) ed[nxt[u][<span class="number">0</span>]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nxt[u][<span class="number">1</span>])&#123;</span><br><span class="line">            fail[nxt[u][<span class="number">1</span>]]=nxt[fail[u]][<span class="number">1</span>];</span><br><span class="line">            q.<span class="built_in">push</span>(nxt[u][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> nxt[u][<span class="number">1</span>]=nxt[fail[u]][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(ed[fail[nxt[u][<span class="number">1</span>]]]) ed[nxt[u][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[N],used[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[nxt[u][<span class="number">0</span>]]||vis[nxt[u][<span class="number">1</span>]])&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TAK\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p=nxt[u][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(!used[p]&amp;&amp;!ed[p]) used[p]=<span class="number">1</span>,<span class="built_in">dfs</span>(p);</span><br><span class="line">    p=nxt[u][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(!used[p]&amp;&amp;!ed[p]) used[p]=<span class="number">1</span>,<span class="built_in">dfs</span>(p);</span><br><span class="line">    vis[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;NIE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h4 id="noi2011-阿狸的打字机"><a
href="https://www.luogu.com.cn/problem/P2414"
title="[NOI2011] 阿狸的打字机">[NOI2011] 阿狸的打字机</a></h4>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,tot,nxt[N][<span class="number">26</span>],fail[N],fa[N],endpos[N],nxt1[N][<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(nxt[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nxt[u][i])&#123;</span><br><span class="line">                fail[nxt[u][i]]=nxt[fail[u]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(nxt[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> nxt[u][i]=nxt[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,id;</span><br><span class="line">    <span class="built_in">query</span>(<span class="type">int</span> x=<span class="number">0</span>,<span class="type">int</span> id=<span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">id</span>(id)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;query&gt; q[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dfnl[N],dfnr[N],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfsfail</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dfnl[u]=++dfncnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u]) <span class="built_in">dfsfail</span>(v);</span><br><span class="line">    dfnr[u]=dfncnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=dfncnt;x+=<span class="built_in">lowbit</span>(x)) tree[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x^=<span class="built_in">lowbit</span>(x)) res+=tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfstrie</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">modify</span>(dfnl[u],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> temp:q[u])&#123;</span><br><span class="line">        <span class="type">int</span> id=temp.id,x=temp.x;</span><br><span class="line">        ans[id]=<span class="built_in">ask</span>(dfnr[x])-<span class="built_in">ask</span>(dfnl[x]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> v=nxt1[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfstrie</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">modify</span>(dfnl[u],<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!nxt[p][c-<span class="string">&#x27;a&#x27;</span>]) nxt[p][c-<span class="string">&#x27;a&#x27;</span>]=++tot;</span><br><span class="line">            fa[nxt[p][c-<span class="string">&#x27;a&#x27;</span>]]=p;</span><br><span class="line">            p=nxt[p][c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;P&#x27;</span>) endpos[++n]=p;</span><br><span class="line">        <span class="keyword">else</span> p=fa[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(nxt1,nxt,<span class="built_in">sizeof</span>(nxt));</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        q[endpos[y]].<span class="built_in">push_back</span>(<span class="built_in">query</span>(endpos[x],i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">        e[fail[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">dfsfail</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfstrie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>图片来源：</p>
<p><a
href="https://oi-wiki.org/string/ac-automaton/">https://oi-wiki.org/string/ac-automaton/</a></p>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Segment Tree Beats</title>
    <url>/2025/07/04/Segment%20Tree%20Beats/</url>
    <content><![CDATA[<h3 id="区间最值操作">区间最值操作</h3>
<p>先来一道<a href="https://acm.hdu.edu.cn/showproblem.php?pid=5306"
title="例题">例题</a>。
这道题要求维护区间和，区间最大值以及<strong>区间最值操作</strong>。
区间和与区间最大值可以轻易地使用普通线段树维护，但这个<strong>区间最值操作</strong>是我们要研究的重点。
区间最值操作，说人话就是给出一个值 <span
class="math inline">\(t\)</span>，将区间内各元素的值限制在 <span
class="math inline">\(t\)</span> 以下（或以上）。也就是令区间内所有值对
<span class="math inline">\(t\)</span> 取 <span
class="math inline">\(\max\)</span>（或 <span
class="math inline">\(\min\)</span>）。例题是区间 <span
class="math inline">\(\min\)</span>。 对于线段树的每个节点，维护区间和
<span class="math inline">\(sum\)</span>，区间最大值 <span
class="math inline">\(maxn\)</span>，区间严格次大值 <span
class="math inline">\(se\)</span> 和最大值个数 <span
class="math inline">\(cnt\)</span>。 接下来，对于区间 <span
class="math inline">\(\min\)</span> 操作 - 若 <span
class="math inline">\(maxn&lt;t\)</span>，则显然操作无效，直接退出。 -
若 <span
class="math inline">\(se&lt;t&lt;maxn\)</span>，则修改只会影响到区间最大值，令
<span class="math inline">\(sum\gets sum-cnt \cdot
(maxn-t)\)</span>，<span class="math inline">\(maxn \gets
t\)</span>，打标记然后退出。 - 若 <span class="math inline">\(se\ge
t\)</span>，进入左右儿子递归搜索，然后上传信息。</p>
<p>可以证明，此法时间复杂度为 <span class="math inline">\(O(m\log
n)\)</span>。 <a
href="https://github.com/OI-wiki/libs/blob/master/%E9%9B%86%E8%AE%AD%E9%98%9F%E5%8E%86%E5%B9%B4%E8%AE%BA%E6%96%87/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2016%E8%AE%BA%E6%96%87%E9%9B%86.pdf"
title="证明详见 P104~105。">证明详见 P104~105。</a> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u*2+1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> t,n,m,a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span>&#123;</span><br><span class="line">	<span class="type">int</span> maxn,se,cnt;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> tag[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	tree[u].sum=tree[ls].sum+tree[rs].sum;</span><br><span class="line">	tree[u].maxn=<span class="built_in">max</span>(tree[ls].maxn,tree[rs].maxn);</span><br><span class="line">	tree[u].cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].maxn==tree[ls].maxn)</span><br><span class="line">		tree[u].cnt+=tree[ls].cnt;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].maxn==tree[rs].maxn)</span><br><span class="line">		tree[u].cnt+=tree[rs].cnt;</span><br><span class="line">	tree[u].se=<span class="built_in">max</span>(tree[ls].se,tree[rs].se);</span><br><span class="line">	<span class="keyword">if</span>(tree[ls].maxn!=tree[rs].maxn)</span><br><span class="line">		tree[u].se=<span class="built_in">max</span>(tree[u].se,<span class="built_in">min</span>(tree[ls].maxn,tree[rs].maxn));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	tag[u]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tree[u].sum=tree[u].maxn=a[l];</span><br><span class="line">		tree[u].cnt=<span class="number">1</span>;</span><br><span class="line">		tree[u].se=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="built_in">push_up</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].maxn&lt;=k)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	tree[u].sum-=(<span class="type">long</span> <span class="type">long</span>)tree[u].cnt*(tree[u].maxn-k);</span><br><span class="line">	tree[u].maxn=tag[u]=k;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tag[u]==<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">update_tag</span>(ls,tag[u]);</span><br><span class="line">	<span class="built_in">update_tag</span>(rs,tag[u]);</span><br><span class="line">	tag[u]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].maxn&lt;=k)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r&amp;&amp;tree[u].se&lt;k)&#123;</span><br><span class="line">		<span class="built_in">update_tag</span>(u,k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		<span class="built_in">modify</span>(ls,l,mid,x,y,k);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		<span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">	<span class="built_in">push_up</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_max</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">		<span class="keyword">return</span> tree[u].maxn;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>,res=<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		res=<span class="built_in">max</span>(res,<span class="built_in">query_max</span>(ls,l,mid,x,y));</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		res=<span class="built_in">max</span>(res,<span class="built_in">query_max</span>(rs,mid<span class="number">+1</span>,r,x,y));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">		<span class="keyword">return</span> tree[u].sum;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		res+=<span class="built_in">query_sum</span>(ls,l,mid,x,y);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		res+=<span class="built_in">query_sum</span>(rs,mid<span class="number">+1</span>,r,x,y);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			<span class="type">int</span> opt,x,y,t;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;opt,&amp;x,&amp;y);</span><br><span class="line">			<span class="keyword">if</span>(opt==<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">				<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,t);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_max</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y));</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query_sum</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="区间最值区间加">区间最值&amp;区间加</h3>
<p><a href="https://www.luogu.com.cn/problem/P10639"
title="例题">例题</a>
同时有区间加后，原本的势能分析就不适用了。复杂度变为 <span
class="math inline">\(O(m\log^2n)\)</span>。对于区间加，区间 <span
class="math inline">\(\max\)</span> 和区间 <span
class="math inline">\(\min\)</span> 各维护一个标记。
<del>然后你就会发现真的很难写。</del>
注意，区间加的标记优先级大于区间最值操作。还有，在进行更新时要考虑到
<span class="math inline">\(maxn\)</span>，<span
class="math inline">\(minn\)</span>，<span
class="math inline">\(max\_se\)</span>，<span
class="math inline">\(min\_se\)</span>，<span
class="math inline">\(min\_tag\)</span> 和 <span
class="math inline">\(max\_tag\)</span> 相互重叠的情况。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u*2+1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2e9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line">	<span class="type">int</span> maxn,minn,max_se,min_se,max_cnt,min_cnt,add_tag,max_tag,min_tag;</span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	tree[u].sum=tree[ls].sum+tree[rs].sum;</span><br><span class="line">	<span class="keyword">if</span>(tree[ls].maxn==tree[rs].maxn)&#123;</span><br><span class="line">		tree[u].maxn=tree[ls].maxn;</span><br><span class="line">		tree[u].max_cnt=tree[ls].max_cnt+tree[rs].max_cnt;</span><br><span class="line">		tree[u].max_se=<span class="built_in">max</span>(tree[ls].max_se,tree[rs].max_se);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(tree[ls].maxn&lt;tree[rs].maxn)&#123;</span><br><span class="line">		tree[u].maxn=tree[rs].maxn;</span><br><span class="line">		tree[u].max_cnt=tree[rs].max_cnt;</span><br><span class="line">		tree[u].max_se=<span class="built_in">max</span>(tree[ls].maxn,tree[rs].max_se);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		tree[u].maxn=tree[ls].maxn;</span><br><span class="line">		tree[u].max_cnt=tree[ls].max_cnt;</span><br><span class="line">		tree[u].max_se=<span class="built_in">max</span>(tree[rs].maxn,tree[ls].max_se);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tree[ls].minn==tree[rs].minn)&#123;</span><br><span class="line">		tree[u].minn=tree[ls].minn;</span><br><span class="line">		tree[u].min_cnt=tree[ls].min_cnt+tree[rs].min_cnt;</span><br><span class="line">		tree[u].min_se=<span class="built_in">min</span>(tree[ls].min_se,tree[rs].min_se);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(tree[ls].minn&lt;tree[rs].minn)&#123;</span><br><span class="line">		tree[u].minn=tree[ls].minn;</span><br><span class="line">		tree[u].min_cnt=tree[ls].min_cnt;</span><br><span class="line">		tree[u].min_se=<span class="built_in">min</span>(tree[ls].min_se,tree[rs].minn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		tree[u].minn=tree[rs].minn;</span><br><span class="line">		tree[u].min_cnt=tree[rs].min_cnt;</span><br><span class="line">		tree[u].min_se=<span class="built_in">min</span>(tree[rs].min_se,tree[ls].minn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	tree[u].max_tag=-inf,tree[u].min_tag=inf;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tree[u].sum=tree[u].maxn=tree[u].minn=a[l];</span><br><span class="line">		tree[u].max_cnt=tree[u].min_cnt=<span class="number">1</span>;</span><br><span class="line">		tree[u].max_se=-inf;</span><br><span class="line">		tree[u].min_se=inf;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="built_in">push_up</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	tree[u].sum+=(r-l<span class="number">+1ll</span>)*k;</span><br><span class="line">	tree[u].maxn+=k,tree[u].minn+=k,tree[u].add_tag+=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].max_se!=-inf)</span><br><span class="line">		tree[u].max_se+=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].min_se!=inf)</span><br><span class="line">		tree[u].min_se+=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].max_tag!=-inf)</span><br><span class="line">		tree[u].max_tag+=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].min_tag!=inf)</span><br><span class="line">		tree[u].min_tag+=k;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_min_tag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].maxn&lt;=k)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	tree[u].sum+=(<span class="number">1ll</span>*k-tree[u].maxn)*tree[u].max_cnt;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].min_se==tree[u].maxn)</span><br><span class="line">		tree[u].min_se=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].minn==tree[u].maxn)</span><br><span class="line">		tree[u].minn=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].max_tag&gt;k)</span><br><span class="line">		tree[u].max_tag=k;</span><br><span class="line">	tree[u].maxn=k,tree[u].min_tag=k;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_max_tag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].minn&gt;=k)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	tree[u].sum+=(<span class="number">1ll</span>*k-tree[u].minn)*tree[u].min_cnt;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].max_se==tree[u].minn)</span><br><span class="line">		tree[u].max_se=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].maxn==tree[u].minn)</span><br><span class="line">		tree[u].maxn=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].min_tag&lt;k)</span><br><span class="line">		tree[u].min_tag=k;</span><br><span class="line">	tree[u].minn=k,tree[u].max_tag=k;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].add_tag)</span><br><span class="line">		<span class="built_in">update_add</span>(ls,l,mid,tree[u].add_tag),<span class="built_in">update_add</span>(rs,mid<span class="number">+1</span>,r,tree[u].add_tag);</span><br><span class="line">	<span class="keyword">if</span>(tree[u].max_tag!=-inf)</span><br><span class="line">		<span class="built_in">update_max_tag</span>(ls,tree[u].max_tag),<span class="built_in">update_max_tag</span>(rs,tree[u].max_tag);</span><br><span class="line">	<span class="keyword">if</span>(tree[u].min_tag!=inf)</span><br><span class="line">		<span class="built_in">update_min_tag</span>(ls,tree[u].min_tag),<span class="built_in">update_min_tag</span>(rs,tree[u].min_tag);</span><br><span class="line">	tree[u].add_tag=<span class="number">0</span>,tree[u].max_tag=-inf,tree[u].min_tag=inf;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">		<span class="built_in">update_add</span>(u,l,r,k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		<span class="built_in">modify_add</span>(ls,l,mid,x,y,k);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		<span class="built_in">modify_add</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">	<span class="built_in">push_up</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_max</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r&amp;&amp;tree[u].min_se&gt;k)&#123;</span><br><span class="line">		<span class="built_in">update_max_tag</span>(u,k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		<span class="built_in">modify_max</span>(ls,l,mid,x,y,k);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		<span class="built_in">modify_max</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">	<span class="built_in">push_up</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_min</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r&amp;&amp;tree[u].max_se&lt;k)&#123;</span><br><span class="line">		<span class="built_in">update_min_tag</span>(u,k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		<span class="built_in">modify_min</span>(ls,l,mid,x,y,k);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		<span class="built_in">modify_min</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">	<span class="built_in">push_up</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">		<span class="keyword">return</span> tree[u].sum;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		res+=<span class="built_in">query_sum</span>(ls,l,mid,x,y);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		res+=<span class="built_in">query_sum</span>(rs,mid<span class="number">+1</span>,r,x,y);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_max</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">		<span class="keyword">return</span> tree[u].maxn;</span><br><span class="line">	<span class="type">int</span> res=-inf,mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		res=<span class="built_in">max</span>(res,<span class="built_in">query_max</span>(ls,l,mid,x,y));</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		res=<span class="built_in">max</span>(res,<span class="built_in">query_max</span>(rs,mid<span class="number">+1</span>,r,x,y));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_min</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">		<span class="keyword">return</span> tree[u].minn;</span><br><span class="line">	<span class="type">int</span> res=inf,mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		res=<span class="built_in">min</span>(res,<span class="built_in">query_min</span>(ls,l,mid,x,y));</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		res=<span class="built_in">min</span>(res,<span class="built_in">query_min</span>(rs,mid<span class="number">+1</span>,r,x,y));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">	<span class="type">int</span> opt,l,r,x;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;opt,&amp;l,&amp;r);</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">			<span class="built_in">modify_add</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">			<span class="built_in">modify_max</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">			<span class="built_in">modify_min</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query_sum</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">5</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_max</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_min</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="区间历史最值">区间历史最值</h3>
<p><a href="https://www.luogu.com.cn/problem/P6242"
title="例题">例题</a>
这里的“历史”不同于可持久化，以历史最大值为例，我们称原数组为 <span
class="math inline">\(A\)</span>，定义数组 <span
class="math inline">\(B\)</span>，则 <span
class="math inline">\(B_i\)</span> 表示所有历史版本中最大的那个 <span
class="math inline">\(A_i\)</span>，形式化地，每次操作之后，都令 <span
class="math inline">\(B_i=\max(A_i,B_i)\)</span>。初始时 <span
class="math inline">\(B\)</span> 与 <span
class="math inline">\(A\)</span> 相同。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码先咕着</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/08/23/abc%20%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="section">200</h2>
<h3 id="d">D</h3>
<p>考虑鸽巢原理：枚举 <span class="math inline">\(201\)</span>
种序列，必然存在两种方案之和模 <span class="math inline">\(200\)</span>
同余。当序列长度为 <span class="math inline">\(8\)</span> 时有 <span
class="math inline">\(2^8=256\)</span> 种子序列，足以覆盖全部情况。直接
dfs，时间复杂度 <span class="math inline">\(2^{\min(n,8)}\)</span>。</p>
<h3 id="e">E</h3>
<p>拜谢 <a
href="https://www.luogu.com.cn/article/xz0tapxl"><em>Kenma</em></a>。<br />
容易想到枚举 <span class="math inline">\(i+j+k\)</span>，接着再确定
<span class="math inline">\(i,j,k\)</span>。<br />
考虑容斥。设 <span class="math inline">\(i+j+k=sum\)</span>，方案数为
<span class="math inline">\(f_{sum}\)</span>，若忽略 <span
class="math inline">\(i,j,k\le n\)</span> 的限制，则 <span
class="math inline">\(f_{sum}=\dbinom{sum-1}{2}\)</span>。此时对限制容斥一下：<br />
<span
class="math display">\[f_{sum}=\binom{sum-1}{2}-3\cdot\binom{sum-n-1}{2}+3\cdot\binom{sum-2n-1}{2}-\binom{sum-3n-1}{2}\]</span>
确定 <span class="math inline">\(i+j+k\)</span> 后枚举 <span
class="math inline">\(i\)</span>，计算相同 <span
class="math inline">\(i\)</span> 下合法三元组数量即可。</p>
<h2 id="section-1">201</h2>
<h3 id="d-1">D</h3>
<p>比较基础的博弈 DP。</p>
<h3 id="e-1">E</h3>
<p>看到树上路径异或和首先转化为点到根的路径异或和，因为设 <span
class="math inline">\(dis(u,v)\)</span> 表示 <span
class="math inline">\(u,v\)</span> 路径的异或和，有 <span
class="math inline">\(dis(u,v)=dis(1,u)\oplus
dis(1,v)\)</span>。则现在问题转化为：有数组 <span
class="math inline">\(dis\)</span>，求其中元素两两异或的结果之和。考虑拆位，设当前考虑到第
<span class="math inline">\(i\)</span> 位，所有 <span
class="math inline">\(dis\)</span> 中第 <span
class="math inline">\(i\)</span> 位为 <span
class="math inline">\(1\)</span> 的有 <span
class="math inline">\(cnt\)</span> 个，这一位的贡献即为 <span
class="math inline">\(cnt\times (n-cnt)\times 2^i\)</span>。时间复杂度
<span class="math inline">\(O(n\log V)\)</span>。</p>
<h2 id="section-2">359</h2>
<h3 id="e-2">E</h3>
<p>设第 <span class="math inline">\(i\)</span> 个水箱的答案为 <span
class="math inline">\(f_i\)</span>。<br />
考虑分为两种水箱：</p>
<ul>
<li><p>是当前最高的，答案为 <span class="math inline">\(i\times
h_i+1\)</span>；</p></li>
<li><p>不是当前最高的，设上一个比它高的位置是 <span
class="math inline">\(j\)</span>，答案为 <span
class="math inline">\(f_j+(i-j)\times h_i\)</span>。</p></li>
</ul>
<p>单调栈维护即可。</p>
]]></content>
  </entry>
  <entry>
    <title>pb_ds 简介</title>
    <url>/2025/07/04/pb_ds%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="这个密码看着不太对。" data-whm="这个文章不能被校验。">
  <script id="hbeData" type="hbeData" data-hmacdigest="55a92bb72c5c4ccc6bcf43c82bd8cc22021e1c33dc87a5f45ad349b1de64cc32">8ade9e8308e767f1a274156f57751d9a3f5b26898da3a0bd68eb817414d883a079b01c06d83aff195d034fe3e1dfb14cd836a9495008b96df4990fee0de4a1f2dec8ba03409cf72db1f8d7023a5cc9024301d725ebf0d2733d54212d4150a0a2bc38b509dfb12f541c6c1edfcf0c21e45dc0003bb62e64a97572121e2a24ea4bea2921031fcbdc5d024132c89e688ef3fb7827a4a82740c79e07e2c73064902901e3e920d5534cb4f4250648bf734276455bb003e7594d0de366611d6d709a4195b985c90edae738b63d9f9903eb64c2757b14d311e3690045f6c23660039ed364cd8fdd74ebc2c9e65d3cd349a5ff9cd2da51db3c2925da3c2bba6efacf67e4f9c0f8b380c5546dd91cce76efb894ef7de4f585e02c609b3106164459be49badc4092ffe4969692d60707a6173f6a077d273938c991f364419ae9ef790cf9ef207fb0e647897ce6cbeee0f4d06c03763f877daf02e520859a74215333c5ea55e622a447a579b609cf59eab7dc3c9d6e098a54d0c33f388f5ccc7363738d13a44cd3a0c0e127717abf85ebe79973d2e70610f38ec4d96b1816de4f0aaf3f2a50af0513003ab4f0064912dbe16e19bf8c41a14a82b5463558bf156f35cf753173fbbead226266ee4de43519ab538f854a324f02a5ef5697435b4c033ea075dfcbacdb583ab197175316acb3189e1780dea28ac6ad1dcc2b9041b4a48b4e58c504552c22a44ebacb7c5400af5d2c3cfc7d48109a933d84e157f9f483c6d481589aac2d5efae2571829409bbc9ac70ff5c74cdf781cd0ac7d630683247aaa9865286bc57cbf1d072ba29d840331fe5e9955e88106d781105de31133813ca316fb8ca8c1d62571b065d457388fafe9a0af6906e62b7d0899a33a338b404845ed24feee1a2d89850e7cdb53dbedfd578c87fecad0b9c74814debc1481c1e51e17e2f083a3eaf3be29869c15d61c38b809ba374f3d0648c22b10863f18b8afe53be2a6737a498b9e840e250696cc451b6475e75fca3d562cfb9ac3df58bed297ce44e36739882dad61093e570d2fdccf6d48c3dd4a5be9e596ba8f35506b8e9414658b87dde19eaadefd755328114f889f38b58bf2669abfc7d30c8d425cf0bd0c8446fabb23b649bbbd1681ce2ac3b5a347c8cedd63a1ec35fd792a85f871945a6544030d85cdfd32a002cdb78e976cde6eeb1eb76bf3b28d3e244e5b8cea6c1195b699731609157a3e87b2fe1113b7e7b84a39a40c8a45190c816b552d0bbab204d5ac67eb380eeab5486b650904f5c6522f40c766b0bf9acde91215d95599bc94463ba2a69cd67b5d79f9541deb823405f2899cfc989a00066bd81b1e259712822608c9f6ddd1a17bdc0e80d9b69cb5e968a12360c5987cca2c4d05af59e9b48102e63dbd6e80cc884b65a316174caa04d70b827c21f4e3cac7e95990b2a107777bc9ee4199849a9e981b039eeee52cd0c46f0f4bc4d847624b5e131ad644b60d229c6621f443cb4af9a766d5084afaf32a89767ab98044fc4f9a283bb4a8e3d2e1f4f0dafd85e21c642b6caf0f721406c51b73d9f54422a95098b233b6e5e80da3bc6af2d26a71c82d7735587f01f119a2cd89f1f9cdca5edeed4b77335983506d67db1717a621d872554eac1ce8743b9006ab28eeaddf702001cca70b6f614918a5ad8b35407079573d6b1d159d7c088e61f5ee38895e983a7d3eb5b808c91ead848cee02323e236f8c7661842b24de219f908be134d563255ab0720772cfa459ae59c32d51233a0b86b80e12b4315b83d693bfe1613908ca01e1c16afe2cadeff0db8a8f37ce440bd6a006e07303261f86579f146fe557c4676b39625d49e7038d604dc485ab52dd61083e0cc9229a618788bf54dd83e1caf46c91bb0095c2360f69472f19d46c87e3638882a95668a73be6f0ea0155c1f66340e80d26b2216990cfc4a3daf2bfacb7a09e41a0ca1da231478a80411b07a6db1cb13bbd25aa91e89b8e9c02c2098d5c2ed0e068d294233267b37f1d7541a333097018118f70aab942e42c3b356aec4305aa9a6c4494436223c95e27d11cad8c57e98c795d7246ca42f42e14aa45ee789ece60f6a4caeb9e29b869341455f3d7fdf36b3b7442ecb77a4775d4dae86a836f904db4c1a4da075b8b2fbbb7d87a9b1adf6af59f11c81dd4f40eba2bf750c044aad93f290c5e945d96b4ee28757eaed437b242144fbabf42929ed0065723250902b6b52df48f8cd43d15239a784b4c3111ff20380113167d14b7ef50c7ea27da20e18bb2569664294c7538ab23c23efd361a71a44ab7e2a251b7cb8177f5851140a1103c04d0ffcd89a0ea9ef844284806f004e692457ac8dc629710407ff059d5199ff339a489d978c9717610cbab7a41cbd5b7312c4f5c95cddfac8601cbd421ae234b94d435b812092a099c4bf9d367cfdda1a0f153074f095d3734ae8bc47d984f7540898bc0f3cd510e1c6f2999cef3c7aad4608d7653776013e878b46f5371c3e3f43a8e6d828237cb5aba7bca49e11cd9350bbaa43419618520e4e110cef0e21fa97bf2a6576c974e6e74cd664e87d17125da40dfebf4244d005ec1bfd13cfd9588fb3eb695c89e46f586b0e3cf51c3548cf8456c4c273b302a402b297f6cbc96ae0b04f06643109d1e2f1dddfcfd070ad4b98452a82b77b58853ca0261df6bbb7cfefcdfc70b012054365aa926d4f9a71c9f171a819f678818c57d973fd88228faa0890089a1f247bf29d1b838170dde5a2b944ba0498feac4e13c383a122a7a327702994863bd5394fc1d1d94f75a7827eb10b3f5483b462aa4783859683f2e2deb2a72ee79a8e767009d8d8797ed193ff332ae4ff18370a1d0c62947d17fac8bbbf28a7999e7c205b00b2be5fd896f4d61c717aca8bd9f5634ffbf13f696d92b9ccac227e7147031b047e8f8e8ea5b4c95b7fabbbbe90b40b9bdb0a59329ebc6068373b22d04fbf5637a74cdf83cee0434dedc90d5248e2b12c35af10e981660ca479730ab46234a1b58483356e41c4799858bf4d1a445072233a4a9ee44cc87bac6af98baab3d3048db6180988df8079a52af2d4defbc303ee9f742adeff551d746c7a15138ded1e1970a4f14c48b86e74d7fe681b89499c398abcf0aea2d0275d4b249509b96e1cf0c45518219acc82080135280d45821052eee59f265b13c44506c9e3af03a953e8e3be223994a07eac88f35b71c3cb3657ddc56d4f6c3621d6e6e42c254603e514c2c4d3ecd0d5706ac32b418fd9fe01eb4cb610112ef60eaa37006de73e8f959f8f50a3bc78a8be0f2c54cf817ad50f8b866fb6d71fae08d4a6096c20df4e5d14070c8f93a87d4d475ecbce5e9da3a38d6b86e34c460b1542665902904c63d3cc4da464f94e2e9182dce4ed76e650563c11fab6331bc5f8aeded328a376d90a7c51702083b51078816e6d6e43783a4d6938b3f780511dd0fbe1b8edd600ff4e8d9fd1209eb4a542e24708f97ddfc70cd5434ea23c163831ae237fef89366ecc8d9fde2c8b660e649fd7b0b7cf0e8ab080089af27fbe48c86b2de62196af94e811919b29907bbed1bb335751301e6a71277be80f1d57411be816707460d1ff882a4b2305d4431810c07e0f4e0eaa625cacde2dd3961ea19852e69247cfd526ea3481d4d785e8c7d6f6bd8adcf06acec9e0e1d8625ffc748e464b6e51605084dc64146504f1ec928d6f005869f9e0792346cb4569802d9ab994e531e10016803ff8f0c18c6be50538fff3fa153beb29bad8f126cd679dafc3d78ab87aad0ef599fd18d4a9f51aba6014659941db4aa43a1f7d0d621eb5f6ccc90a7e04ee0ab71a84a9ef827eb1a53141f3bda78a227999106a29c6a49b218508a6d243c688363c03471397bceec53281dae74bcbb8ce10b32be9f70f9ba3ff369e9491bb616d6bd27a9f699f0cac45ecdd7fcb3cffb83209d98b4bc56932b1b391236b79072e484d0ce13781034a27a8df26959a11cd53500e0870ae6d37ed9d3106d5958353dcad8e19296fc94cc29c6af2e9f6e78c534daf727fbc67591e41bcf8b697bc800f545f316f7e839855111da42d176830105301123039a0b1db9db63a919f09834c03be16c47f64f0d9bf422be6fa11ff4617ca92ed8816aa6657240e8168ab02e4db3c6b285e2c97a0dd77681f57d7721062745f4ae5b4fe66cfdfc86bd41fab457339e2a840677e791a41f4ada775a7405c61e9ae44b2003a55dbc365b47500a46dbc46c21e7a7b8bbf7ad36ab81473945142bc237746332add5d28a9c4e4a9fdce1784cd169b7480cf43834362bf94d38e804ee74b8acf4ecb931695ab58a5002fee0a1c093b44f94fef2d6c561c7b6193f7ec91f058a40b197b5093f6a1281459a42b23dc03e91e3daf8a1b14db2f4044ac505e1fe1682c0bec0a509d5575cdcc329a0522ef909a7bf858427b977285eaa8bc4f683e642fbacd29019ba14c64fb68b0e0aea7f3a427fb822c60fdb170d5da76b5f6db0190422f121f833de4d0971fcaee6dfaefe810a9a12a22b7b84ba96c78322185bb8ca4ff605979a4b5378fcff46617fa4434fc9c394578edcff40aec2fbf96697a5a45f39cb38d372493bd57ac957e057ad3f84677aaec686f6cae362c0862a7d8e9aaf01c5c058f041cb610c3e22b0317b5ce4592135f5004c8a01de031a820648aed0ee9b5f0548e38a3d0620211e5d367dcf108d0eecff06af98de09b18aee3ae75d080efe0343c646b1a13b92e975fd08d3696db4f62a886fb87c5283275dfe377b53946ba5ddfb8d5549185a7b5e96ef73f0888eff0160ddc33dcc0dca6deb6ad53a5134b7856eaf5c5d72c5edcb52939d2df892aa07f894e634925b85d6258db1ba7f77919330ef19ec8b11f404c20a8594dad7d3468f43ae6a61fa7c1516dfc9f2b85797b14186a886f49af83b1d541838b1596aba7f5f643ff6de3b63df953b6bf537d2fb4d092542e5d2661b5d1b9564e5017f67154140d2bc490e7a84d4723d185d210a7ac4ea960ed79e845800b01649b3d5774db906c6cb610b6d8c39cc7bebd81eb6edea68104890eada304e702cedc6520514fef052c2bc0e7abfcb403fe9dc3ce6707483b1543c34323b9dc97a1955896f3c9a0ea933f944762442fbe85833d3e2ac21126bc01a98e0dc54efa0963b708ec3e73b0bd31eca74f83a300adaa1c1787bf23305a4f67b0068e59b8f7e146f652151e6cf8009874ec38b304d37e4f75a25bee5184dd9002ad58574f49e05691a5d6fda62c57d6937b459e4addb0df9162d01000f7b08724e9b0628fad90b9600ea9cd36154a055098ebfe9b1482671d8d80826101e86e78386d4cb96fdf773b419d09be8a7cd3a274322383b8ab8a6277dc7886d5d469576b3de26b713d2077a3619827287e18c7880725377f213d183ac48360a613a93672c447464cb5f21b07164daa86118f760d0f53a7ae6b8e912146d5ba2b7ea49d9da3b3c45e937c1b6f187d78df67c91c8d9b5af897f5c04fd3e9c0061c6ece9137bce465e4906e3f72c225b944da1467f2cd23710d6fdf4cc6ce32c42e12c91b9c265625a2128c0c28ebdc6831d42105639cf5ede492f4031338c202ed85b11627d0d18a4b4d7ccd056ea7febf3556b6bdda41d9ea5a3bc7efcb2b88af981d20e26be417e83ae1f9a6f095f159fbe2f7326bda91727154c0dbd115f1aa21e4f86e24fb6ead3c4c36bcc3f4a27d903720696df665ecd9a255a73b1378f13908de752459b48959159b7cee9190d4976a72a60c34adbc715623f24aebb2bf533134e5dbdb49db8a8d4541012ac695025647dd7f513b8fb4c2225c91e4686735bff9de7753659d9cb4db64c2a7ea71141edaad2c1d8cc7b5a794fbaca9a88b192f04b31979ccbdf720057ef9776486cf1106253aeeeb622edd6d3c8fce2d36728e73af9ff078354950256cb54eab1febc61a8e14eb0837efd64c706ec7f81f97fe6f38cacbae3e7a894fd548c5136c9018140189e31432163b040aa062c81e33b5276f16378917b44a71941dee2aa724a6bb966254a49a67361bc61398ddf2889b352b0ae931c5f39860fdbef10f2ed124e2d8f9a3cebbbd7a5b90ee02786a13601c5f9289a0ffb54ce5fc559fb4c8a4cb358d40316e5732a35a76f7b7bad2a4db56fade38a82bb57f0568faa2b83df11e0ad59552a9b928bbb3cf911bd99f52157deddce7b8c3bb39e894d0614fefe824b408e8157e52815fb16dd88476f1351da45f947fb54c7e4bbf35ce194ddd501878186cb60da33f9fc94495fc8119a0713294dfbe6452aa69398b952b9d34b31d9482b6e129275929be4e86e7edcd8f88dd5f5b179be4a94fad900df7ca6e9cd4b768ec21a27705dfbe1f18a54f7e4e700ea5f2ad8184541f904723c411a57651f0d6a2118129ee5d579acf741006d75efb232e4f7ca5f3cf95c338cef6a4e8f45d2e17d4150b61af5e847ce0558032f2df1e4008c59016b3f959635300c404d0303e92eba9ab46e33d7c32289706f0e7f210944e4fe3e452713eeccc6bfcdd35f04790cfbf9b7a9697ebc9643ca806dfebd37df65181bc45d1846de2a40f2ebd639961d4834fbf769491091b7402404b60058ff1a17298da586552acbfeae32ed35fd6ec28aae7a50f8382b8c2699cf555db4cb951456e0d1c91f10773b9b9839bcc393e39fa47181b3ae73969fade6ce6d4f45ce4331690b6e8ceabc6bdb39b38e82178fd713d4aedadff4b04a70b43d73928008c0aec76da95d154d78d1118794daf7ceb383d7a419b689b18107a34e69fbd25a94aafa840a61896140603a24fe0074057025c76bd8d275b93c3ecc3b7eb340214582e69d31c27fb4c21ca1d07bbd66837d84e26ab6aa8686c3b0b3621c557f586d2c2ae5abbea439a387b44eac3d6830c866e053a5ee533e68893eed0b6858af6de11a52db07aa92949ae1c14ad2b9d346038f1a370971c7a6f25076f33bd7fb279a87686f863e84ef13ebb35b1582625e56f58aad3725059a82075cfd020cfc7cfb343aa58820562d2cc013ff22437b8069cf93dc4a9af5ec1c9cc7480191659e07607ea68327f3cd2d04a34264c0bff8088947ed55dbc46decb6b1785d85fa28177b97d4a6ba5db1895ef2a30e28d2cd76df2d13f2db4ebe3392ba0192f4035e30d06c5b72abc67435619f41975d49fb7ac946dc1dd80ef0fd9f9c0500cdc14223627b5a99dcf128a61f7e2f115df6b658aa48233965617e5ad3f924ebabf578aa72585d16612753e924cd3ef00d8bd319e4b90f14f71a9cd3b4bf06ab296aa10d089ffd8dd4ae9e87658f8a0c8aea83d37cb7e5bb35e7dacded806684c7a2ecc29556a51ba3ad49197a81cbbec26bdf3d90cc05b0d03afd91a325d238f36eab2045aede66fd7509b6d6de3fa5100b1027897a49d4ca3f872e8b840bee19bc9e759dd8a3397a00799b99796212d0985850eceb5dd8e3f29a9c865dcc5fbb198520375cc050c56ea7291a695b00838ecb54e834a97413a7ddfac2fb5d75cc79bb8fbdbd43a5de7710e8981c40273817af65003c1c9923fc697a844648f9f1d7ac735c336192c261c2c8076e5e6df4091b22959a56c2846297a2c6ae94e8672e7304fd1e4dd6ad5757e598a7e290bdb5c7b755c3abe4c4ae69a61bee99cd7f0c5fd88b289894cc92b6f00b1ce4052c338b2a48d19063147450319bc37c7ad05a555189b4b946793239d021148710210c580425818117b1709f1be6f847cdf1be8c4d939a2f6209e2c2727c095e1c2968a6b851d336dbce57a04b73677f513c564ebc2d6f7a76fe2bf10614896f47bd79e24fe022606ad776372a21a4c1ee8a80aab92b8b7cb6481aa2c89993286468e2acd7065a3775660067e000b5358b37519bdf5f50f85a6ae6da0a186c0d0855ae86eaade4d1c776a7bb688656ab98a592c589fdeeea51bbe902c40b6ab01437b8238b8098fa89a0aca4e8a06866596c10de2ab9a142ecf76b9f05aeee34a18210a1e1493c792bc8608ffa93b9f99c739ee1d31a45ed59a16b6e4cfdf13a360a84c5f56d26be4c165308534d10365d863dc573fd1ca02c8e5e8b7f3fb7ecd06832d0cf3e0e792d0f7282a216bda3b908a13eff6ea0af1a96ca0796f28ddf890e46a028868375ba3e347d1d3323434eefbb9beac99f4d7ac67b8966e9db676c1dad356a32d76ba9bbc8d255af61f11746720e2fbcce147c276eb2dd7e73da0372bf5fd89c3ce7b349bfa766a77a8dbd2d4da9e25d1a3887ddfb0b99a30c95b056c9b51c854e44ef74ae1f318a04def7a3edf951ee7d94d4da8d0e04d3236a1a93166db81f8134b8fd881b71f87c5a3e1c7e7e7582b33d488a6378c84612111529fe04979f15d19e36e1391bab6b8323c051d3498622a9f36bb7d3ee45a8d3968fd09f7bc1721e1c6a5675771fec087a16c6bf5492502bf8019a5309cd76c84d818bc740779ecf0f5860882d6a5cbba8e918ee3d3406189b3b2ad23801ddcf0b98a2f7970caa7509405c38b9997d4232c29003f1f8f80b4b95cf708500df171de5bdb1c8adb4321216d7cb7d1ada53e000acfc05505675f2e078a3c13f1ef7427e8ea9d48923a1a56a86b112490a16a0a8c551fcea723b6db97f96ceeb4b32eadcf702bd11313498653fb1556d13b03d5bc88ca1fa239886f74c7ed92e4e73b69a930ee6e5ad590030ed077b3ca7cdf91045a30c93e97d6834f25f597cc511618067548707239b2cfcf00a9b566a34f39b8d73975be2e8b964ca17e0e5da90ed48ab3525ae0565335b7e19392301f8767297d6cd91f9ffd3f16974c92265c28904053440ba6907fa3da9e74ede1ac77a5324855aca31131a0825295c02c7d0cac95953b07f6dd8df8aa137a174cf37f889db1e33d7041eb51599d3bc9a184a0debf833e00ebacb79e5859cd82bb147b5f6d3a9a0c635810f4b30a0ab6cd9bd763b3e05fd84dea2614e3d29c4538c70d63527d0717ed1242a39b52dad83b7512a00ef5a061630948925715be49850f1bae8e2b8c8a71ae51fe79d26f994952f95021fb526f03edf1442f2e1c6df3bb5d52f00960563d868681a2432c0a3d33c715ef68338fcbe4b01a51d0a237f3cc342e094fecfa08e1300f78754690e7b0044af891df55eccbb16e4b1d6de785dd3d9b28337fad28498594515f23cd61944bd409c6ea6543696f9f2df0feec7ecdce55ebc04fc0f0e93cf3cd9e6688fdc7f9f8e7dec4a274bc8e933e1931f1045517261f37534e052990e05d40a693e3cd61b52de8b8a91d225223a794fc800448389d1298dea0a8ce0614d69a1448fdb2e0a72204bb56e40cac15af6a76b91cd1e79cc438387b8097e54189a283cae9aa192ade4b766dd2335c181fd86ab2e65c5563cb7aa7dbac7b4bee3699b0e74f48e8cca73dbf9787d31b30d3fc3bbf6cd4af089f11e0354b92819b21fb2b215b0cb3dd4ab5bbcd49ce49fa2426d48ddb67fc9323f3452b427b701314d7d6a1fd05162e0c474f201c24f3a9a7c7d6e689a4d786a35cfb87228a60f0d8d89d1021f06e092d2e8e1a482af990c6ba33c9e5c92d3596ce4e552d687867edce26bf0f5bcb593a84018d75029aca1d1d25f6e82faf15ca4c80179832744c19edc12920942684425d10a7d5618f47ca63ae890b0943c5b503fd584a378ecb64a088da866a2c7ac9aed13c68f3cdaa5b041ffc9c532511d416431a0202bb32498e58198b135f5e3d4545663f06e0121f613974e8bd1d84b4efd7ee4a8a6efce26b6d90f9723066ea0998244811fdc04cb5b4b494d60e7121c4aa1161985f4529fcf12a18f9fde4d5a9b2190204caeb9809c8e93d62caff46df5d208fcba901ac918d740d5fde653c99a93392ce9b3f58ffe7c2d7d5831946c0c6db81eac7c991da7f57bfffd2336e1e35db225f188484b7e86695332bbec5f107027140bc2f3b0296784636abfe7be4a7b64891cea0f2ea07a58b57831c0d06d2a3cb8b4cdbd02f75c7389888df17d2347ac4af08c9809d0c8f9f22deba60f64e747e5a8c9b7aaafb90600f8811a2bb58a4650a9cfcb477f78b022373a6de21c02747fd97af7bdc82d60c50634d71a01aebcda4558a7267c1ae2f1a8a64f8ed6cd6e005fcf5f8d9457e098973e28584cc5e7858d28cd47f7812083a9cc2cfd2c34d65cb34f80cc3860227549a9e440cf13dae9c949bed98d83eebce1dad1c8935a6e5fb88d0eac828c5f45b98202d3cb6ef2fbe127b83b0d20c3c606af6c5090d6ad9cf48d492e75225dcc1bb03e72e2c46f28e25217ae663148578196ecd182c0c3ed449cdd5aa0fbb859bfa91ce4ba32263c751fa10f0bdd1fb1c747d10b5bba34789b87c8af0bab21944ee32dd4ab1eb7e8ab1630c040a7ad6844011713c343dec8d358e557f869b1a70b79613e656ca665d0130c6228c5cfbb15df9c8931da4157eacaf1742c433f24252ec2f08cca3ee7f0d732bcb78b6a52000d34537506e74f98633c0f9ba088042feb603fc1275cb39d3a09f5480b800dc1cf66f4ac253375952ddb02c9e6ee751ffdc36f10722d8b7ab284db8176f948dfe914301600c6061a51a69f57d58f52882783ffeae53320767b2c1370c454c17d40eb50f989992ed152d593a967f780154f08da117db18640621b4ceb38ffaeaf5a6d06a415b6a767997069e8ff4d621603d73c90e09730cf59147253f5114a3571d61ef31c3cc70db736f7c8d957bd2536d80688fbc68dd692713e968134e60d7757a899783420a579733800e1e2cef2ac701c9428ec3af1eced8b3b9253ec0c852931eb74707395f1551473c485813dc2c754cb7a2be96c49ad67da0dd00529deb316be9b345b5453ce35f492de61b23f3d2ed3d905b831c579a2822520897031b695d6fe982fd27bb5b0c7c7067654f19e1cdcff212234ba6764f2dbe2ea12ca926b1589fad0242f8f8f8c7cd09b855bb8362c1c36fc08c41ff3942fff37d0f4ee5afbff0a13026734e8fe679396d68cb5a161f7561a0b4f1b1c2df22b965d94140858e230ea1e911b7ec9858d8daaaf5eff1f7f61fb4d515f3aac295bf7c8038120049a1500311afcbd7958366653f84bc39a92137d3c29050b22724431ac6a447b80cec7ecfb9d338fe9b1a7eee017dd84c6488af5ffe51bcadd260bc011b47a1ae8347e0d0683a535d7cbbaa3e143a37e3f812ce31174812d5276accba30eb36fa3f22f2b9fa1f1e08bf2cf519366311efbb1d3a954fa8a84827a62397b5fb365914d49cca8346973db6502c62f358673f9b3ea4480be9202d38861dcfceea16b6f26a3c49d7b998ead1571087f6c434a960b22dbd53afd9232c88af4142c4fd294c84f6582d7b7ef14e914a8ce09dff466320b4ca7b37d3ef6e743cbd066b262fde73be2e9af0a234ba281490cb096e95cefd2204b80e1590615a9de79a7bb6e5c9b25dd7e7cb2a26d80a82bf1876200e9c6b7d7490795bb6bf7eb44323e12f9ce05bf0f0c105c8d2ce29a8f39a05474db28bfc195c07f9956ddaf435527cf1d2e5b7e741aa6a3a456cffed65e67f2558371fd74a4cd36ade8c7d0e541f1952edadeccf33dec2d7e9ac9798e4ff473ed2a723305eab9348fc505b4eff3e9f2fa1fec971887a9ee8fc830126013001a791a6743db4983306c38a284162b5ec73290c55d6a676f25937d93169dc6b46afb212b937aeaba6529ded9683456c37660b6da1f7a7eb260e255219c395a1d3bec46f4623ab07ac30f464f3642cc62a11b8421f992893649d1585d006066d0b55c4af476603e265b90629d24775cfcf18d1f754493f876b5b02725fffa53c5bea2ae837fd7ce53dcdcbbdf7008853aac313c9a3056aab4f0328d7fa7a1873ed5a74c400e94d1776168f88867316057a4c1293708ed7ce067342aac7faceac8a4571a6c3f4f2c705b06e7d6589069fcd4df99a37bfd4776b90c38f9ff786c21393bdc1d0fa79a05a5100a19e3dc5c368fd6fdfddeb59bdb45d51ac8c5720ebef299cd0a83825cf28680e8d7a515b5671e549d4db0bca327c78fb5fd178a55117f8e4c73b622f79d472b01d368762e3ad5ffba224e56c647816290f57f2b5b8458045869ce861244cbeced98dc4562cd623e6548e3ea1f6fa2004438742b3733fd891aae89349fb92bb28916691a73f2ca865e845d87ca6befcab8e609190b7529346d45e1d7c962a72416720769eeb7996ac21baf96865b1c2521a902c1d873661cb84a61dd608dfbae8e49b692837347a5c60e705490e72f922469eda01d5a4b3a5535b363e403e5b2038f6b90fc725cbfda5cbb5bc1fcec95cd5a629809ceab7ba2b414ea7f7ad823b0ff6420ecb04472ff0e31ec148969eef934a9f072b6f51c9e13d0d1fd76184906ccb4964a06d745922f0cfa4d7e5a36416f83cc503c8d4d28fcd743807f4126a0428c01026c0054b0fdb8e4e2ee194bda2c73cf6ab1acb4bd0d71f92fff7e60b3255f71ab5e6da62acd765727044773b1edf62438afed5750277bc72934ada6650c7ee89d69c78785af5d41c316eddc5d6eb4a944003b3674ffb5177d4cd1bf0ddcd45daf3634f27a4ad8dbcbecf9a38b7b28ca0f489342ad5ef219dc15d45659aa012728ce16cfea2bd4ad3bf609242328e934c42680a29ca74a115ecc7a7649d611b88124d7b85fb5ddb929d1acdd61ebe90b50d48b5456fd7f07e27f983c7404b6066d9a1db9955c9427cef4abb95146b4b7bd718f4e0b7d63715037d65afa1014f66de885d66bca8eab1102b91ef63ac1d3ab4fa630157ff4ceb7490b53d2681141ae8160bb1759a212ddb5ab40c2ebad249b6a0887d3f250c7ede872e5799e70ad21cac2d89c64cdfc320e44dd38539f83a1677bd4e3cbd63adff56ddefa09b109ef0c82f8e39f1fbd648f9e40e6239b62325372c41bf7265d0b890a9b9a0c8e14116f4cf0d0bc05b89d79ce520f1735e8a04280bdb26de86e060706bcfb39fadf797c807081032f9a76f2799156257f0c212d9b4dfafc4c465a1f892375e1eb1579c6c7a1f0088f2e9d9cd630a78c667fc261898cbf58d7aa6d48b5309dcc0ee18db8b095bc023eca954946aa282b35ee540cfdfe30d84b92b5dd4db8a2a47b752640b29ef2e364bd83d0350f43bf9d5504035460f37ea4261d8d080a8a0e9bf03b846f622d713462ee8565e346d23d146c977d91216499b0d9cb16637281510b3c02ae517286fb1fba1682a2e054136ec1afa868a645b155c49da45d597452098211d56c91c6d5d643306a8abb77f5f65950235e9833d7797e5a3620077d6cfa0a9c353acf630a58d0b3b46fd03004eea17f4131af215b6f8f3ba2c3a2a0004443c41c3bf4a37279f5e6b59652bdfebfc3e17bfe1e881040dd4af01d13d7da438b5e91bbfda4ffabdb148b53ef0732d60f573436650e393d452b9ef76a1ff78f2c79380d3902377ddad7e80302c483c37bb79245e17a6b142a354f79bf53c09e5b820f9c00c8a2c11c3a03bc3455a35087aba1d49d7e76313997eb966b5f36c670d4bcc1fad14c93dbe1d07fd996e0e78119b51a6198ca4a1454d3ce0708fcf87067c0e4de124c85376c31204908141d38c58b7d36dd1a27a0479f382d2f29e254935601da657228f07441405181ec07910b5fc89b003e4f077c7b4bbe189fcff93af8f88e9d5a3a8a79b6b7b6df59927e1cf95ec6eb0d4c047f15eb167730397a11ff51a19a3e35ac333fd1d5b865dd8f53aed52444248e95273275fd8eae9b59bceff00970f8018a7636ff2671532f0fc33b9a74626b0f3856554f9952ad826b4494fbb2e601de863c598fcd6e0d9bfcb82ab10a13d9814e001db1d6a7bdf39f8dbb7521ec20deaa0b1782cfb50fe6f595ffe1785b80cb0bddae5c806a5cfad75c9ff34a8c2b8e21f151272b638a7db185bbe80a16a5ce4842de3a57445649ae032234469cfc23337eed14539550ea7f5a86f81df5caf0e5625f0c052a11b396c9a3eac39d7d232bd78d84ca57bb98c5773a24e4262dd65919cc2fec98e4667d8a76b4b3d9d77e5bc822fa69de1e7332b29e1a70385ed8dac10baebf11d980e3e433fb91ff871a143c159475ebf729759fdfc964ca7df55b295c2ceefe616fcf13e5541096b8c05affa903e88d9d82c0c57f622dab3820da546902e109498aa100556a9337b0e1f3c9b569fec92666aaf1ef547791a3550e2b1011fabb76a268655654750b41ccbd6aee58991138bdab07989bda3aaecd7858ab982442de5aeed4f87535582e17e1672b9c465a8c1aa3b82b84771c9ad9d26386fcd188c1e26896bbbf020a6bf18b00f55e547a7c9de19a034cc724fe17ee43b5575c185782cce4265df44a20243688cc92c47b6a21670aa4775a4f32bd7e788005bb939b21464cdd96e4328fff65ecf631f941ee24a66a8cd7f82fbece06b92d3ea122339cbeb1e31fbec94c7b573b937c3260eda50542278eeee3174368c0d9928cd0ac807d9fe80857a4d8260aa9ede36ca52fa63c98978e883b559a0873607a9cb86d1e755448619075cc98b5561e32bb6951ff4f26d534efd3c8476a74e108756edf680a24ee12ffb83f6741969d1279b303953b588dc2aa87d2e39828afef5622a8e2c47f5aa2f41579d8f6e1e3ec53832c64306c47144973cc4f78d62fc4617cd4b1e4e58661a09602f3b56674821d3c05eedd452b8fd39c981ff272896b5c60205c95a6af0c79d8dec12d49c9f61e55c5615753c81129716048657e6c4164888401cf9b3eaf382a59ed3fca882b6c967ec881b19a54284bf317c8ac01a84c649065e8f0478d5f2d722c47e9ceca4b241368eb3e5d38dedc8e9296390fbaab05d81f3f23534ef7ede68d2fdf80e6a4b2f3e6cec4542e1dda8362d35f33833d175779a256a0f875fccfb04dd8ce657f8d7d38eb4c177f3c0d119cbbb593b0315166058ac1daf80655147aa92fb48128d591460276f8a6fbf7ab0f8d396636573082d119bfa990e9ecf3dda3f9e205db82eb255a5c25832885eb25db0697926ff52def189b988a074fea6a2a4b87ff7519b6d6aa4735dd75fbaf9504ad4eb8d845f245ac4af2f00a7232d4ea6bfb64c38f6f3de37b66372be536e7c74fd8aae6f5fbc08b2342d99482976ff263bbf2e54e3e8964218d899531d3a2bbd2372e926da26f5fe1ed8f4bf8505a74a0c3a331f575c5fb12e1be2fa1b1c3ae4bd9b680b08d66c95d7109faa39090a0dd497e51eafe21bb342dc4da98fbc5e22eaafa6ab123ed881025d3349014c6e71af3f882d278e98cd39cf9d6b1c7fe0213592504fac7181624f804e3edf1a65aef66f176fdeb8c4ea58af668d3b94e6d1ba35f6a19269a8f177db3e9ae2838ab90de341543b4b6daa454a4c15c76c3915eca34f20e1f3507585a7b76bcc2660ebe2c961d01b070d76657077e3ab2666d21e057866e3899843632d6b62553baccd409c77622fbe6a1dc1d582124008622fe823816f54cf5fb917b1089c75096f3c6b197d3a719662f3c92e334812b8356425a2c8accd8dbd94daa7a8e71fe2d3e247424c3270c40af263faa38362cfbdd25d3b08f11aac4b54b86aa1d5e430cc001f00d3367120856027c7976f828f465119076ebc224c392787b5860402d7eb8b69d85032ca70164dc127bf83e0843175b126002990ecd40598e30510bee1b4302970b5cb037469500d43e2aed4609dc5c7966946b926159d85d78c4f576ac6f95f65736aa13c54225ca962e86f2fd811ad69f02e475e5b00aacd7c447353c685f62f02bc3b18b75a61e99accf80da26b7a9a44c88bc7d6c4fa237f61bab18152f44ea3e111226c6cf0722c628a97f09e362cae7e1533972d61412803cd9cb0c888a8f93ece8529d302b7eb3e9fd4e05d4a9da78c59cbc8eb4e86dcb528fb226081428da67eb11d1820b2412633f9efa52d346a80426a216e06d04bfddbbf63270e7d135bba777ec9c8673b541d9af6348cd1b2e5b30d0763eba4c5bdcb344d26cd6d283498a7c9594ad235948a3388e56013f783332437cc3da3321b6c434b8c69901176605281d770d788ef48223514754f1821e395d1b5638de8d59a613129404fb70ba772bc37fbcff0d007088a1f95e8a85359e0adc2a4ce42e876d716594f68197e55a8b6598e669fceb787bf434d30d94ce9bf10fcedcf3c24c8caa3ed814c8499e04ec4c5c85f81e4cb85afe581f9865e3966906722144b035bb82ac79aa30af657b577db439c984def3ebe18e276aef216de52eb0691baad92b694abe93aedbf43bb856f0a4f81e469b84d205b5470b6254ee7fa1fc01903e398a3275c9efbea6cf2e0c5e2db128bdb423892099774228bef8b2ebc93eadf657f945c93b978288af146780432c3389e331d5f424fcb60f5be6707608454d08bf1057f34ed2cde85a363d103227256d43a3101f029ff581fee957af6a1a1d27581d5ad09cc920f78173516ea4e1c9a392e98a13abed6d7ca4561fcf137100b9a5b3d4ff93d29d80482b4d9cee9e4b05bf5f2ba9d505ba169b70987a41e6ebbc0e1b5f24c475364dad043de04dbe42c6e29b042829d9edbd56b95fe0e01cbef83161cb020ce349c046b85eefa7b6caf09e0d953fc67eaac44a4249c37cd4cf6bf497c403f89dc1d63cd843883a3063c41d00cd2acb0ea696b5f42223713ed171533519465111044ad29a6bc2b333dee502e12fa84ad5f89fd74310422ac25184c8851d501559c9e9bd38e4abf11ffb800a9f41c25c7ffc111cd7a42ebd29643d876d39b635abd9fc67b37e28ae25529ebcd53a63fbeeb97064a312f071f415a5f08d8d356623bd4cb95ca21846968a50c21f70ff5c98f56aefe4b229e96f92a199a881e8e487307b6a5352584689e95e54effd7c0f1ab188dbf84b1c39131c904338cda98fe957f4782e5c7d3f0a1cff1aef1e6d69d39239467d54bd97f4f169e58666e06cd3b3bd55aef829ff56baa949481c570aedda153a2c1cfc01e29dab01f04d6dd94e1715947c9c153b1428ae4eb9311a6ec178a85d56273bba2f62667fcfa95a4bb5440514d5afcc49db7bc4a86b312c4dc1a4957889d58c6e1417d2136b64d42244d34bb233e85cb03307f625061c5d84eb466f6856b499c51627e1f75fc67d79d3e67f149683f061d13327298faee17e39938347bc317ec02790be5c12d309d98dac4786521b5b015263cffb3b84ce4b4297264826c63e5cc76fd0d60b1359d37f5bfdcdc508c46fd82d383771c9f38dcfc281d9a8954fc55b2eb3019b9e3b7a928dded46ae155138e29bcf1ca3b4ad6657fc36a45da752b0a1528a25d06cdf7d1bb3234e3a7eca80d174b830446b327168f8c1747abbdda9a77c21f87573da8b24ffb8aec53fd01bd82e04c2c5b7e3f41dab2457b73ae2fb0e322db6c50098cc73f49cae9b097d7782428b78bd1b59dca60c0bbe3ba0b1c856156a9d7daa331a89805198c3c4999d8a18216880ad63ca4b8697ea431ea035166ecbaef365e96ad4e95dedbbc19eddbb16155ebad3c1eaf472c16ecbe601f8b1f67f3eed4ff61721af5ffd98f6d943102444be67a9b4472adacef329695e6a5298b6e93dea58b2860a6cf222d951d46d92cdab1a4fec8e2073523fd32952375ed7a8d2ddd8dae74c7ddffde7ef22f9360c8490493bae4e085d015605efe038dfacd581660a78eadc3691e6d7493cc507d622061329fa4bd7f215015fa05a7b5869186519649122ec0ece1f307daf5fdd03a814bcdcb565e0d22d30c85d53585bbb36bf3a75b950af0934c709a377470dcefe7282ceab7da008e9980e09dba540d8c0e45285edb48e39e85f893753445bc9903a65666dce5ce7826ea78719121b0fa3ab46d4b58dc54f96caa56f3e0c5b8dbf83e21a6838da233be47bf49788228dbd9be84425ddf762d8eae7b031d5ac06ea045c631db327b4ce4cac8105db760b6fa928f421a1bd849781d3df8677fdd1ddecbe7a726a6c69f85e5d4987baa04cdc3084d5cfe414c3986995522749155444924c94a28b1e00b623bebc8812228100de125ccb15233bc66319a108a6abdc5e7b4e2296d307ae68c993ecdbf9473de63e0ac886f5c0bd60df0824fdf1513e0cbd773052f9034b093599cd4834d2ae335186de7d4060f3bef088e5cb38db6a1fe8f55d34c6923d54d3270bf1fe897ab47c69bfa2ea216e76c82960b0711fe924e0ebd5cf06841ec5ae47bdb7ef078a84304b4378cdcb3636960b40bc0a17a6d3abc2f8d9abea4af87a963bda9ab0ba4424c08ad7a74070544a335d1cf1736f6fb800ca087b7e192c322d0e9da9efbc3b21a6e0ca5bc73757b02a357d6ef032b9a683aded6ead2a323f453927d4dfbf62d582945593bb82475bc925d924db167037c6edec4c30b31151e82458e447ca682d2cff3516178634afb504f1e651c37ae78980a85d14ff751411a1f1fc963ff9d53a5e45331be4fee5182e39e8eedd60ad5e087b68f50094b4eb6ff1f7db3666909cb34239feabfbed249fe35058ad8d69ca9a8e8b77e5d4b01968f219fea400fce308ccb8e1c1cf9c92cc9afdaf9266bae454b1787d3d65e94207b917e206b9273dab4481dc802a21fd7dc108f1fca1eefd86e6049a5e1fe0264b18671c2effa1840c6b85dc83aa50c4d114e70dc17ca752390bb9e7ab9139661bc3dcc23ffa29886421a80eaafea121471b6fee5e3192ca6c18ceef588c89c3068efc7ed3d64a047a0226ff3af75055b0d7f5a1a083b2c74022031909936c144304fd846b8afc92c5313fbbf79eaa47670780fa593f071531a47718b3c1d25d6cb96e69a512e487f3ec7d973bd6bb34ef1a883180d8d2e7708d7ccaccac4b7f128cb6f340fe19261186f92c0e1f8008b37ce0e7ef1716ffa69d3d5a8dd19fbab16de45a84d68d3a154697e5ba65c110b40b2c5a01a9d2691a40045555b6ea46ac043b647a06b333b770cad123456a0457345513b8693ad7faa4e439afc598a0439bdff285344a75151e8b147349494fc1a7a2ac1852924595e1036eba8e8dc5febfbc047c0f4f0c59d9a9b677fa5612020703c7924c34a9bb237b6868541a549df15304c8a563bc7ecb665530f5acb8cd37d79920a65045e14a993235269ed4b700e94c66665d419c93bed0fa8ab2f03b1831c5a281494f067f9d968cc1276c15dbd47e2c2b83a571eeaec2f9c4854426a112f350ddc53c609dbd2156503488fbd4099dde9badbf75dc9db514a1b9974dcde142e5cde52123507cd76c5764c8eae05cf431f1e58f84965111a82faa10a012ece3d65f160c7c8957363f499c37c6ba34de53d5a440eaeaee615e5f7a3715769c76cb6e02a1d74c6c900ec4bde64b2e8f268001deb5380d5b81aee74f19ccf78789b650d80372dfca8cd14b437a9ea085b3afd80097b0d4e81c0d0b5e0c77bb2f1587e9f8deef5c051c80d256960ab294dc8febc9f94ee8abcda9610b681aa56ddcbef77596c20af9f05a5e00b7bea94612174707f70a8f7a82280f706f76253ac903ddc13c5e89baa4b3101195fa7546ebfda1382a69ca3328889ed3f16f0e76a49d14757e9f00296fea615a1c5dbb770312d70a2058ba1d0cc3237d9ea0ca1a0fbfe24ff2e0010911cd3068ce421613b530095e0e1bda4ee4d8c3b79708424723827edb60eab080af46b4393ae75e63ead7b58857e66638669279c9c8727d517e7e6160b6f4bd663f68cd7a2406e5db147156ab842bb0d93c1536f8c67d7a071bfc88a1a3c31fa316a9ee3796da2afab134f4ec1eb97acbdf5b4ed2f777f9d1e12a810b727468004932125b3bac789ca701fd4c57372472a577c77415799b5666aaf4bec49c8c1b56f150492e765fa4f5ed29d599371a3085e09292b1e27f87a77bb2dfa9f3dbca3c7ce74c6906bb181ab8a3268beb299b2d1694279476906aeeb6a8f6509df1133f08a0f8f368073a001c8e34451fb2f7b94247534e036cb210cb21c24201bcbb0be29915e7873bee0605f843608048c328a4e028865c1881130dce26de3565ca4d655e10711c713db41b31a385703d77b08806b493705a1ea450c456ae521a6fda56d6293fb70dc4d185b035cc0fe5de1d87000efb890e5a49716eca93821a3eb3ada0dca577cd153f7eea333d8ced849f1fdd8237bf2e1ecfaf5a54ecc970588b2d6b3dafed123c81fe9612d3c5595281345d24e85ae94c9007b482dc0d6de4744b9eed10418af5fae7e50c30c8c7198afaca1d2d54546696874e4bf667b174795c3ea3eaf240793a22d1b70432fa939937746edaabf2c699e30d5c2b8bf81a6ec4db069c9f6b1e5a5be5fd31097015a258e8a23c16368b77c872d9839f91bddb1e01247dba78b452ed332b914af77c8900bb25924590c71a0516f97ae67524b9a8c8431b704b4db63c039f5e2fb0f9607896bb49894856b424e475a1e57664ff9ff8a16e4df8d453c75927c26ab3a42224dc98998d4be04ffb3e6e75b009db309f894f589a6730c45aa1fce452a0a10f399038129e2f780d913fab12f41da3953124163fc7c24b5ed327cdc5a2d852f45dffaea7ebcfe4b40f0a7be5ffacb34ba253b809872a7b58230a701c77de5a03edaea746e041af395372f22e10cee533ea1e8790abefe50a4e566de335e33119df9cc4d3a9ab8c715332f9905862652e1d8e48fc65502e43acd36cf64362498dd0b22be92a80532e38b8038dc8a650dad188faa8c8f3c84980e48099030fc95f063dc7a818a90601b55cea68c358e6ceaced2181ff9ed224047e11fee67e19bcfc4582ebf4c9184be94ecdce43c2a4f3eea7d7d37329c22e213f5c81bc594c04cceaccc506a9807f6fa5f170a7c784489471a0d6e59da695ce6923962fdde8e1c4b54050c9702d1d60619e1eefca55d48f3a2a8c637ddb55d3625af9dfa081f8f98eb341f8ee74217a77ebc8b56c8e582be804fe4f6262cc469e9ae1ff5519517a59c4fc5577a74169dd77e7603d7660d96d2ca85109d78e9dfb51ddaac5ca4d775c9de110a1ab38f84232c5d90875235bb6361831bc632dab9cc66931c1fff0e928c6a0f8ae796c87270a10d7d2e5a2d94f60a7b20b1525e5c38b096a6401920f1377ba8863869d2d0fb5549583f85786b3602ddc2d2306949fffdf78245fe0d10e97e193db7cae93d7a0d3ee2591c60879704a3430c1e3e33bc1637d0926407ed0959948532c619d4d1c3c9d6418700e12a3c97151181dc9c5356e736ad35b0e686b3b09c0554dcf1de0eff11f465f6cf9999f1221d8979f2bca1a60c460325bf0977a33163d8ae644c04d95b73fdf14fa125d0fc83d44651e9fc36ccfe684d7a66cdc3199fbee32cdaf6e1de38eb98adedc74efbcfeb0b08973d36266d2bf8323fb5c7f0ea7af809f92058ed7d9c5320f5eabd6ae642bbb0acebbf2a9f6fdb98102facaf03a908325cdd02ab5b36d72957f2b5c39c69006d0f0cfbdd41bc322e5d3877c21a6025e163446221e72b3ee3101dfe41c4ab273dc9c06086c469bc077840208df27c8e3a80bffeb96dd2004928cbdb7be07ebfd533c506f14ce1afb513b01908c3972ef75e95ed4f5e839609b600a12da7a6d3d8aa9811daa1861c15b8d87301daf7d80c9169d3b390698f5a69e62a77a5996b46f082b394ca5258c1eab69cbe44c57676ed0a92577c2466c72632673ba34a8b6ab11812e3c02b6f7b1fcd85592a582c635054e411d132859fe3eb859dd5e76b72a2e1e159ab9e41fb4ca1b1f6ca642ff3bc827323fb4fbca0b7b13df11dc48042151d5cc3fa020caa0e43aceb17c08836d95e70f82d0c88d88bd569d2e6d70074a993dc48eac3213f9cd719324b4bff31a320e848cf26557e141fdc58d38b9c42331ac006f5d303112ae90aba015d3db3ed821a3b095ed40111ff52222cdd93623c9aac2dec5689a25f82fcc8027faeab39298609380e140400742e415c8a1310679fe2804fb09b57e67a25cdad53eef5030ae7ef48bdcd4678feb548836137ef97501fe7f4a5ab410e5e37b3adaab05274bb174f25ae2b58623198c33f7c13064d7b0dcb3c992d87d84deb3b42bacb9168b468291cd0291ba1a40fdce65794c0dd4f265be6814e416a08d5db742aab4c75a2281505e26a52333245f0b25b755bfa65485461faae270065aed50f450c30d47409ce7be47c5a97be84e63344f246b4b96749b9b71d4959693c95e76da1aabf80be3edc93361bb0cd54e0d1659438929f01d1bf30370b2fc5297462fc8b89428bb12b569ba3c6181d1713aa5d715a19a981dcb283122d338c65acb72b0293956c15fbc4fb1947b7a12a415ed8686001c886393671c6cf9f50e1b795879a61178718dbafd81d28252559766294ba30ab9b8e3c04b1794bcf96fb68663269218cae05a3f4efb6b13e34f5f17a9c5111baeb918ec51d63eff80a96b789064f4b198b2efefd7242aff9ec50fad78a40ba80c76f1b94a418904ed24d760d4348d488861dd3ffa1c6433265f565f69299276fbcf54a0a250f7bfbdbb3cc18a38e14532f8581e31f23d9b025c17a30d1a7df2e4e79f8364807512522826f0bd7b463c9fc5d1449bbed6d6479450bb78d6a5e2bfea66eebbc359d8cf14f07bd61f6cd841d9733ad274183b5ce6d7110840f8c277c90f544397b4bedc93b003f33918743d28c744e0fa5c6df4aeb6cd129af140d72b5841f4feaae960d698e1f2419312b8a964c05d454c301b24620c1e1c2732c50284041828d5957fd71e798af70d3003bb5220efc594504c7c921a2eea3f58426a51dc43a65c03b57b81ffe7f5afe93973f6c6a848f2fea86f55bfbf3a498f4dfd670d3048dccf3ff78f635eebc61d627682a076bed45856683fd52342d8af6554720a485e754c2d6a5e73a3424e9495deebdbb4c868942d8be014f4bf06a0633488f137576a4493cac82c2cd24c719c812ff617e8e2e6e5a8355ce2005ad37fc92d6b348abb512b58a35f833ccd771fe130e25b4024ebfe76a4f53ffd92a39a0f021d237c3ed6d398247ba87cded770290935cce94ca94e9b539620e04ef8cf34d74d4c6c76112e082408272cc8b04759290ec9fc8b76c80899aff9381722b86d323c4a8d9f357903fe84e70eb5e52d89ced0e928f008cc3899524f1c9cefc9533a4c2a8f76494a9f52c0b23554891a9683db594d9d94c7d307db56d00a2e29c29b09ee7f11c73be149f6ee09f668350bfbd1405c1ad1e6966eb549795a17fe613ce71b436980ed76dfae483fc16f3a0c43761f4d247fb2ca3df27ffac1664359ed6e5e43ef3b0efb21db6dcb4d8ce558e313ead5df851e48775e4ff11f52e155b124611f2bb96c1d8ed8ea1b2fcd0d843610c42da748b158714fc06dc6b38f46a0ff0b60d7505151dc047fb018f7c7e86de54a247d5d76442af51e128964425fdae7eff28f93b4ef43bf0a022a808d85dceafefb9e9fe50b6979f347ff0c38b718d5b23481ded550698a8880852374ff4c9e494abedb722641545f643fa4fb262af4d790bc20882b4bf3ab67e53221372df242b972c68bf9d601fd35298a27acb64525c4867b0804970a8ad9e904e84a2ac4fbe8d7cdc46bedd10792c713690a115be39076ca90c33d7a5081584be4dcea575124a1218e668d76a03709dd684f85dc554147876682f6ba6cbd3f97d81f4e464a97798a56832754c533a757eb5e12716cb42dbe2f9229c96c51e8f4de1acb11ae20fae6006f6f753121b8832426a3c3d9225d7845882a108009b1cd3cb9a79cc551ffc4e16eea4f8e6ea052e7dbe2057aaeb083d547992c1e614b46cde7b002414294905d91693c1925c673275d837af1a57ce5ba1ec611920123a24795970a10accc16220fed8ae36161c8d6a04b74fb4e49978ebf1ed6faf53e05f82afaa9ceba3bdb396c195a50e0299239f87885da3d6b09e1d3982b5d67488fbb34724d23ec981ac60df8c85bf647fcba5302b531c58e3ba9707935a82363a3cd42d55316c76b4896342f27f3648b26ad1894ad5bb4f43b86a738f48454a33fc6aaf70cd556a5e9d88189847a91bbb09c7f152dd9653c90208c31fd7a907d9ba36f4a5bf06ffe71cf378d89f29144a19e4e0baf0fd7c5ff4042afb5285f6a59ccaa54458a1031f473e95231d2b3205d08de495ebf99287c2a564b5fa9a538514b99d9a960527f21ecda60082c6358dc51a7681cf8be9679e02672ba64c39e9de2324869ac754f34b97087e03d11d156e317f2b7d00c2a4a3bc33a6b6bb91488f8fb9ad7e22e549d5783c5032348f5481a0738a14f51310f2d965b3ce77ed04a44376a226d6e8ad2e9a14b15997119e2c939da9b445543a337c25e4a34725e02236d76143c6591028cfb729814d4f6b462333bc742785e08bfc8db2c24832112371c7c77429866192882a30fcc5f8682d49b72976aa68e027c77bfb2e3e5ce5f6a79f17ad511be507e6f88ce7c461a33be8b50dd00b34d0b4ccce4acd6a4a265c57f19dc7eca1b1cc0077c65b880e1b0a917e97accf335d71afaa925cdaa6fcdb1167fed0a24a24b5f768c7545bcf805827aea231ae41ff908c92ee4146dbc53e56e264b5730737a2aaae58f14c13f1a6cc34593d9811e0e11af1ed9a2f1ea45a41733ebad11233799be80b1db7b4b489da79a025986d10928199bdf01969209e18591dacd628ab7e84291ae9bd0aaec0be8ed99e810ebf6095532dc579f92b412332cf4eafd3c46a543d634185efbff5494ac1e1a0cedb2020f3e4da006d42c0a2686acb7c739da672fc97d322f9f69879ec8861f87de9d219fda0f54b358af644a9f715e9e78c1acc8707c46ae19b4ddac7f90aecd335dd6dcd808430f47fb6094cf40c452160406ea893960b03f27b1fe26cbe9428acc0a780387b1ded5b3bf9eff7c279e49e12f942eeb31f3b3229b29c1391f4f7ac822e3272aea4b8ba6517445aef2f74ad8b91e7abcae0bb5029e5bcb1dc09b28f28c24182a62305ed8d68ac295f99078954720343760c8f647a2093b01384e71ecffb7f549aaae93eb8a8514e13d8bc0c6f3839622c5df37a356e2a0caec76b26d027c3a4f1ab87ba5a9d42d7a5ae5a6061642cbef80207a78cfef237e86fdae63c1152978f8dbd70b3a3202a7418fd523ceb942bfb66c8d1940e07e2205fb6212652a2b1d866a7bc219b1c1dea72e6e8f52a944344c12fefa2f11e3c74c700389df503ebc92191009f3c9e80c294a0ff180f04293136a39181c23087a18deea355e22d8c2c5a633992ce30171bb1e77e56e096a5dc56d17a16918df0737093b37c76c50e06d401cc68b53883b95c959f8052819100649df1ef3f2b491ed8022e46e947e8aae198677265dc5d6c1f2f77d5a94056bef83d62ed6c627f7a97a85b7a32fb7f218f1a48ab6045d36592b00affa3acd83d2b5fcfc30abe3759faf7901607c2f852b140402eaf40d3760f4acb07caa2b008255a1fe0dc61112a939f3e597c72d4661df50dc51a80f1d5f799e70c302d8f586309e1c53f66d60a654496102e6440d9c85c7aa952faa2d2b00e367104c81e0608848543e515803d6f8022bb72cf36f2517b55b84db057987410ada0939723d6887cbe77fcd8b0af3fce416fd6276bf6fb958c29a09b5cb8064b79edf6b3929c4fbe5e75247a5534e733f343006f0f248c77091feae5328f94fe44827bc1dc1fa86018644a61863e4d487aa152a132a7b8aae223bceaf6f1c4295019a3174f8af07fad5f47c07d504648e2c9a2a5c264e9cd91c4a860975fbb64aa806363c4fc75751f3c1a290b69787b89d34c44609004072512bf7230461b9876142f28ca057e1f2c0cbf6d4b30383bc7cf1c18504fff4150c440b70b55a8c220802b8356ddec1b53a829b800b4b9508c29a855a478eb61c4baa8e6b4e1b7c74ffad3d113e7086a62d2ad441aafef80646d516c01ef5fc12313acc6366e81c7b99c9778df8d6a9c5921d097d86f8ea68e4d3b28f8d52d199697b3673434d4b67dc967717a7ef73aa24794d4a560aaba885a4ccb4557f312ba75d9553209dff04869ae63aafa737f7127344119707eafe336126c60680d313a3225bcef9729e47f112af45cf2fcdb807211a2745a5a6d1f0e89abde5401cd943658bfef1a81bc5dec13b2580b1656c2bf3a11ff965e1a2baa9962cad40d4210bf7a5cba135a0bc24851f3422293e07eed942438e1b781b0912faaea7741508b7e96f8ffa118df97efa840f30d2bba6120d3a16d4e150a84832aafde2bed80092fee962a6db7b72d5ec92db3a1b0581e026acbcddf2d272156a1827d49755fac4af42485716a1fa2f226b70c25eaa2f84f671ce96115ce5b4172c49cd0ee9ab83e2944f0b5c105d623e1e3b9b7b22838cec4c41d328b06ee16de4b9c72afdf5d70688d0d56dacd11f235faf9b1b1dac83ee072d99c05acb971fe7bd3509ba21fddb60f096f1b4bdcb849d0d6ec73f2d7b0cb253036c41967777e526c364b3b2072880d43311e1fe53e08a7b7b408baa2e0b2e27462e02e181b8be2ad5ead172862182dfecd97980729a41017a4d70252bcb9f5a8c1743f22b530f978d109dc026127eb7d2428b52cdcd7e03d07dd52f8ccedcf4cc02ca670eac4ee8245a721c5628daa8dde03d243e68895080066a03bbc3fef46eb4ea3ed9981270e81e3f8caa0d1a43d2e305c30273640b48d7621dc735c533bf079eb1b2f22bcf5271e70b4b2c955a1ff2d690974b92e13a87e493f5a216aff8f812cc882ed5f1b58706028ac0a39d9227e39a8b65c7b549a1cf3f858b4d80116e8cf5eb41df0f8df28d2bc793a6894a37f1c4730229c58d4878eaac44463d16298036398ad1bc35e53780f4751f2172cc614813ab3c5c464a0005517a49566e68baae7f1b0589edd924e2ba795eb7b696b9588bdb8fe02b8935b54c362db376b6958566e98d37c487c09689dacaaae6aa3504c8936ad6a104adff0438d0bebcf4073588401d0a3504b5d11a463a44772a799af1c9181d9e45f7eea6d77995ec5fa108f1b8c9ceff968ec192441c6091133f74ae8df2b65dc01d7ce5a402ffb98912d6ecb4fb1c86cfea81dbd4aa48cd4401e3203738fdcba65f7a6dc25b7575b4541935eb3e872533dc08a4e666996a6871c88798b3b3ca60147c249984f4a77185dce9af198a30d1d09ba3764c4eeb057dde3d1004f0065</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">这里需要密码。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Kalthyix 团队周报</tag>
      </tags>
  </entry>
  <entry>
    <title>【MX-X11-T1】「蓬莱人形 Round 1」仅此而已，就已经足够了</title>
    <url>/2025/07/04/%E3%80%90MX-X11-T1%E3%80%91%E3%80%8C%E8%93%AC%E8%8E%B1%E4%BA%BA%E5%BD%A2%20Round%201%E3%80%8D%E4%BB%85%E6%AD%A4%E8%80%8C%E5%B7%B2%EF%BC%8C%E5%B0%B1%E5%B7%B2%E7%BB%8F%E8%B6%B3%E5%A4%9F%E4%BA%86/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P12147">题目链接</a></p>
<h3 id="题意简述">题意简述</h3>
<p>定义 <span class="math inline">\(f(x)=x\oplus(x+2^k)\)</span>。给出
<span class="math inline">\(n\)</span>，求 <span
class="math inline">\(f(0)+f(1)+f(2)+\cdots+f(n)\)</span>。<span
class="math inline">\(T\)</span> 组询问，每组有不同的 <span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(k\)</span>。<span class="math inline">\(1 \le T\le
10^5\)</span>，<span class="math inline">\(0 \le n &lt;
2^{29}\)</span>，<span class="math inline">\(0 \le k \le
29\)</span>。</p>
<h3 id="思路">思路</h3>
<p>由于 <span class="math inline">\(T\)</span> 较大，考虑 <span
class="math inline">\(O(1)\)</span> 或 <span
class="math inline">\(O(\log n)\)</span>
求法。先打表找规律。因题目有特殊性质 <span
class="math inline">\(k=0\)</span>，考虑先打 <span
class="math inline">\(k=0\)</span> 时 <span
class="math inline">\(f(0)\)</span> 到 <span
class="math inline">\(f(n)\)</span>
的值。由于涉及位运算，考虑同时观察二进制。打表得到<br />
<span class="math display">\[
f(0)=1=(1)_2\\
f(1)=3=(11)_2\\
f(2)=1=(1)_2\\
f(3)=7=(111)_2\\
f(4)=1=(1)_2\\
f(5)=3=(11)_2\\
f(6)=1=(1)_2\\
\cdots
\]</span> 观察到一种对称性：<span class="math inline">\(f(0)\)</span> 和
<span class="math inline">\(f(2)\)</span> 关于 <span
class="math inline">\(f(1)\)</span> 对称，然后将这 <span
class="math inline">\(3\)</span> 个数视为一个整块，则 <span
class="math inline">\(f(0)\)</span> 到 <span
class="math inline">\(f(2)\)</span> 的部分和 <span
class="math inline">\(f(4)\)</span> 到 <span
class="math inline">\(f(6)\)</span> 的部分关于 <span
class="math inline">\(f(3)\)</span> 对称。同理，<span
class="math inline">\(f(0)\)</span> 到 <span
class="math inline">\(f(6)\)</span>
的部分还能继续对称下去。为了方便，我们把最短的块 <span
class="math inline">\(f(0)=1\)</span> 记作 <span
class="math inline">\(K_1\)</span>，称为 <span
class="math inline">\(1\)</span> 阶块，<span
class="math inline">\(K_n\)</span> 的长度记为 <span
class="math inline">\(len_n\)</span>，<span
class="math inline">\(K_n\)</span> 内所有元素之和为 <span
class="math inline">\(sum_n\)</span>。则 <span
class="math inline">\(K_2\)</span> 应当包含 <span
class="math inline">\(f(0)\)</span>，<span
class="math inline">\(f(1)\)</span>，<span
class="math inline">\(f(2)\)</span>。以此类推。<br />
接下来，尝试将规律推广到 <span class="math inline">\(k&gt;0\)</span>
的情况。<br />
打 <span class="math inline">\(k=1\)</span> 的表，得<br />
<span class="math display">\[
f(0)=(10)_2\\
f(1)=(10)_2\\
f(2)=(110)_2\\
f(3)=(110)_2\\
f(4)=(10)_2\\
f(5)=(10)_2\\
f(6)=(1110)_2\\
f(7)=(1110)_2\\
\cdots
\]</span> 我们发现，<span class="math inline">\(len_1\)</span> 变为了
<span class="math inline">\(2^1\)</span>。而 <span
class="math inline">\(K_1\)</span> 中的值变为了 <span
class="math inline">\((10)_2\)</span>，也就是 <span
class="math inline">\(2^1\)</span>。继续打出 <span
class="math inline">\(k=2\)</span> 和 <span
class="math inline">\(k=3\)</span> 时的表，发现如下规律：<br />
<strong><span class="math inline">\(len_1\)</span> 为 <span
class="math inline">\(2^k\)</span>，<span
class="math inline">\(K_1\)</span> 中的元素的值为 <span
class="math inline">\(2^k\)</span></strong>。</p>
<h3 id="实现">实现</h3>
<p>考虑分治。<br />
考虑从 <span class="math inline">\(K_x\)</span> 推得 <span
class="math inline">\(K_{x+1}\)</span>，我们发现，<span
class="math inline">\(K_{x+1}\)</span> 应分为 <span
class="math inline">\(3\)</span> 部分，<span
class="math inline">\(K_x\)</span> 作为左右两部分，<span
class="math inline">\(2^k\)</span> 个 <span
class="math inline">\(2^{x+1}-1\)</span> 左移 <span
class="math inline">\(k\)</span> 位作为中间部分。容易发现 <span
class="math inline">\(len_{x+1}=2 \times len_x+2^k\)</span>。<br />
反之，从 <span class="math inline">\(K_{x+1}\)</span> 推得 <span
class="math inline">\(K_x\)</span>，有 <span
class="math inline">\(len_{x}=\dfrac{len_{x+1}-2^k}{2}\)</span>。<br />
由于 <span class="math inline">\(k&gt;0\)</span> 时的 <span
class="math inline">\(sum_n\)</span> 都可从 <span
class="math inline">\(k=0\)</span> 时的 <span
class="math inline">\(sum_n\)</span> 通过位运算 <span
class="math inline">\(O(1)\)</span> 求出，考虑预处理出 <span
class="math inline">\(k=0\)</span> 时的 <span
class="math inline">\(sum_1\)</span> 到 <span
class="math inline">\(sum_k\)</span>，之所以只处理到 <span
class="math inline">\(sum_k\)</span>，是因为 <span
class="math inline">\(len_k\)</span> 刚好略大于 <span
class="math inline">\(\max(n)\)</span>，即 <span
class="math inline">\(2^{29}\)</span>，已经可以覆盖所有 <span
class="math inline">\(f(x)\)</span>。<br />
其他实现细节详见代码注释。</p>
<h3 id="code">code</h3>
<p>这里的递归过程很像线段树。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">536870911</span>;</span><br><span class="line"><span class="type">int</span> t,n,k;<span class="comment">//同原题</span></span><br><span class="line"><span class="type">int</span> len;<span class="comment">//中间部分长度，同时也是最小块长</span></span><br><span class="line"><span class="type">int</span> cnt;<span class="comment">//阶数</span></span><br><span class="line"><span class="type">int</span> sum[<span class="number">40</span>];<span class="comment">//k=0时的块内和</span></span><br><span class="line"><span class="type">int</span> lensum;<span class="comment">//大于n的最小块长</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;r||y&lt;l)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//超出范围，直接退出</span></span><br><span class="line">	<span class="type">int</span> len1=(r-l<span class="number">+1</span>-len)/<span class="number">2</span>;<span class="comment">//左右子块长度</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(y-x<span class="number">+1</span>&lt;=len)<span class="comment">//查询区间已小于或等于最小块长</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1ll</span>&lt;&lt;k)*(y-x<span class="number">+1</span>);<span class="comment">//(sum[1]&lt;&lt;k)*查询区间长</span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)<span class="comment">//查询区间完全覆盖当前区间</span></span><br><span class="line">		<span class="keyword">return</span> (sum[u]&lt;&lt;k)*len;</span><br><span class="line">	res+=<span class="built_in">solve</span>(u<span class="number">-1</span>,l,l+len1<span class="number">-1</span>,x,y);<span class="comment">//左子块递归</span></span><br><span class="line">	<span class="type">int</span> l1=<span class="built_in">max</span>(x,l+len1),r1=<span class="built_in">min</span>(y,l+len1+len<span class="number">-1</span>);<span class="comment">//这里要让中间部分与查询部分取交集</span></span><br><span class="line">	res+=<span class="built_in">max</span>(<span class="number">0ll</span>,(r1-l1<span class="number">+1</span>))*(((<span class="number">1ll</span>&lt;&lt;u)<span class="number">-1</span>)&lt;&lt;k);</span><br><span class="line">	res+=<span class="built_in">solve</span>(u<span class="number">-1</span>,l+len1+len,r,x,y);<span class="comment">//右子块递归</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_length</span><span class="params">()</span></span>&#123;</span><br><span class="line">	lensum=len;</span><br><span class="line">	<span class="keyword">while</span>(lensum&lt;=n)&#123;</span><br><span class="line">		lensum&lt;&lt;=<span class="number">1</span>;<span class="comment">//左右子块长度相等，直接乘2</span></span><br><span class="line">		lensum+=len;<span class="comment">//中间部分</span></span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	sum[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//k=0时，f(0)=1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">30</span>;i++)&#123;</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>;<span class="comment">//左右子块和相等，直接乘2</span></span><br><span class="line">		sum[i]+=(<span class="number">1ll</span>&lt;&lt;i)<span class="number">-1</span>;<span class="comment">//中间部分</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		len=<span class="number">1ll</span>&lt;&lt;k;<span class="comment">//中间部分长度</span></span><br><span class="line">		cnt=<span class="number">1</span>;<span class="comment">//阶数</span></span><br><span class="line">		<span class="built_in">get_length</span>();<span class="comment">//获取覆盖0到n的最小块长</span></span><br><span class="line">		cout&lt;&lt;<span class="built_in">solve</span>(cnt,<span class="number">0</span>,lensum,<span class="number">0</span>,n)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 时间复杂度 <span class="math inline">\(O(T\log
n)\)</span>。</p>
<h3 id="证明">证明</h3>
<p>对于 <span class="math inline">\(f(x)\)</span> 的值的二进制 <span
class="math inline">\(k\)</span> 位及以下均为 <span
class="math inline">\(0\)</span> 很显然，因为 <span
class="math inline">\(2^k\)</span> 最低影响到第 <span
class="math inline">\(k+1\)</span> 位。而 <span
class="math inline">\(x\)</span> 必须增长 <span
class="math inline">\(2^k\)</span> 才能令第 <span
class="math inline">\(k+1\)</span> 位更改一次，所以可得 <span
class="math inline">\(len_1=2^k\)</span> 和中间块长等于 <span
class="math inline">\(len_1\)</span>。由此我们还可得，<span
class="math inline">\(f(x)\)</span> 的值发生更改（在 <span
class="math inline">\(x\)</span> 每次加 <span
class="math inline">\(1\)</span> 时）当且仅当 <span
class="math inline">\(x\)</span> 的 <span
class="math inline">\(k+1\)</span> 位的值更改。如：令 <span
class="math inline">\(k=1\)</span>，则 <span
class="math inline">\(f((1)_2)\)</span> 到 <span
class="math inline">\(f((10)_2)\)</span>，第 <span
class="math inline">\(2\)</span> 位发生更改，<span
class="math inline">\(f(x)\)</span> 的值由 <span
class="math inline">\((10)_2\)</span> 变为 <span
class="math inline">\((110)_2\)</span>。接下来考虑高位。我们发现，<span
class="math inline">\(k+1\)</span> 位以上，连续的一串 <span
class="math inline">\(1\)</span> 会使答案形成“若干个连续 <span
class="math inline">\(1\)</span>”的结构。而高位连续的 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(1\)</span> 的变换恰有 <span
class="math inline">\(2^{n-1}\times 2^k\)</span> 的周期性（乘 <span
class="math inline">\(2^k\)</span>
是因为要考虑低位）。可以联想一个二进制数的不断加 <span
class="math inline">\(1\)</span> 操作，观察最低位连续 <span
class="math inline">\(1\)</span>
的变化。以上两部分结合即得我们观察到的规律。</p>
<h3 id="总结">总结</h3>
<p>这道题规律优美自然，充分运用了二进制的特性，称得上是一道位运算好题。<br />
友链：大佬 <a href="https://www.luogu.com.cn/user/1411149"
title="yonghu10010">yonghu10010</a> 的<a
href="https://www.luogu.com.cn/article/2piluq58"
title="题解">题解</a>，与本题解使用相同思路，但实现方式略有出入。</p>
]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树·平衡树</title>
    <url>/2025/07/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%C2%B7%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉搜索树">二叉搜索树</h2>
<h3 id="性质">性质</h3>
<ul>
<li>显然二叉搜索树是一棵二叉树。</li>
<li>空树是二叉搜索树。</li>
<li>二叉搜索树的左右子树也是二叉搜索树。</li>
<li>二叉搜索树的左子树上任意一个节点的权值均小于根节点的权值，右子树上任意一个节点的权值均大于根节点的权值。</li>
</ul>
<p>二叉搜索树上的基本操作时间复杂度大多为 <span
class="math inline">\(O(h)\)</span>，<span
class="math inline">\(h\)</span> 为二叉搜索树的高度。若二叉搜索树有
<span class="math inline">\(n\)</span> 个节点，则最优时间复杂度为 <span
class="math inline">\(O(\log n)\)</span>（完全二叉树），最坏时间复杂度为
<span class="math inline">\(O(n)\)</span>（退化成链）。
显然，二叉搜索树很容易被卡，我们需要上优化。</p>
<h2 id="平衡树">平衡树</h2>
<p>二叉搜索树复杂度之所以不稳定，在于其操作大多与树的高度有关。平衡树通过维护<strong>平衡性</strong>维持树的高度，降低时间复杂度。</p>
<h3 id="平衡性">平衡性</h3>
<p>对于一棵二叉搜索树，每一个节点左子树和右子树高度相差至多为 <span
class="math inline">\(1\)</span>。</p>
<h3 id="平衡的调整">平衡的调整</h3>
<p>我们使用 <strong>左旋（zag）</strong> 和 <strong>右旋（zig）</strong>
操作维护平衡性。注意，维护平衡性时不能改变中序遍历序列。
先说右旋操作，我们有一棵二叉搜索树 <img
src="https://github.com/headless-piston/blog_images/blob/main/rotate_1.png?raw=true"
alt="image" /> 我们将 <span class="math inline">\(B\)</span>
向右上旋转，成为新的根节点，<span class="math inline">\(A\)</span>
向右下旋转成为 <span class="math inline">\(B\)</span>
的右子树的根节点，<span class="math inline">\(B\)</span> 的右子树变为
<span class="math inline">\(A\)</span> 的左子树。 <img
src="https://github.com/headless-piston/blog_images/blob/main/rotate_2.png?raw=true"
alt="image" /> <img
src="https://github.com/headless-piston/blog_images/blob/main/rotate_3.png?raw=true"
alt="image" />
左旋与右旋互为镜像。将第三张图中的树左旋可得到第一张图中的树。</p>
<h3 id="splay-树">Splay 树</h3>
<h4 id="定义">定义</h4>
<p>一种二叉平衡树，通过 Splay（伸展）操作，在 <span
class="math inline">\(O(\log n)\)</span>
时间内实现插入、查询和删除操作。注意，<span class="math inline">\(O(\log
n)\)</span> 为 Splay 的<strong>均摊</strong>时间复杂度。Splay
树将旋转操作用到了极致，但常数在平衡树中属于较大的。</p>
<h4 id="声明">声明</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>];<span class="comment">//son[i][0/1]表示节点i的左/右儿子编号</span></span><br><span class="line"><span class="type">int</span> fa[N];<span class="comment">//父节点</span></span><br><span class="line"><span class="type">int</span> tot;<span class="comment">//已使用节点个数</span></span><br><span class="line"><span class="type">int</span> val[N];<span class="comment">//val[i]为节点i的权值</span></span><br><span class="line"><span class="type">int</span> cnt[N];<span class="comment">//cnt[i]为节点i所对权值出现的次数</span></span><br><span class="line"><span class="type">int</span> siz[N];<span class="comment">//子树的大小</span></span><br></pre></td></tr></table></figure>
<h4 id="辅助操作">辅助操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dir</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//判断节点x是父节点的左儿子还是右儿子</span></span><br><span class="line">	<span class="keyword">return</span> x==son[fa[x]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//更新节点x的信息</span></span><br><span class="line">	siz[x]=cnt[x]+siz[son[x][<span class="number">0</span>]]+siz[son[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="旋转操作">旋转操作</h4>
<p>设需要上移节点 <span class="math inline">\(x\)</span>，进行右旋操作。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*右旋</span></span><br><span class="line"><span class="comment">			z           z</span></span><br><span class="line"><span class="comment">           /           /</span></span><br><span class="line"><span class="comment">          y	          x</span></span><br><span class="line"><span class="comment">         / \    -&gt;   / \</span></span><br><span class="line"><span class="comment">		x  yr       xl  y</span></span><br><span class="line"><span class="comment">       / \             / \</span></span><br><span class="line"><span class="comment">      xl xr           xr yr</span></span><br><span class="line"><span class="comment">  左旋</span></span><br><span class="line"><span class="comment">			z           z</span></span><br><span class="line"><span class="comment">			 \           \</span></span><br><span class="line"><span class="comment">			  y           x</span></span><br><span class="line"><span class="comment">			 / \  -&gt;     / \</span></span><br><span class="line"><span class="comment">			yl  x       y   xr</span></span><br><span class="line"><span class="comment">			   / \     / \</span></span><br><span class="line"><span class="comment">		      xl xr   yl xl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="type">int</span> y=fa[x],z=fa[y];</span><br><span class="line">	<span class="type">bool</span> r=<span class="built_in">dir</span>(x);</span><br><span class="line">	son[y][r]=son[x][!r];<span class="comment">//x的子节点转移到y</span></span><br><span class="line">	<span class="keyword">if</span>(son[x][!r])</span><br><span class="line">		fa[son[x][!r]]=y;</span><br><span class="line">	fa[x]=z;<span class="comment">//x变为z的子节点</span></span><br><span class="line">	<span class="keyword">if</span>(z)</span><br><span class="line">		son[z][<span class="built_in">dir</span>(y)]=x;</span><br><span class="line">	son[x][!r]=y;<span class="comment">//y变为x的子节点</span></span><br><span class="line">	fa[y]=x;</span><br><span class="line">	<span class="built_in">push_up</span>(y);</span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="伸展操作">伸展操作</h4>
<p>Splay 树要求访问每一个节点 <span class="math inline">\(x\)</span>
后强制其旋转到根节点。该操作就是伸展操作。通过一系列伸展步骤将 <span
class="math inline">\(x\)</span> 逐步移到根节点。记 <span
class="math inline">\(x\)</span> 的父节点为 <span
class="math inline">\(p\)</span>，伸展步骤有三种： - zig/zag：当 <span
class="math inline">\(p\)</span> 为根节点时，直接将 <span
class="math inline">\(x\)</span> 左旋或右旋。在 <span
class="math inline">\(x\)</span>
在伸展操作刚开始时深度为奇数时作为伸展操作的最后一步。 -
zig-zig/zag-zag（一字型）：当 <span class="math inline">\(p\)</span>
不是根节点且 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(p\)</span>
都是左侧子节点或都是右侧子节点时进行。首先将 <span
class="math inline">\(p\)</span> 旋转，然后将 <span
class="math inline">\(x\)</span> 旋转。 - zig-zag/zag-zig（之字型）：当
<span class="math inline">\(p\)</span> 不是根节点且 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(p\)</span>
一个为左侧子节点一个为右侧子节点时进行。将 <span
class="math inline">\(x\)</span> 先左旋再右旋或先右旋再左旋。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//z为根节点</span></span><br><span class="line">	<span class="type">int</span> temp=fa[z];</span><br><span class="line">	<span class="keyword">while</span>(fa[x]!=temp)&#123;</span><br><span class="line">		<span class="type">int</span> y=fa[x];</span><br><span class="line">		<span class="keyword">if</span>(fa[y]!=temp)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dir</span>(x)==<span class="built_in">dir</span>(y))</span><br><span class="line">				<span class="built_in">rotate</span>(y);<span class="comment">//一字型</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">rotate</span>(x);<span class="comment">//之字型</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rotate</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	z=x;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="平衡树操作">平衡树操作</h4>
<h5 id="按照值查找">按照值查找</h5>
<p>查找值 <span class="math inline">\(v\)</span>，并将 <span
class="math inline">\(v\)</span> 所对节点上移至根部。 若不存在值为 <span
class="math inline">\(v\)</span>
的节点，则要将最后一个访问到的节点上移至根部。此时的根为所有大于 <span
class="math inline">\(v\)</span> 的值中最小的或所有小于 <span
class="math inline">\(v\)</span> 的值中最大的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//该函数调用后的根节点即为返回值</span></span><br><span class="line">	<span class="type">int</span> x=z,y=fa[x];</span><br><span class="line">	<span class="keyword">while</span>(x&amp;&amp;val[x]!=v)&#123;</span><br><span class="line">		y=x;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x?x:y);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="按照排名访问">按照排名访问</h5>
<p>即查找树中第 <span class="math inline">\(k\)</span>
小的元素。利用记载的子树大小进行查找。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loc</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]&gt;=k)</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]+cnt[x]&gt;=k)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k-=siz[son[x][<span class="number">0</span>]]+cnt[x];</span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="合并">合并</h5>
<p>合并两棵 Splay 树，设根节点分别为 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span>，则需要 <span
class="math inline">\(x\)</span> 树中的最大值小于 <span
class="math inline">\(y\)</span> 中的最小值。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//x树中的最大值小于y树中的最小值，返回合并后的根节点</span></span><br><span class="line">	<span class="keyword">if</span>(!x||!y)</span><br><span class="line">		<span class="keyword">return</span> x|y;<span class="comment">//存在空树，直接返回</span></span><br><span class="line">	<span class="built_in">loc</span>(y,<span class="number">1</span>);<span class="comment">//将y树最小值移至根节点</span></span><br><span class="line">	son[y][<span class="number">0</span>]=x;<span class="comment">//此时y左节点必然为空</span></span><br><span class="line">	fa[x]=y;<span class="comment">//x成为y的左子树</span></span><br><span class="line">	<span class="built_in">push_up</span>(y);</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="分裂">分裂</h5>
<p>根据某值 <span class="math inline">\(v\)</span>，将 Splay
树分裂为值小于等于 <span class="math inline">\(v\)</span> 和大于 <span
class="math inline">\(v\)</span> 两部分。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;<span class="comment">//通过引用返回分裂后的根节点a和b</span></span><br><span class="line">	<span class="comment">//x为当前根节点，按照权值v分裂为小于等于v和大于v两部分</span></span><br><span class="line">	<span class="keyword">if</span>(!x)&#123;</span><br><span class="line">		a=b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//树为空</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">find</span>(x,v);<span class="comment">//将权值为v的节点旋转到根节点</span></span><br><span class="line">	<span class="keyword">if</span>(val[x]&lt;=v)&#123;</span><br><span class="line">		a=x;</span><br><span class="line">		b=son[x][<span class="number">1</span>];</span><br><span class="line">		son[x][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		fa[b]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">push_up</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		b=x;</span><br><span class="line">		a=son[x][<span class="number">0</span>];</span><br><span class="line">		son[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		fa[a]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">push_up</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="插入">插入</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z,y=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&amp;&amp;val[x]!=v)&#123;</span><br><span class="line">		y=x;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x)</span><br><span class="line">		cnt[x]++,siz[x]++;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		x=++tot;</span><br><span class="line">		val[x]=v;</span><br><span class="line">		cnt[x]=siz[x]=<span class="number">1</span>;</span><br><span class="line">		fa[x]=y;</span><br><span class="line">		<span class="keyword">if</span>(y)&#123;</span><br><span class="line">			<span class="keyword">if</span>(v&lt;val[y])</span><br><span class="line">				son[y][<span class="number">0</span>]=x;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				son[y][<span class="number">1</span>]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x);<span class="comment">//插入过后不要忘记转到根节点</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除">删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="keyword">if</span>(!z||val[z]!=v)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//删除失败</span></span><br><span class="line">	cnt[z]--,siz[z]--;</span><br><span class="line">	<span class="keyword">if</span>(!cnt[z])&#123;<span class="comment">//该节点对应的值被删完了</span></span><br><span class="line">		<span class="type">int</span> x=son[z][<span class="number">0</span>],y=son[z][<span class="number">1</span>];</span><br><span class="line">		fa[x]=fa[y]=<span class="number">0</span>;</span><br><span class="line">		z=<span class="built_in">merge</span>(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//删除成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查询排名">查询排名</h5>
<p>查询值 <span class="math inline">\(v\)</span> 的排名。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_rank</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="type">int</span> res=siz[son[z][<span class="number">0</span>]]<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">if</span>(val[z]&lt;v)</span><br><span class="line">		res+=cnt[z];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="查询前驱">查询前驱</h5>
<p>即查询小于 <span class="math inline">\(v\)</span> 的最大的数。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pre</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="keyword">if</span>(z&amp;&amp;val[z]&lt;v)</span><br><span class="line">		<span class="keyword">return</span> val[z];</span><br><span class="line">	<span class="type">int</span> x=son[z][<span class="number">0</span>];<span class="comment">//在左子树中查找最大值</span></span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span> -inf;</span><br><span class="line">	<span class="keyword">while</span>(son[x][<span class="number">1</span>])</span><br><span class="line">		x=son[x][<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span> val[z];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="查询后继">查询后继</h5>
<p>即查询大于 <span class="math inline">\(v\)</span> 的最小的数。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_nxt</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="keyword">if</span>(z&amp;&amp;val[z]&gt;v)</span><br><span class="line">		<span class="keyword">return</span> val[z];</span><br><span class="line">	<span class="type">int</span> x=son[z][<span class="number">1</span>];<span class="comment">//在右子树中查找最小值</span></span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span> inf;</span><br><span class="line">	<span class="keyword">while</span>(son[x][<span class="number">0</span>])</span><br><span class="line">		x=son[x][<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span> val[z];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="序列操作">序列操作</h4>
<h5 id="区间翻转">区间翻转</h5>
<p>我们需要在树中加入值为 <span class="math inline">\(-inf\)</span> 和
<span class="math inline">\(inf\)</span>
两个哨兵节点，防止翻转区间包含第 <span class="math inline">\(1\)</span>
个节点或最后一个节点时出事。与线段树类似，我们使用懒标记记录翻转情况。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="built_in">loc</span>(root,l);<span class="comment">//将l转至根节点</span></span><br><span class="line">	<span class="built_in">loc</span>(son[root][<span class="number">1</span>],r-l<span class="number">+2</span>);<span class="comment">//将r转至根节点的右儿子，由于根已改变，所以第二个参数传的是r-l+2</span></span><br><span class="line">	<span class="type">int</span> x=son[son[root][<span class="number">1</span>]][<span class="number">0</span>];<span class="comment">//根节点右儿子的左儿子，则x为区间[l,r]的根节点</span></span><br><span class="line">	<span class="built_in">update_tag</span>(x);</span><br><span class="line">	<span class="built_in">push_down</span>(x);</span><br><span class="line">	<span class="built_in">splay</span>(root,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 辅助操作 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tag</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">swap</span>(son[x][<span class="number">0</span>],son[x][<span class="number">1</span>]);</span><br><span class="line">	tag[x]^=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tag[x])&#123;</span><br><span class="line">		<span class="keyword">if</span>(son[x][<span class="number">0</span>])</span><br><span class="line">			<span class="built_in">update_tag</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span>(son[x][<span class="number">1</span>])</span><br><span class="line">			<span class="built_in">update_tag</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">		tag[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 同时，<span
class="math inline">\(\operatorname{loc}\)</span> 函数查找时要更新懒标记
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loc</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z;</span><br><span class="line">	<span class="built_in">push_down</span>(x);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]&gt;=k)</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]<span class="number">+1</span>&gt;=k)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k-=siz[son[x][<span class="number">0</span>]]<span class="number">+1</span>;</span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">push_down</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="无注释版代码">无注释版代码</h4>
<details>
<summary>
模板题 1 主体部分
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dir</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==son[fa[x]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	siz[x]=cnt[x]+siz[son[x][<span class="number">0</span>]]+siz[son[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> y=fa[x],z=fa[y];</span><br><span class="line">	<span class="type">bool</span> r=<span class="built_in">dir</span>(x);</span><br><span class="line">	son[y][r]=son[x][!r];</span><br><span class="line">	<span class="keyword">if</span>(son[x][!r])</span><br><span class="line">		fa[son[x][!r]]=y;</span><br><span class="line">	fa[x]=z;</span><br><span class="line">	<span class="keyword">if</span>(z)</span><br><span class="line">		son[z][<span class="built_in">dir</span>(y)]=x;</span><br><span class="line">	son[x][!r]=y;</span><br><span class="line">	fa[y]=x;</span><br><span class="line">	<span class="built_in">push_up</span>(y);</span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=fa[z];</span><br><span class="line">	<span class="keyword">while</span>(fa[x]!=temp)&#123;</span><br><span class="line">		<span class="type">int</span> y=fa[x];</span><br><span class="line">		<span class="keyword">if</span>(fa[y]!=temp)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dir</span>(x)==<span class="built_in">dir</span>(y))</span><br><span class="line">				<span class="built_in">rotate</span>(y);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">rotate</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rotate</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	z=x;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z,y=fa[x];</span><br><span class="line">	<span class="keyword">while</span>(x&amp;&amp;val[x]!=v)&#123;</span><br><span class="line">		y=x;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x?x:y);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loc</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]&gt;=k)</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]+cnt[x]&gt;=k)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k-=siz[son[x][<span class="number">0</span>]]+cnt[x];</span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x||!y)</span><br><span class="line">		<span class="keyword">return</span> x|y;</span><br><span class="line">	<span class="built_in">loc</span>(y,<span class="number">1</span>);</span><br><span class="line">	son[y][<span class="number">0</span>]=x;</span><br><span class="line">	fa[x]=y;</span><br><span class="line">	<span class="built_in">push_up</span>(y);</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z,y=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&amp;&amp;val[x]!=v)&#123;</span><br><span class="line">		y=x;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x)</span><br><span class="line">		cnt[x]++,siz[x]++;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		x=++tot;</span><br><span class="line">		val[x]=v;</span><br><span class="line">		cnt[x]=siz[x]=<span class="number">1</span>;</span><br><span class="line">		fa[x]=y;</span><br><span class="line">		<span class="keyword">if</span>(y)&#123;</span><br><span class="line">			<span class="keyword">if</span>(v&lt;val[y])</span><br><span class="line">				son[y][<span class="number">0</span>]=x;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				son[y][<span class="number">1</span>]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="keyword">if</span>(!z||val[z]!=v)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	cnt[z]--,siz[z]--;</span><br><span class="line">	<span class="keyword">if</span>(!cnt[z])&#123;</span><br><span class="line">		<span class="type">int</span> x=son[z][<span class="number">0</span>],y=son[z][<span class="number">1</span>];</span><br><span class="line">		fa[x]=fa[y]=<span class="number">0</span>;</span><br><span class="line">		z=<span class="built_in">merge</span>(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_rank</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="type">int</span> res=siz[son[z][<span class="number">0</span>]]<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">if</span>(val[z]&lt;v)</span><br><span class="line">		res+=cnt[z];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pre</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="keyword">if</span>(z&amp;&amp;val[z]&lt;v)</span><br><span class="line">		<span class="keyword">return</span> val[z];</span><br><span class="line">	<span class="type">int</span> x=son[z][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(son[x][<span class="number">1</span>])</span><br><span class="line">		x=son[x][<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span> val[z];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_nxt</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="keyword">if</span>(z&amp;&amp;val[z]&gt;v)</span><br><span class="line">		<span class="keyword">return</span> val[z];</span><br><span class="line">	<span class="type">int</span> x=son[z][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(son[x][<span class="number">0</span>])</span><br><span class="line">		x=son[x][<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span> val[z];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>
模板题 2 主体部分
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>],fa[N],tot,val[N],siz[N],root;</span><br><span class="line"><span class="type">bool</span> tag[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dir</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==son[fa[x]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	siz[x]=<span class="number">1</span>+siz[son[x][<span class="number">0</span>]]+siz[son[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tag</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">swap</span>(son[x][<span class="number">0</span>],son[x][<span class="number">1</span>]);</span><br><span class="line">	tag[x]^=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tag[x])&#123;</span><br><span class="line">		<span class="keyword">if</span>(son[x][<span class="number">0</span>])</span><br><span class="line">			<span class="built_in">update_tag</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span>(son[x][<span class="number">1</span>])</span><br><span class="line">			<span class="built_in">update_tag</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">		tag[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> y=fa[x],z=fa[y];</span><br><span class="line">	<span class="type">bool</span> r=<span class="built_in">dir</span>(x);</span><br><span class="line">	son[y][r]=son[x][!r];</span><br><span class="line">	<span class="keyword">if</span>(son[x][!r])</span><br><span class="line">		fa[son[x][!r]]=y;</span><br><span class="line">	fa[x]=z;</span><br><span class="line">	<span class="keyword">if</span>(z)</span><br><span class="line">		son[z][<span class="built_in">dir</span>(y)]=x;</span><br><span class="line">	son[x][!r]=y;</span><br><span class="line">	fa[y]=x;</span><br><span class="line">	<span class="built_in">push_up</span>(y);</span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=fa[z];</span><br><span class="line">	<span class="keyword">while</span>(fa[x]!=temp)&#123;</span><br><span class="line">		<span class="type">int</span> y=fa[x];</span><br><span class="line">		<span class="keyword">if</span>(fa[y]!=temp)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dir</span>(x)==<span class="built_in">dir</span>(y))</span><br><span class="line">				<span class="built_in">rotate</span>(y);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">rotate</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rotate</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	z=x;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loc</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z;</span><br><span class="line">	<span class="built_in">push_down</span>(x);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]&gt;=k)</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]<span class="number">+1</span>&gt;=k)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k-=siz[son[x][<span class="number">0</span>]]<span class="number">+1</span>;</span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">push_down</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="built_in">loc</span>(root,l);</span><br><span class="line">	<span class="built_in">loc</span>(son[root][<span class="number">1</span>],r-l<span class="number">+2</span>);</span><br><span class="line">	<span class="type">int</span> x=son[son[root][<span class="number">1</span>]][<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">update_tag</span>(x);</span><br><span class="line">	<span class="built_in">push_down</span>(x);</span><br><span class="line">	<span class="built_in">splay</span>(root,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">+1</span>;i++)&#123;</span><br><span class="line">		son[++tot][<span class="number">0</span>]=root;</span><br><span class="line">		<span class="keyword">if</span>(root)</span><br><span class="line">			fa[root]=tot;</span><br><span class="line">		root=tot;</span><br><span class="line">		val[tot]=i;</span><br><span class="line">		siz[tot]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">push_up</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(root,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="treap">Treap</h3>
<p>Treap
将二叉搜索树与堆结合起来，通过维护堆的性质维护平衡。所以每个节点需要额外维护一个随机的值，用这个随机的值来维护堆的性质。这里介绍旋转
Treap，即通过旋转维护平衡性。</p>
<h4 id="无注释版代码-1">无注释版代码</h4>
<details>
<summary>
Code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>],val[N],rnd[N],siz[N],cnt[N],tot,root;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	siz[x]=cnt[x]+siz[son[x][<span class="number">0</span>]]+siz[son[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">bool</span> dir)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=son[x][!dir];</span><br><span class="line">	son[x][!dir]=son[temp][dir];</span><br><span class="line">	son[temp][dir]=x;</span><br><span class="line">	x=temp;</span><br><span class="line">	<span class="built_in">push_up</span>(son[x][dir]);</span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)&#123;</span><br><span class="line">		x=++tot;</span><br><span class="line">		siz[x]=cnt[x]=<span class="number">1</span>;</span><br><span class="line">		val[x]=v;</span><br><span class="line">		rnd[x]=<span class="built_in">rand</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(val[x]==v)</span><br><span class="line">		cnt[x]++;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">bool</span> dir=(v&gt;val[x]);</span><br><span class="line">		<span class="built_in">insert</span>(son[x][dir],v);</span><br><span class="line">		<span class="keyword">if</span>(rnd[x]&lt;rnd[son[x][dir]])</span><br><span class="line">			<span class="built_in">rotate</span>(x,!dir);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">		<span class="built_in">erase</span>(son[x][<span class="number">0</span>],v);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(v&gt;val[x])</span><br><span class="line">		<span class="built_in">erase</span>(son[x][<span class="number">1</span>],v);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt[x]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">			cnt[x]--;</span><br><span class="line">			<span class="built_in">push_up</span>(x);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(son[x][<span class="number">0</span>]||son[x][<span class="number">1</span>])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!son[x][<span class="number">1</span>]||rnd[son[x][<span class="number">0</span>]]&gt;rnd[son[x][<span class="number">1</span>]])</span><br><span class="line">				<span class="built_in">rotate</span>(x,<span class="number">1</span>),<span class="built_in">erase</span>(son[x][<span class="number">1</span>],v);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">rotate</span>(x,<span class="number">0</span>),<span class="built_in">erase</span>(son[x][<span class="number">0</span>],v);</span><br><span class="line">			<span class="built_in">push_up</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_rank</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v==val[x])</span><br><span class="line">		<span class="keyword">return</span> siz[son[x][<span class="number">0</span>]]<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">find_rank</span>(son[x][<span class="number">0</span>],v);</span><br><span class="line">	<span class="keyword">return</span> siz[son[x][<span class="number">0</span>]]+cnt[x]+<span class="built_in">find_rank</span>(son[x][<span class="number">1</span>],v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]&gt;=k)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">find</span>(son[x][<span class="number">0</span>],k);</span><br><span class="line">	<span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]+cnt[x]&gt;=k)</span><br><span class="line">		<span class="keyword">return</span> val[x];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(son[x][<span class="number">1</span>],k-siz[son[x][<span class="number">0</span>]]-cnt[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pre</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=root,pre;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v&gt;val[x])</span><br><span class="line">			pre=val[x],x=son[x][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_nxt</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=root,nxt;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">			nxt=val[x],x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nxt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="fhq-treap">FHQ Treap</h3>
<p>即无旋转操作的
Treap，通过分裂和合并来维护平衡性。因其无旋，所以可以做可持久化数据结构，并且是平衡树中比较好写的一种。缺点是常数较大。</p>
<details>
<summary>
模板题 1 AC 代码
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FHQ_Treap</span>&#123;</span><br><span class="line">	<span class="type">int</span> ls,rs;</span><br><span class="line">	<span class="type">int</span> val,rnd,siz;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> root,tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	t[u].siz=t[t[u].ls].siz+t[t[u].rs].siz<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	t[++tot].rnd=<span class="built_in">rand</span>()&lt;&lt;<span class="number">15</span>|<span class="built_in">rand</span>();</span><br><span class="line">	t[tot].siz=<span class="number">1</span>;</span><br><span class="line">	t[tot].val=val;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> val,<span class="type">int</span> &amp;lrt,<span class="type">int</span> &amp;rrt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p)&#123;</span><br><span class="line">		lrt=rrt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[p].val&lt;=val)&#123;</span><br><span class="line">		lrt=p;</span><br><span class="line">		<span class="built_in">split</span>(t[p].rs,val,t[p].rs,rrt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		rrt=p;</span><br><span class="line">		<span class="built_in">split</span>(t[p].ls,val,lrt,t[p].ls);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!l||!r)</span><br><span class="line">		<span class="keyword">return</span> l|r;</span><br><span class="line">	<span class="keyword">if</span>(t[l].rnd&gt;t[r].rnd)&#123;</span><br><span class="line">		t[l].rs=<span class="built_in">merge</span>(t[l].rs,r);</span><br><span class="line">		<span class="built_in">push_up</span>(l);</span><br><span class="line">		<span class="keyword">return</span> l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		t[r].ls=<span class="built_in">merge</span>(l,t[r].ls);</span><br><span class="line">		<span class="built_in">push_up</span>(r);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">split</span>(root,val,x,y);</span><br><span class="line">	root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,<span class="built_in">build</span>(val)),y);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,temp;</span><br><span class="line">	<span class="built_in">split</span>(root,val,x,y);</span><br><span class="line">	<span class="built_in">split</span>(x,val<span class="number">-1</span>,x,temp);</span><br><span class="line">	temp=<span class="built_in">merge</span>(t[temp].ls,t[temp].rs);</span><br><span class="line">	root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,temp),y);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_rank</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">split</span>(root,val<span class="number">-1</span>,x,y);</span><br><span class="line">	<span class="type">int</span> res=t[x].siz<span class="number">+1</span>;</span><br><span class="line">	root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_kth</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=root;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(t[t[p].ls].siz<span class="number">+1</span>==k)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t[t[p].ls].siz<span class="number">+1</span>&gt;k)</span><br><span class="line">			p=t[p].ls;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			k-=t[t[p].ls].siz<span class="number">+1</span>,p=t[p].rs;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t[p].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">split</span>(root,val<span class="number">-1</span>,x,y);</span><br><span class="line">	<span class="type">int</span> p=x;</span><br><span class="line">	<span class="keyword">while</span>(t[p].rs)</span><br><span class="line">		p=t[p].rs;</span><br><span class="line">	root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span> t[p].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nxt</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">split</span>(root,val,x,y);</span><br><span class="line">	<span class="type">int</span> p=y;</span><br><span class="line">	<span class="keyword">while</span>(t[p].ls)</span><br><span class="line">		p=t[p].ls;</span><br><span class="line">	root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span> t[p].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,opt,x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;opt,&amp;x);</span><br><span class="line">		<span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="built_in">insert</span>(x);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="built_in">erase</span>(x);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find_rank</span>(x));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find_kth</span>(x));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">pre</span>(x));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">nxt</span>(x));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p><a href="https://www.luogu.com.cn/problem/P3369"
title="模板题 1">模板题 1</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3391"
title="模板题 2">模板题 2</a></p>
<p><a href="https://oi-wiki.org/ds/bst/"
title="参考资料">参考资料</a></p>
<p><a href="https://www.deepseek.com/"
title="特别鸣谢">特别鸣谢</a>，为我解答了很多问题，以及帮我进行代码的修正。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>五一集训题目合集</title>
    <url>/2025/07/04/%E4%BA%94%E4%B8%80%E9%9B%86%E8%AE%AD%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="a-simple-task"><a
href="https://codeforces.com/problemset/problem/558/E"
title="A Simple Task">A Simple Task</a></h3>
<p>因为字符集大小只有 <span
class="math inline">\(26\)</span>，考虑直接在线段树每个节点维护当前区间的字符个数。排序时直接暴力区间赋值，复杂度会有
<span class="math inline">\(26\)</span> 的常数。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u&lt;&lt;1|1</span></span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> tree[N*<span class="number">4</span>][<span class="number">26</span>],tag[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        tree[u][i]=tree[ls][i]+tree[rs][i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tag[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[u][s[l]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!~tag[u])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        tree[ls][i]=tree[rs][i]=<span class="number">0</span>;</span><br><span class="line">    tree[ls][tag[u]]=mid-l<span class="number">+1</span>,tree[rs][tag[u]]=r-mid;</span><br><span class="line">    tag[ls]=tag[rs]=tag[u];</span><br><span class="line">    tag[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            tree[u][i]=<span class="number">0</span>;</span><br><span class="line">        tree[u][k]=r-l<span class="number">+1</span>;</span><br><span class="line">        tag[u]=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="built_in">modify</span>(ls,l,mid,x,y,k);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">        <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">        <span class="keyword">return</span> tree[u][k];</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        res+=<span class="built_in">query</span>(ls,l,mid,x,y,k);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">        res+=<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">query_ans</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(tree[u][i])</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>+i;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_ans</span>(ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_ans</span>(rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;</span><br><span class="line">    s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> l,r,k;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">        <span class="keyword">if</span>(k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">                a[i]=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i])</span><br><span class="line">                    <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,l+a[i]<span class="number">-1</span>,i);</span><br><span class="line">                l+=a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">                a[i]=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">25</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i])</span><br><span class="line">                    <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,l+a[i]<span class="number">-1</span>,i);</span><br><span class="line">                l+=a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">query_ans</span>(<span class="number">1</span>,<span class="number">1</span>,n,i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="heoi2012-采花"><a href="https://www.luogu.com.cn/problem/P4113"
title="[HEOI2012] 采花">[HEOI2012] 采花</a></h3>
离线，树状数组维护之前出现两次及以上的颜色数，每次出现 <span
class="math inline">\(2\)</span> 次后在之前的位置加 <span
class="math inline">\(1\)</span>，并且把之前的之前加的撤销。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,c,m,x[N],tree[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        tree[i]+=k;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&gt;<span class="number">0</span>;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        res+=tree[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Query &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r&lt;x.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="type">int</span> pre1[N],pre2[N],ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,c,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(x[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">read</span>(q[i].l,q[i].r),q[i].id=i;</span><br><span class="line">    std::<span class="built_in">sort</span>(q<span class="number">+1</span>,q<span class="number">+1</span>+m);</span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now&lt;=q[i].r)&#123;</span><br><span class="line">            <span class="type">int</span> temp=x[now];</span><br><span class="line">            <span class="keyword">if</span>(pre1[temp])&#123;</span><br><span class="line">                <span class="built_in">modify</span>(pre1[temp],<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(pre2[temp])</span><br><span class="line">                    <span class="built_in">modify</span>(pre2[temp],<span class="number">-1</span>);</span><br><span class="line">                pre2[temp]=pre1[temp];</span><br><span class="line">            &#125;</span><br><span class="line">            pre1[temp]=now;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[q[i].id]=<span class="built_in">query</span>(q[i].r)-<span class="built_in">query</span>(q[i].l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ynoi2012-noip2015-充满了希望"><a
href="https://www.luogu.com.cn/problem/P5524"
title="[Ynoi2012] NOIP2015 充满了希望">[Ynoi2012] NOIP2015
充满了希望</a></h3>
注意到，任何情况下，查询的答案要么是 <span
class="math inline">\(0\)</span>，要么是一个确定的值（即有没有被修改过），这个确定的值必然来自
2 操作。所以维护时间戳，利用树状数组查询区间和。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,q,opt[N];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">segtree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> tree[N*<span class="number">4</span>];</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tree[u])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            tree[ls]=tree[rs]=tree[u];</span><br><span class="line">            tree[u]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">                tree[u]=k;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">push_down</span>(u);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">                <span class="built_in">modify</span>(ls,l,mid,x,y,k);</span><br><span class="line">            <span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">                <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tree[u]||l==r)</span><br><span class="line">                <span class="keyword">return</span> tree[u];</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">push_down</span>(u);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">query</span>(ls,l,mid,x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ll tree[N];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!x)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=m;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">                tree[i]+=k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!x)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ll res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">                res+=tree[i];</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;b;</span><br><span class="line"><span class="type">int</span> val[N],t[N];</span><br><span class="line">ll ans[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; ask[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,opt,l,r,k;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            <span class="type">int</span> x=a.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l),y=a.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,r);</span><br><span class="line">            a.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,l,y);</span><br><span class="line">            a.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,r,r,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r&gt;&gt;val[i];</span><br><span class="line">            a.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            t[i]=a.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l,r;i&lt;=q;i++)&#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        ask[r].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(l,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i])</span><br><span class="line">            b.<span class="built_in">modify</span>(t[i],val[t[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> k:ask[i])</span><br><span class="line">            ans[k.second]=b.<span class="built_in">query</span>(i)-b.<span class="built_in">query</span>(k.first<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="thupc-2017-天天爱射击"><a
href="https://www.luogu.com.cn/problem/P7424"
title="[THUPC 2017] 天天爱射击">[THUPC 2017] 天天爱射击</a></h3>
法一： 主席树 + 二分答案。对每颗子弹设一个版本，二分版本。<span
class="math inline">\(O(n\log^2n)\)</span>（常数过大无法通过）。 法二：
静态区间第 <span class="math inline">\(k\)</span> 大。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> root[N],tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum,ls,rs;</span><br><span class="line">&#125;tree[N*<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tree[u].sum=tree[tree[u].ls].sum+tree[tree[u].rs].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> old,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    u=++tot;</span><br><span class="line">    tree[u]=tree[old];</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[u].sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="built_in">modify</span>(tree[u].ls,tree[old].ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">modify</span>(tree[u].rs,tree[old].rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> old,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>,s=tree[tree[u].ls].sum-tree[tree[old].ls].sum;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=s)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[u].ls,tree[old].ls,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[u].rs,tree[old].rs,mid<span class="number">+1</span>,r,k-s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x1,x2,s;</span><br><span class="line">&#125;q[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">read</span>(q[i].x1,q[i].x2,q[i].s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">read</span>(x);</span><br><span class="line">		b[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2e5</span>;i++)&#123;</span><br><span class="line">		root[i]=root[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t:b[i])</span><br><span class="line">			<span class="built_in">modify</span>(root[i],root[i],<span class="number">1</span>,m<span class="number">+1</span>,t);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x1=q[i].x1,x2=q[i].x2,s=q[i].s;</span><br><span class="line">		<span class="type">int</span> k=<span class="built_in">query</span>(root[x2],root[x1<span class="number">-1</span>],<span class="number">1</span>,m<span class="number">+1</span>,s);</span><br><span class="line">        ans[k]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="legacy"><a
href="https://codeforces.com/problemset/problem/786/B"
title="Legacy">Legacy</a></h3>
<p>线段树优化建图。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K 4e5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 4557430888798830399</span></span><br><span class="line"><span class="type">int</span> n,q,s,a[N],tot_edge,head[N*<span class="number">8</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[N*<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++tot_edge].to=v;</span><br><span class="line">    e[tot_edge].nxt=head[u];</span><br><span class="line">    e[tot_edge].w=w;</span><br><span class="line">    head[u]=tot_edge;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        a[l]=u;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_edge</span>(u,ls,<span class="number">0</span>),<span class="built_in">add_edge</span>(u,rs,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">add_edge</span>(ls+K,u+K,<span class="number">0</span>),<span class="built_in">add_edge</span>(rs+K,u+K,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">bool</span> rev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rev)</span><br><span class="line">            <span class="built_in">add_edge</span>(v+K,u,w);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">add_edge</span>(u+K,v,w);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="built_in">modify</span>(ls,l,mid,x,y,v,w,rev);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">        <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,v,w,rev);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;ll,<span class="type">int</span>&gt;,vector&lt;pair&lt;ll,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;ll,<span class="type">int</span>&gt;&gt;&gt; que;</span><br><span class="line"><span class="type">bool</span> vis[N*<span class="number">8</span>];</span><br><span class="line">ll dis[N*<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">read</span>(n,q,s);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add_edge</span>(a[i],a[i]+K,<span class="number">0</span>),<span class="built_in">add_edge</span>(a[i]+K,a[i],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,opt,x,y,v,w;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(opt);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x,y,w);</span><br><span class="line">            <span class="built_in">add_edge</span>(a[x]+K,a[y],w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(v,x,y,w);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,a[v],w,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">read</span>(v,x,y,w);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,a[v],w,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[(<span class="type">int</span>)(a[s]+K)]=<span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,a[s]+K));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=que.<span class="built_in">top</span>().second;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[a[i]]==inf)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,dis[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="noi2018-归程"><a href="https://www.luogu.com.cn/problem/P4768"
title="[NOI2018] 归程">[NOI2018] 归程</a></h3>
<p>使用 Kruskal 重构树，倍增查找，时间复杂度 <span
class="math inline">\(O(n\log n)\)</span>。 <del>多测一定要记得清 head
数组……</del></p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>,M=<span class="number">4e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,a;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;x.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[M*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[M*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> tot_edge,head[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++tot_edge].to=v;</span><br><span class="line">    e[tot_edge].w=w;</span><br><span class="line">    e[tot_edge].nxt=head[u];</span><br><span class="line">    head[u]=tot_edge;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; que;</span><br><span class="line"><span class="type">int</span> dis[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=que.<span class="built_in">top</span>().second;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">		        que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q,k,s,fa[M*<span class="number">2</span>],w[M*<span class="number">2</span>],f[M*<span class="number">2</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=n;</span><br><span class="line">    <span class="built_in">sort</span>(p<span class="number">+1</span>,p<span class="number">+1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)</span><br><span class="line">        fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">find</span>(p[i].u),y=<span class="built_in">find</span>(p[i].v);</span><br><span class="line">        <span class="keyword">if</span>(x==y)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        fa[x]=fa[y]=++cnt;</span><br><span class="line">        w[cnt]=p[i].a;</span><br><span class="line">        dis[cnt]=<span class="built_in">Min</span>(dis[x],dis[y]);</span><br><span class="line">        f[x][<span class="number">0</span>]=f[y][<span class="number">0</span>]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">            f[j][i]=f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lastans,v0,p0;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(f[x][i]&amp;&amp;w[f[x][i]]&gt;y)</span><br><span class="line">            x=f[x][i];</span><br><span class="line">    <span class="keyword">return</span> dis[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;return.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;return.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		tot_edge=lastans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="built_in">sizeof</span>(w));</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">		<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">		<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">read</span>(n,m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="built_in">read</span>(p[i].u,p[i].v,l,p[i].a);</span><br><span class="line">            <span class="built_in">add_edge</span>(p[i].u,p[i].v,l);</span><br><span class="line">            <span class="built_in">add_edge</span>(p[i].v,p[i].u,l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dijkstra</span>();</span><br><span class="line">        <span class="built_in">kruskal</span>();</span><br><span class="line">        <span class="built_in">read</span>(q,k,s);</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="built_in">read</span>(v0,p0);</span><br><span class="line">            v0=(v0+k*lastans<span class="number">-1</span>)%n<span class="number">+1</span>;</span><br><span class="line">            p0=(p0+k*lastans)%(s<span class="number">+1</span>);</span><br><span class="line">            lastans=<span class="built_in">query</span>(v0,p0);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lastans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="scoi2016-萌萌哒"><a
href="https://www.luogu.com.cn/problem/P3295"
title="[SCOI2016] 萌萌哒">[SCOI2016] 萌萌哒</a></h3>
<p>倍增+并查集。考虑将区间二进制拆分，之后再合并。<span
class="math inline">\(f_{i,j}\)</span> 表示以 <span
class="math inline">\(i\)</span> 为左端点，长度为 <span
class="math inline">\(2^j\)</span> 的区间的所在连通块的左端点。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,f[N][<span class="number">25</span>],l1,r1,l2,r2,ans,maxn;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==f[x][k])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> f[x][k]=<span class="built_in">find</span>(f[x][k],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="built_in">find</span>(x,k),b=<span class="built_in">find</span>(y,k);</span><br><span class="line">    <span class="keyword">if</span>(a!=b)</span><br><span class="line">        f[a][k]=b;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    maxn=std::__lg(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=maxn;j++)</span><br><span class="line">            f[i][j]=i;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(l1,r1,l2,r2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=maxn;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">if</span>(l1+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=r1)&#123;</span><br><span class="line">                <span class="built_in">merge</span>(l1,l2,j);</span><br><span class="line">                l1+=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">                l2+=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=maxn;j;j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">find</span>(i,j);</span><br><span class="line">            <span class="built_in">merge</span>(i,x,j<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">merge</span>(i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)),x+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)),j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(f[i][<span class="number">0</span>]==i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                ans=<span class="number">9</span>;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans=(ans*<span class="number">10ll</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="hh-去散步"><a href="https://www.luogu.com.cn/problem/P2151"
title="HH 去散步">HH 去散步</a></h3>
<p>设边权均为 <span class="math inline">\(1\)</span>，计算邻接矩阵 <span
class="math inline">\(A\)</span> 的 <span
class="math inline">\(k\)</span> 次幂，则 <span
class="math inline">\(A^k_{i,j}\)</span> 表示走 <span
class="math inline">\(k\)</span> 步能连接 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span>
两点间的路径条数。但这道题要求不走回头路，我们考虑点边互换，记录入边和出边来避免走回头路。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">10</span>)</span><br><span class="line">        <span class="built_in">putchar</span>(x<span class="number">+48</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x%<span class="number">10</span><span class="number">+48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 45989</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> x[N][N];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="built_in">sizeof</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix &amp;a)&#123;</span><br><span class="line">        Matrix res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=cnt;k++)</span><br><span class="line">                    res.x[i][j]=(res.x[i][j]+x[i][k]*a.x[k][j]%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p;</span><br><span class="line"><span class="type">int</span> n,m,t,a,b,res;</span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        res.x[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,t,a,b);</span><br><span class="line">    a++,b++;</span><br><span class="line">    e[cnt=<span class="number">1</span>].u=<span class="number">0</span>,e[<span class="number">1</span>].v=a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        u++,v++;</span><br><span class="line">        e[++cnt].u=u;</span><br><span class="line">        e[cnt].v=v;</span><br><span class="line">        e[++cnt].u=v;</span><br><span class="line">        e[cnt].v=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">            <span class="keyword">if</span>(e[i].v==e[j].u&amp;&amp;i!=(j^<span class="number">1</span>)&amp;&amp;i!=j)</span><br><span class="line">                p.x[i][j]=<span class="number">1</span>;</span><br><span class="line">    p=<span class="built_in">qpow</span>(p,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">if</span>(e[i].v==b)</span><br><span class="line">            res=(res+p.x[<span class="number">1</span>][i])%mod;</span><br><span class="line">    <span class="built_in">write</span>(res);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="sdoi2015-寻宝游戏"><a
href="https://www.luogu.com.cn/problem/P3320"
title="[SDOI2015] 寻宝游戏">[SDOI2015] 寻宝游戏</a></h3>
<p>将关键点按 dfn 排序为 <span
class="math inline">\(a_1,a_2,a_3,\cdots,a_n\)</span>，则包含所有关键点的最小生成树的边权和的
<span class="math inline">\(2\)</span> 倍为 <span
class="math inline">\(dis(a_1,a_2)+dis(a_2,a_3)+\cdots+dis(a_n,a_1)\)</span>。
实现方面，使用一个 set 来查询前驱后继。这题不开 long long 一分没有。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll ans,d[N];</span><br><span class="line"><span class="type">int</span> dfn[N],son[N],dfncnt,idfn[N],dep[N],siz[N],top[N],fa[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    dep[u]=dep[f]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:e[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=i.to,w=i.w;</span><br><span class="line">        <span class="keyword">if</span>(v==f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        d[v]=d[u]+w;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]])</span><br><span class="line">            son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">    top[u]=topf;</span><br><span class="line">    dfn[u]=++dfncnt;</span><br><span class="line">    idfn[dfncnt]=u;</span><br><span class="line">    <span class="keyword">if</span>(!son[u])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:e[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=i.to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==son[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[a]!=top[b])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[a]]&gt;dep[top[b]])</span><br><span class="line">            a=fa[top[a]];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b=fa[top[b]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[a]&gt;dep[b]?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dis</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	a=idfn[a],b=idfn[b];</span><br><span class="line">    <span class="keyword">return</span> d[a]+d[b]<span class="number">-2</span>*d[<span class="built_in">lca</span>(a,b)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		st.<span class="built_in">insert</span>(t);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(st.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">		ans=<span class="number">2</span>*<span class="built_in">dis</span>(*st.<span class="built_in">begin</span>(),t);</span><br><span class="line">		st.<span class="built_in">insert</span>(t);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	st.<span class="built_in">insert</span>(t);</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">auto</span> it=st.<span class="built_in">find</span>(t);</span><br><span class="line">	<span class="keyword">if</span>(it==st.<span class="built_in">begin</span>())</span><br><span class="line">		x=*--st.<span class="built_in">end</span>();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		x=*--it;</span><br><span class="line">	it=st.<span class="built_in">find</span>(t);</span><br><span class="line">	<span class="keyword">if</span>(it==--st.<span class="built_in">end</span>())</span><br><span class="line">		y=*st.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		y=*++it;</span><br><span class="line">	ans+=<span class="built_in">dis</span>(x,t)+<span class="built_in">dis</span>(t,y)-<span class="built_in">dis</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(st.<span class="built_in">size</span>()&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		st.<span class="built_in">erase</span>(t);</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(st.<span class="built_in">size</span>()==<span class="number">3</span>)&#123;</span><br><span class="line">		st.<span class="built_in">erase</span>(t);</span><br><span class="line">		ans=<span class="number">2</span>*<span class="built_in">dis</span>(*st.<span class="built_in">begin</span>(),*--st.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">auto</span> it=st.<span class="built_in">find</span>(t);</span><br><span class="line">	<span class="keyword">if</span>(it==st.<span class="built_in">begin</span>())</span><br><span class="line">		x=*--st.<span class="built_in">end</span>();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		x=*--it;</span><br><span class="line">	it=st.<span class="built_in">find</span>(t);</span><br><span class="line">	<span class="keyword">if</span>(it==--st.<span class="built_in">end</span>())</span><br><span class="line">		y=*st.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		y=*++it;</span><br><span class="line">	ans-=<span class="built_in">dis</span>(x,t)+<span class="built_in">dis</span>(t,y)-<span class="built_in">dis</span>(x,y);</span><br><span class="line">	st.<span class="built_in">erase</span>(t);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">read</span>(x,y,z);</span><br><span class="line">        e[x].<span class="built_in">push_back</span>(&#123;y,z&#125;);</span><br><span class="line">        e[y].<span class="built_in">push_back</span>(&#123;x,z&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="built_in">read</span>(t);</span><br><span class="line">		t=dfn[t];</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">find</span>(t)==st.<span class="built_in">end</span>())</span><br><span class="line">			<span class="built_in">add</span>(t);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">			<span class="built_in">del</span>(t);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <tags>
        <tag>题目合集</tag>
      </tags>
  </entry>
  <entry>
    <title>初等数论</title>
    <url>/2025/07/15/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<p>之前写几篇数论文章已经忘了，而且写的也不是很美丽，正巧今天讲课讲了一遍数论，那就当从头复习一遍。</p>
<h3 id="符号与约定">符号与约定</h3>
<p>非特殊声明下，本文所涉及的数均为非负整数。<br />
<span class="math inline">\(a\mid b\)</span> 表示 <span
class="math inline">\(b\)</span> 是 <span
class="math inline">\(a\)</span> 的倍数，<span
class="math inline">\(a\)</span> 是 <span
class="math inline">\(b\)</span> 的约数。<br />
<span class="math inline">\(\gcd(a,b)\)</span> 表示 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span>
的最大公约数。在不引起混淆的前提下可记作 <span
class="math inline">\((a,b)\)</span>。<br />
<span class="math inline">\(\operatorname{lcm}(a,b)\)</span> 表示 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span>
的最小公倍数。在不引起混淆的前提下可记作 <span
class="math inline">\([a,b]\)</span>。</p>
<h3 id="素数">素数</h3>
<p>数量估计：小于等于 <span class="math inline">\(x\)</span>
的素数<strong>约有</strong> <span class="math inline">\(\dfrac{x}{\ln
x}\)</span> 个。</p>
<h4 id="埃拉托斯特尼筛法">埃拉托斯特尼筛法</h4>
<p>原理：所有合数必然都有素因子，则我们可以采用“标记”的思想，若遇到一个未被标记的数，则其必为素数，并将它的所有倍数标记。反之它就是合数。时间复杂度
<span class="math inline">\(O(n\log \log
n)\)</span>。我不会证。简单的优化是标记数组使用
<code>std::bitset</code>，性能甚至超越了 <span
class="math inline">\(O(n)\)</span> 的线性筛法。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e7</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">bitset&lt;N&gt; p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="number">1e7</span>;</span><br><span class="line">    p.<span class="built_in">set</span>();</span><br><span class="line">    p[<span class="number">0</span>]=p[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)</span><br><span class="line">        <span class="keyword">if</span>(p[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j+=i)</span><br><span class="line">                p[j]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 外层循环只需执行到 <span
class="math inline">\(\sqrt{n}\)</span> 即可。使用安全的除法运算防止
<code>int</code> 溢出。</p>
<h4 id="线性筛法">线性筛法</h4>
<p>也叫欧拉筛法。其时间复杂度为线性的原因是每个合数仅会被标记 <span
class="math inline">\(1\)</span>
次。更为重要的是，在筛出所有质数的同时也能求出所有数的最小质因子，可以优化质因数分解。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e7</span><span class="number">+10</span>,M=<span class="number">7e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,p[M],e[N],tot;<span class="comment">//e[i]存储i的最小质因子在p[]中的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="number">1e7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!e[i]) p[e[i]=++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=e[i]&amp;&amp;p[j]&lt;=n/i;j++)</span><br><span class="line">            e[p[j]*i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="算术基本定理">算术基本定理</h4>
<p>任何一个数 <span
class="math inline">\(n\)</span>，都可以表示为有限个素数之积。即可以表示为：
<span class="math display">\[n=\prod p_i^{\alpha_i}\]</span>
这也是标准素因数分解式。<br />
根据这个式子，设 <span class="math inline">\(a=\prod
p_i^{\alpha_i}\)</span>，<span class="math inline">\(b=\prod
p_i^{\beta_i}\)</span>，则 <span
class="math inline">\(\gcd(a,b)\)</span> 可表示为 <span
class="math inline">\(\prod p_i^{\min(\alpha_i,\beta_i)}\)</span>，<span
class="math inline">\(\operatorname{lcm}(a,b)\)</span> 可表示为 <span
class="math inline">\(\prod
p_i^{\max(\alpha_i,\beta_i)}\)</span>。根据这个定义，容易证明 <span
class="math display">\[\gcd(a,b)\times \operatorname{lcm}(a,b)=a\times
b\]</span></p>
<h3 id="同余">同余</h3>
<h4 id="求最大公约数">求最大公约数</h4>
<p>辗转相除法，又名欧几里得算法。原理：<span
class="math inline">\(\gcd(a,b)=\gcd(b,a\bmod
b)\)</span>。递归执行，边界为 <span
class="math inline">\(\gcd(a,0)=a\)</span>。时间复杂度 <span
class="math inline">\(O(\log \min(a,b))\)</span>。</p>
<h4 id="裴蜀定理">裴蜀定理</h4>
<p>对于 <span class="math inline">\(a,b\)</span>，存在 <span
class="math inline">\(x,y\)</span> 使得<br />
<span class="math display">\[ax+by=\gcd(a,b)\]</span> 并且方程 <span
class="math inline">\(ax+by=c\)</span> 有解当且仅当 <span
class="math inline">\(\gcd(a,b)\mid
c\)</span>。以下是求解过程的推导：<br />
<span class="math display">\[\begin{aligned}
ax+by&amp;=\gcd(a,b)\\
&amp;=\gcd(b,a\bmod b)\\
&amp;=bx&#39;+(a-b\times \lfloor\frac{a}{b}\rfloor)y&#39;\\
&amp;=ay&#39;+b(x&#39;-\lfloor\frac{a}{b}\rfloor y&#39;)
\end{aligned}\]</span>
像欧几里得算法一样递归求解即可。这个算法叫做扩展欧几里得算法。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,x,y);</span><br><span class="line">    <span class="type">int</span> temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="逆元">逆元</h4>
<p>线性求法：<br />
要求模数 <span class="math inline">\(p\)</span>
为<strong>质数</strong>。显然在 <span class="math inline">\(i=1\)</span>
时 <span class="math inline">\(i^{-1}=1\)</span>，考虑 <span
class="math inline">\(i&gt;1\)</span> 的情况。设 <span
class="math inline">\(k=\lfloor\dfrac{p}{i}\rfloor,j=p\bmod
i\)</span>，则 <span class="math inline">\(p=ki+j\)</span>。则 <span
class="math inline">\(ki+j\equiv 0 \pmod p\)</span>，两边同时乘 <span
class="math inline">\(i^{-1}j^{-1}\)</span>，得 <span
class="math inline">\(kj^{-1}+i^{-1}\equiv 0\pmod p\)</span>，移项并回代
<span class="math inline">\(k,j\)</span>，得 <span
class="math inline">\(i^{-1}\equiv
-\lfloor\dfrac{p}{i}\rfloor\times(p\bmod i)^{-1} \pmod p\)</span>
实际操作中为了避免负数，可以将 <span
class="math inline">\(-\lfloor\dfrac{p}{i}\rfloor\)</span> 替换为 <span
class="math inline">\(p-\lfloor\dfrac{p}{i}\rfloor\)</span>。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    inv[i]=(<span class="type">long</span> <span class="type">long</span>)(p-p/i)*inv[p%i]%p;</span><br></pre></td></tr></table></figure> 不过一般都直接用费马小定理快速幂求出。</p>
<h4 id="欧拉函数">欧拉函数</h4>
<p>定义欧拉函数 <span class="math inline">\(\varphi(n)\)</span> 为 <span
class="math inline">\(1\sim n\)</span> 中与 <span
class="math inline">\(n\)</span> 互素的数的个数。<br />
<span class="math display">\[\varphi(n)=n\prod
\frac{p_i-1}{p_i}\]</span> 证明：容斥，但我不会。<br />
欧拉定理：<br />
若 <span class="math inline">\(a,m\)</span> <strong>互质</strong>，则
<span class="math inline">\(a^{\varphi(m)}\equiv 1\pmod
m\)</span>。<br />
扩展欧拉定理： <span class="math display">\[a^b\equiv
\begin{cases}a^{b\bmod \varphi(m)},&amp;\gcd(a,m)=1,\\
a^b,&amp;\gcd(a,m)\ne 1,b&lt;\varphi(m),\\
a^{(b\bmod\varphi(m))+\varphi(m)},&amp;\gcd(a,m)\ne 1,b\ge\varphi(m).
\end{cases}
\pmod m
\]</span> 都不会证。</p>
<h3 id="线性同余方程组">线性同余方程组</h3>
<h4 id="扩展中国剩余定理">扩展中国剩余定理</h4>
<p>又称 exCRT。<br />
给定同余方程组<br />
<span class="math display">\[\begin{cases}
x\equiv a_1\pmod {m_1},\\
x\equiv a_2\pmod {m_2},\\
\cdots\\
x\equiv a_n\pmod {m_n}.
\end{cases}\]</span> 在模数<strong>不保证</strong>互质的情况下求解 <span
class="math inline">\(x\)</span>。<br />
原理：exCRT 的本质是合并线性同余方程。<br />
定理：若方程组有解，则解在模 <span
class="math inline">\(\operatorname{lcm}(m_1,m_2,\cdots,m_n)\)</span>
意义下唯一，否则无解。<br />
求解过程：<br />
考虑 <span class="math inline">\(2\)</span> 个同余方程的情况： <span
class="math display">\[\begin{cases}
x\equiv a_1\pmod {m_1},\\
x\equiv a_2\pmod {m_2}.
\end{cases}\]</span> 设 <span
class="math inline">\(x=k_1m_1+a_1=k_2m_2+a_2\)</span>，则 <span
class="math inline">\(k_1m_1-k_2m_2=a_2-a_1\)</span>。注意：根据裴蜀定理，当且仅当
<span class="math inline">\(\gcd(m_1,m_2)\mid (a_2-a_1)\)</span>
时此方程有解。设 <span
class="math inline">\(d=\gcd(m_1,m_2)\)</span>，原式写为 <span
class="math inline">\(\dfrac{m_1}{d}k_1-\dfrac{m_2}{d}k_2=\dfrac{a_2-a_1}{d}\)</span>，设
<span
class="math inline">\(m_1&#39;=\dfrac{m_1}{d},m_2&#39;=\dfrac{m_2}{d},c=\dfrac{a_2-a_1}{d}\)</span>，则方程变为：<br />
<span class="math display">\[m_1&#39;k_1+m_2&#39;k_2=c\]</span> 因为
<span
class="math inline">\(\gcd(m_1&#39;,m_2&#39;)=1\)</span>，所以可以直接用扩展欧几里得算法求出
<span class="math inline">\(k_1\)</span> 的一个特解 <span
class="math inline">\(k_1^*\)</span>。<span
class="math inline">\(k_1\)</span> 的通解为 <span
class="math inline">\(k_1=k_1^*+t\times m_2&#39;\)</span>，代回，得到
<span class="math inline">\(x\)</span> 的通解为<br />
<span class="math display">\[\begin{aligned}
x&amp;=k_1m_1+a_1\\
&amp;=(k_1^*+t\times m_2&#39;)m_1+a_1\\
&amp;=m_1k_1^*+a_1+t\times m_1m_2&#39;
\end{aligned}\]</span> 注意到 <span
class="math inline">\(m_1m_2&#39;=\dfrac{m_1m_2}{d}=\operatorname{lcm}(m_1,m_2)\)</span>，所以有<br />
<span class="math display">\[x\equiv
m_1k_1^*+a_1\pmod{\operatorname{lcm}(m_1,m_2)}\]</span>
至此，我们成功合并了两个方程。<br />
对于 <span class="math inline">\(n\)</span>
个方程的合并，只需重复以上步骤，一直合并到只剩一个方程 <span
class="math inline">\(x\equiv A\pmod M\)</span>，其中 <span
class="math inline">\(M=\operatorname{lcm}(m_1,m_2,\cdots,m_n)\)</span>。时间复杂度
<span class="math inline">\(O(n\log M)\)</span>。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exCRT</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1=a[<span class="number">1</span>],m1=m[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a2=a[i],m2=m[i];</span><br><span class="line">        <span class="type">int</span> k1,k2;</span><br><span class="line">        <span class="type">int</span> d=<span class="built_in">exgcd</span>(m1,m2,k1,k2);</span><br><span class="line">        <span class="keyword">if</span>((a2-a1)%d!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        k1*=(a2-a1)/d;</span><br><span class="line">        <span class="type">int</span> t=m2/d;</span><br><span class="line">        k1=(k1%t+t)%t;</span><br><span class="line">        a1+=k1*m1;</span><br><span class="line">        m1=m1/d*m2;</span><br><span class="line">        a1=(a1%m1+m1)%m1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他">其他</h3>
<p>附表：<br />
<img
src="https://github.com/headless-piston/blog_images/blob/main/prime.jpg?raw=true" /></p>
<p>参考资料：<br />
https://oi-wiki.org/math/ https://www.cnblogs.com/Tmbcan/p/18903233</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>双语歌词修复器</title>
    <url>/2025/07/14/%E5%8F%8C%E8%AF%AD%E6%AD%8C%E8%AF%8D%E4%BF%AE%E5%A4%8D%E5%99%A8/</url>
    <content><![CDATA[<p>lyh 大爷给的音乐网站相当好用，但是上面的歌词下载下来全 tm
有问题啊。这严重影响了开摆的体验……</p>
<h3 id="前置知识">前置知识</h3>
<h4 id="lrc-文件">lrc 文件</h4>
<p>歌词文件的扩展名一般为 <code>.lrc</code>，电脑中的 music player 如
PotPlayer 在播放某音乐时会自动在与音乐文件相同的路径下查找同名 lrc
文件。如果查到，就会在播放音乐时同步渲染出歌词。<br />
你可以直接用记事本打开 lrc
文件，然后就会发现里面的内容大约为这个格式：<br />
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[11:45.14]Wha↗t↘ can I↗↘say~</span><br><span class="line">[19:19.81]Man↗ba↗ o↗ut~</span><br></pre></td></tr></table></figure> <code>[]</code>
内的东西叫做时间戳，表示应该啥时候渲染出这一句歌词。而如果是中英双语的歌词，大概是这样的：<br />
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[11:45.14]Wha↗t↘ can I↗↘say~</span><br><span class="line">[11:45.14]我能说什么</span><br><span class="line">[19:19.81]Man↗ba↗ o↗ut~</span><br><span class="line">[19:19.81]曼巴出来</span><br></pre></td></tr></table></figure> 对应的中文翻译的时间戳应当与英文的一样。</p>
<h4 id="中文的编码方式">中文的编码方式</h4>
<p>我们知道英文可以用 ASCII 码，每个字符 <span
class="math inline">\(1\)</span> 字节，然而中文的编码一般是每个字占
<span class="math inline">\(2\)</span>
字节甚至更多，正常程序中对中文字符串的某位进行处理可能导致表示同一个字的多字节中的其中一个改变，而其他的没变，最终变为乱码。</p>
<h3 id="问题分析">问题分析</h3>
<p>我们发现，从网站上下载下来的歌词文件长这样：</p>
<details>
<summary>
Take Me Hand-DAISHI DANCE&amp;Cécile Corbel.lrc
</summary>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[00:00.0]Take Me Hands - DAISHI DANCE/</span><br><span class="line">[00:23.83] </span><br><span class="line">[00:23.83]Lyrics by：Cecile Corbel</span><br><span class="line">[00:36.89] </span><br><span class="line">[00:36.89]Composed by：DAISHI DANCE/Tomoharu Moriya</span><br><span class="line">[00:59.59] </span><br><span class="line">[00:59.59]In my dreams</span><br><span class="line">[01:01.49]在我的梦里</span><br><span class="line">[01:01.49]I feel your light</span><br><span class="line">[01:03.38]我感受到了你的光芒</span><br><span class="line">[01:03.38]I feel love is born again</span><br><span class="line">[01:07.01]我感受到了爱的重生</span><br><span class="line">[01:07.01]Fireflies</span><br><span class="line">[01:09.020004]萤火虫</span><br><span class="line">[01:09.020004]In the moonlight</span><br><span class="line">[01:10.84]在月光下</span><br><span class="line">[01:10.84]Rising stars</span><br><span class="line">[01:14.479996]随着星星闪耀</span><br><span class="line">[01:14.479996]Remember</span><br><span class="line">[01:16.979996]记住</span><br><span class="line">[01:16.979996]The day</span><br><span class="line">[01:19.11]这个日子</span><br><span class="line">[01:19.11]I fell in love with you</span><br><span class="line">[01:22.03]我与你相爱</span><br><span class="line">[01:22.03]Darling won&#x27;t you break</span><br><span class="line">[01:26.12]亲爱的 你不会</span><br><span class="line">[01:26.12]My heart</span><br><span class="line">[01:29.979996]让我心碎</span><br><span class="line">[01:29.979996]Take my hand now</span><br><span class="line">[01:31.75]牵着我的手</span><br><span class="line">[01:31.75]Stay close to me</span><br><span class="line">[01:33.81]贴近我的心</span><br><span class="line">[01:33.81]Be my lover</span><br><span class="line">[01:35.68]做我的爱人</span><br><span class="line">[01:35.68]Won&#x27;t you let me go</span><br><span class="line">[01:37.53]你不会让我离开</span><br><span class="line">[01:37.53]Close your eyes now</span><br><span class="line">[01:39.5]现在 闭上你的双眼</span><br><span class="line">[01:39.5]And you will see</span><br><span class="line">[01:41.34]你将会看到</span><br><span class="line">[01:41.34]There&#x27;s a rainbow</span><br><span class="line">[01:43.21]有一道彩虹</span><br><span class="line">[01:43.21]For you and me</span><br><span class="line">[01:59.64]专属你我</span><br><span class="line">[01:59.64]As I wake up</span><br><span class="line">[02:01.58]当我醒来</span><br><span class="line">[02:01.58]I see your face</span><br><span class="line">[02:03.49]看着你的脸庞</span><br><span class="line">[02:03.49]I feel love is born again</span><br><span class="line">[02:07.02]我感受到了爱的重生</span><br><span class="line">[02:07.02]Cherry blossom</span><br><span class="line">[02:08.9]樱花烂漫</span><br><span class="line">[02:08.9]Flying birds</span><br><span class="line">[02:10.84]鸟儿飞翔</span><br><span class="line">[02:10.84]In the sky</span><br><span class="line">[02:14.64]在天空里</span><br><span class="line">[02:14.64]Can&#x27;t you see</span><br><span class="line">[02:16.85]你是否看得见</span><br><span class="line">[02:16.85]The sun</span><br><span class="line">[02:18.34]阳光</span><br><span class="line">[02:18.34]That is shining on the fields</span><br><span class="line">[02:22.12]照射着大地</span><br><span class="line">[02:22.12]Is it shining in</span><br><span class="line">[02:26.33]它是否照射进</span><br><span class="line">[02:26.33]Your heart</span><br><span class="line">[02:29.99]你的心里</span><br><span class="line">[02:29.99]Take my hand now</span><br><span class="line">[02:31.75]牵着我的手</span><br><span class="line">[02:31.75]Stay close to me</span><br><span class="line">[02:33.81]贴近我的心</span><br><span class="line">[02:33.81]Be my lover</span><br><span class="line">[02:35.68]做我的爱人</span><br><span class="line">[02:35.68]Won&#x27;t you let me go</span><br><span class="line">[02:37.54001]你不会让我离开</span><br><span class="line">[02:37.54001]Close your eyes now</span><br><span class="line">[02:39.52]现在 闭上你的双眼</span><br><span class="line">[02:39.52]And you will see</span><br><span class="line">[02:41.33]你将会看到</span><br><span class="line">[02:41.33]There&#x27;s a rainbow</span><br><span class="line">[02:43.20999]有一道彩虹</span><br><span class="line">[02:43.20999]For you and me</span><br><span class="line">[02:59.65]专属你我</span><br><span class="line">[02:59.65]And I dream of you</span><br><span class="line">[03:03.36]我都梦见你</span><br><span class="line">[03:03.36]Every night</span><br><span class="line">[03:06.95]在每一个夜晚</span><br><span class="line">[03:06.95]Cause&#x27;s there only you</span><br><span class="line">[03:10.9]因为 是否只有你</span><br><span class="line">[03:10.9]In my mind</span><br><span class="line">[03:14.49]在我的心里</span><br><span class="line">[03:14.49]Will you be</span><br><span class="line">[03:16.99]你会是</span><br><span class="line">[03:16.99]A stranger or a friend in my life</span><br><span class="line">[03:22.13]我生命中的陌生人 还是一个朋友</span><br><span class="line">[03:22.13]Darling won&#x27;t you break</span><br><span class="line">[03:25.9]亲爱的 你不会</span><br><span class="line">[03:25.9]My heart</span><br><span class="line">[03:29.99]让我心碎</span><br><span class="line">[03:29.99]Take my hand now</span><br><span class="line">[03:31.75]牵着我的手</span><br><span class="line">[03:31.75]Stay close to me</span><br><span class="line">[03:33.83]贴近我的心</span><br><span class="line">[03:33.83]Be my lover</span><br><span class="line">[03:35.67]做我的爱人</span><br><span class="line">[03:35.67]Won&#x27;t you let me go</span><br><span class="line">[03:37.52]你不会让我离开</span><br><span class="line">[03:37.52]Close your eyes now</span><br><span class="line">[03:39.47]现在 闭上你的双眼</span><br><span class="line">[03:39.47]And you will see</span><br><span class="line">[03:41.33]你将会看到</span><br><span class="line">[03:41.33]There&#x27;s a rainbow</span><br><span class="line">[03:43.2]有一道彩虹</span><br><span class="line">[03:43.2]For you and me</span><br><span class="line">[03:45.0]专属你我</span><br><span class="line">[03:45.0]Take my hand now</span><br><span class="line">[03:46.75]牵着我的手</span><br><span class="line">[03:46.75]Stay close to me</span><br><span class="line">[03:48.8]贴近我的心</span><br><span class="line">[03:48.8]Be my lover</span><br><span class="line">[03:50.67]做我的爱人</span><br><span class="line">[03:50.67]Won&#x27;t you let me go</span><br><span class="line">[03:52.52]你不会让我离开</span><br><span class="line">[03:52.52]Close your eyes now</span><br><span class="line">[03:54.51]现在 闭上你的双眼</span><br><span class="line">[03:54.51]And you will see</span><br><span class="line">[03:56.33]你将会看到</span><br><span class="line">[03:56.33]There&#x27;s a rainbow</span><br><span class="line">[03:58.19]有一道彩虹</span><br><span class="line">[03:58.19]For you and me</span><br><span class="line">[03:59.7]专属你我</span><br><span class="line">[03:59.7]Darling take my hand now</span><br><span class="line">[04:02.3]牵着我的手</span><br><span class="line">[04:02.3]Stay close to me</span><br><span class="line">[04:03.86]贴近我的心</span><br><span class="line">[04:03.86]Be my lover</span><br><span class="line">[04:05.93]做我的爱人</span><br><span class="line">[04:05.93]Won&#x27;t you let me go</span><br><span class="line">[04:07.35]不要放开我的手</span><br><span class="line">[04:07.35]Close your eyes now</span><br><span class="line">[04:08.76]现在 闭上你的双眼</span><br><span class="line">[04:08.76]And you will see</span><br><span class="line">[04:11.34]你将会看到</span><br><span class="line">[04:11.34]There&#x27;s a rainbow</span><br><span class="line">[04:13.19]有一道彩虹</span><br><span class="line">[04:13.19]For you and me</span><br><span class="line">[04:13.21]专属你我</span><br></pre></td></tr></table></figure>
</details>
<p>问题主要有两个：</p>
<ol type="1">
<li><p>全错位了，除了第一行，其他每行都应使用上一行的时间戳</p></li>
<li><p>有的时间戳长的吓人，这样的时间戳会导致渲染错误。经我实测，删掉后面多余的部分对渲染没有影响，所以我们直接丢弃超出正常长度的部分就行。</p></li>
</ol>
<p>所以我们编写程序对这种格式错误进行修复。<br />
为了解决中文乱码问题，我们使用 <code>fstream</code> 而不是传统的 I/O
方式。</p>
<h3 id="code">code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> f=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;.lrc&quot;</span>,ios::binary)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;fixed.lrc&quot;</span>,ios::binary)</span></span>;</span><br><span class="line">    out&lt;&lt;<span class="built_in">char</span>(<span class="number">0xEF</span>)&lt;&lt;<span class="built_in">char</span>(<span class="number">0xBB</span>)&lt;&lt;<span class="built_in">char</span>(<span class="number">0xBF</span>);<span class="comment">//防中文乱码</span></span><br><span class="line">    string line,last_time;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in,line))&#123;</span><br><span class="line">        <span class="keyword">if</span>(line.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            out&lt;&lt;last_time&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it=--line.<span class="built_in">end</span>();</span><br><span class="line">        <span class="keyword">while</span>(it!=line.<span class="built_in">begin</span>()&amp;&amp;*it==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            line.<span class="built_in">erase</span>(it--);<span class="comment">//去除行末空格</span></span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(line[pos]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(line[pos++]);</span><br><span class="line">            <span class="keyword">while</span>(pos&lt;(<span class="type">int</span>)line.<span class="built_in">length</span>()&amp;&amp;line[pos]!=<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                s.<span class="built_in">push_back</span>(line[pos++]);</span><br><span class="line">            <span class="keyword">if</span>(pos&lt;(<span class="type">int</span>)line.<span class="built_in">length</span>())</span><br><span class="line">                s.<span class="built_in">push_back</span>(line[pos++]);</span><br><span class="line">        &#125;<span class="comment">//截取时间戳</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()&gt;<span class="number">9</span>)</span><br><span class="line">            s.<span class="built_in">erase</span>(<span class="number">9</span>),s.<span class="built_in">push_back</span>(<span class="string">&#x27;]&#x27;</span>);<span class="comment">//限制时间戳长度</span></span><br><span class="line">        string content;</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;(<span class="type">int</span>)line.<span class="built_in">length</span>())</span><br><span class="line">            content.<span class="built_in">push_back</span>(line[pos++]);</span><br><span class="line">        <span class="keyword">if</span>(f)&#123;<span class="comment">//第一行</span></span><br><span class="line">            out&lt;&lt;<span class="string">&quot;[00:00.0]&quot;</span>&lt;&lt;content&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            f=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!last_time.<span class="built_in">empty</span>()||!content.<span class="built_in">empty</span>())</span><br><span class="line">            out&lt;&lt;last_time&lt;&lt;content&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        last_time=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用流程">使用流程</h3>
<p>创建 cpp 文件 <code>lrc_fix_tool.cpp</code>
并编译，将待修复歌词的文件名改为
<code>.lrc</code>（这个时候顺便复制原歌词文件名），与
<code>lrc_fix_tool.exe</code>
放在同一路径，运行程序，在相同路径下生成修复好的
<code>fixed.lrc</code>，这时再重命名回去就好啦。<br />
经实测，刚才的问题歌词修改后为：</p>
<details>
<summary>
Take Me Hand-DAISHI DANCE&amp;Cécile Corbel.lrc
</summary>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[00:00.0]Take Me Hands - DAISHI DANCE/</span><br><span class="line">[00:00.0]</span><br><span class="line">[00:23.83]Lyrics by：Cecile Corbel</span><br><span class="line">[00:23.83]</span><br><span class="line">[00:36.89]Composed by：DAISHI DANCE/Tomoharu Moriya</span><br><span class="line">[00:36.89]</span><br><span class="line">[00:59.59]In my dreams</span><br><span class="line">[00:59.59]在我的梦里</span><br><span class="line">[01:01.49]I feel your light</span><br><span class="line">[01:01.49]我感受到了你的光芒</span><br><span class="line">[01:03.38]I feel love is born again</span><br><span class="line">[01:03.38]我感受到了爱的重生</span><br><span class="line">[01:07.01]Fireflies</span><br><span class="line">[01:07.01]萤火虫</span><br><span class="line">[01:09.02]In the moonlight</span><br><span class="line">[01:09.02]在月光下</span><br><span class="line">[01:10.84]Rising stars</span><br><span class="line">[01:10.84]随着星星闪耀</span><br><span class="line">[01:14.47]Remember</span><br><span class="line">[01:14.47]记住</span><br><span class="line">[01:16.97]The day</span><br><span class="line">[01:16.97]这个日子</span><br><span class="line">[01:19.11]I fell in love with you</span><br><span class="line">[01:19.11]我与你相爱</span><br><span class="line">[01:22.03]Darling won&#x27;t you break</span><br><span class="line">[01:22.03]亲爱的 你不会</span><br><span class="line">[01:26.12]My heart</span><br><span class="line">[01:26.12]让我心碎</span><br><span class="line">[01:29.97]Take my hand now</span><br><span class="line">[01:29.97]牵着我的手</span><br><span class="line">[01:31.75]Stay close to me</span><br><span class="line">[01:31.75]贴近我的心</span><br><span class="line">[01:33.81]Be my lover</span><br><span class="line">[01:33.81]做我的爱人</span><br><span class="line">[01:35.68]Won&#x27;t you let me go</span><br><span class="line">[01:35.68]你不会让我离开</span><br><span class="line">[01:37.53]Close your eyes now</span><br><span class="line">[01:37.53]现在 闭上你的双眼</span><br><span class="line">[01:39.5]And you will see</span><br><span class="line">[01:39.5]你将会看到</span><br><span class="line">[01:41.34]There&#x27;s a rainbow</span><br><span class="line">[01:41.34]有一道彩虹</span><br><span class="line">[01:43.21]For you and me</span><br><span class="line">[01:43.21]专属你我</span><br><span class="line">[01:59.64]As I wake up</span><br><span class="line">[01:59.64]当我醒来</span><br><span class="line">[02:01.58]I see your face</span><br><span class="line">[02:01.58]看着你的脸庞</span><br><span class="line">[02:03.49]I feel love is born again</span><br><span class="line">[02:03.49]我感受到了爱的重生</span><br><span class="line">[02:07.02]Cherry blossom</span><br><span class="line">[02:07.02]樱花烂漫</span><br><span class="line">[02:08.9]Flying birds</span><br><span class="line">[02:08.9]鸟儿飞翔</span><br><span class="line">[02:10.84]In the sky</span><br><span class="line">[02:10.84]在天空里</span><br><span class="line">[02:14.64]Can&#x27;t you see</span><br><span class="line">[02:14.64]你是否看得见</span><br><span class="line">[02:16.85]The sun</span><br><span class="line">[02:16.85]阳光</span><br><span class="line">[02:18.34]That is shining on the fields</span><br><span class="line">[02:18.34]照射着大地</span><br><span class="line">[02:22.12]Is it shining in</span><br><span class="line">[02:22.12]它是否照射进</span><br><span class="line">[02:26.33]Your heart</span><br><span class="line">[02:26.33]你的心里</span><br><span class="line">[02:29.99]Take my hand now</span><br><span class="line">[02:29.99]牵着我的手</span><br><span class="line">[02:31.75]Stay close to me</span><br><span class="line">[02:31.75]贴近我的心</span><br><span class="line">[02:33.81]Be my lover</span><br><span class="line">[02:33.81]做我的爱人</span><br><span class="line">[02:35.68]Won&#x27;t you let me go</span><br><span class="line">[02:35.68]你不会让我离开</span><br><span class="line">[02:37.54]Close your eyes now</span><br><span class="line">[02:37.54]现在 闭上你的双眼</span><br><span class="line">[02:39.52]And you will see</span><br><span class="line">[02:39.52]你将会看到</span><br><span class="line">[02:41.33]There&#x27;s a rainbow</span><br><span class="line">[02:41.33]有一道彩虹</span><br><span class="line">[02:43.20]For you and me</span><br><span class="line">[02:43.20]专属你我</span><br><span class="line">[02:59.65]And I dream of you</span><br><span class="line">[02:59.65]我都梦见你</span><br><span class="line">[03:03.36]Every night</span><br><span class="line">[03:03.36]在每一个夜晚</span><br><span class="line">[03:06.95]Cause&#x27;s there only you</span><br><span class="line">[03:06.95]因为 是否只有你</span><br><span class="line">[03:10.9]In my mind</span><br><span class="line">[03:10.9]在我的心里</span><br><span class="line">[03:14.49]Will you be</span><br><span class="line">[03:14.49]你会是</span><br><span class="line">[03:16.99]A stranger or a friend in my life</span><br><span class="line">[03:16.99]我生命中的陌生人 还是一个朋友</span><br><span class="line">[03:22.13]Darling won&#x27;t you break</span><br><span class="line">[03:22.13]亲爱的 你不会</span><br><span class="line">[03:25.9]My heart</span><br><span class="line">[03:25.9]让我心碎</span><br><span class="line">[03:29.99]Take my hand now</span><br><span class="line">[03:29.99]牵着我的手</span><br><span class="line">[03:31.75]Stay close to me</span><br><span class="line">[03:31.75]贴近我的心</span><br><span class="line">[03:33.83]Be my lover</span><br><span class="line">[03:33.83]做我的爱人</span><br><span class="line">[03:35.67]Won&#x27;t you let me go</span><br><span class="line">[03:35.67]你不会让我离开</span><br><span class="line">[03:37.52]Close your eyes now</span><br><span class="line">[03:37.52]现在 闭上你的双眼</span><br><span class="line">[03:39.47]And you will see</span><br><span class="line">[03:39.47]你将会看到</span><br><span class="line">[03:41.33]There&#x27;s a rainbow</span><br><span class="line">[03:41.33]有一道彩虹</span><br><span class="line">[03:43.2]For you and me</span><br><span class="line">[03:43.2]专属你我</span><br><span class="line">[03:45.0]Take my hand now</span><br><span class="line">[03:45.0]牵着我的手</span><br><span class="line">[03:46.75]Stay close to me</span><br><span class="line">[03:46.75]贴近我的心</span><br><span class="line">[03:48.8]Be my lover</span><br><span class="line">[03:48.8]做我的爱人</span><br><span class="line">[03:50.67]Won&#x27;t you let me go</span><br><span class="line">[03:50.67]你不会让我离开</span><br><span class="line">[03:52.52]Close your eyes now</span><br><span class="line">[03:52.52]现在 闭上你的双眼</span><br><span class="line">[03:54.51]And you will see</span><br><span class="line">[03:54.51]你将会看到</span><br><span class="line">[03:56.33]There&#x27;s a rainbow</span><br><span class="line">[03:56.33]有一道彩虹</span><br><span class="line">[03:58.19]For you and me</span><br><span class="line">[03:58.19]专属你我</span><br><span class="line">[03:59.7]Darling take my hand now</span><br><span class="line">[03:59.7]牵着我的手</span><br><span class="line">[04:02.3]Stay close to me</span><br><span class="line">[04:02.3]贴近我的心</span><br><span class="line">[04:03.86]Be my lover</span><br><span class="line">[04:03.86]做我的爱人</span><br><span class="line">[04:05.93]Won&#x27;t you let me go</span><br><span class="line">[04:05.93]不要放开我的手</span><br><span class="line">[04:07.35]Close your eyes now</span><br><span class="line">[04:07.35]现在 闭上你的双眼</span><br><span class="line">[04:08.76]And you will see</span><br><span class="line">[04:08.76]你将会看到</span><br><span class="line">[04:11.34]There&#x27;s a rainbow</span><br><span class="line">[04:11.34]有一道彩虹</span><br><span class="line">[04:13.19]For you and me</span><br><span class="line">[04:13.19]专属你我</span><br></pre></td></tr></table></figure>
</details>
<p>打开 PotPlayer 播放，歌词正确渲染，问题解决。<br />
如果是只有一种语言的歌词修个时间戳长度就好了。</p>
<h3 id="其他">其他</h3>
<p>感谢 <a
href="https://www.luogu.com.cn/user/1389641"><em>Kenba</em></a>
提供“前置知识”部分的歌词。</p>
]]></content>
      <tags>
        <tag>鲜花</tag>
      </tags>
  </entry>
  <entry>
    <title>基础对拍详解</title>
    <url>/2025/07/04/%E5%9F%BA%E7%A1%80%E5%AF%B9%E6%8B%8D%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="这个密码看着不太对。" data-whm="这个文章不能被校验。">
  <script id="hbeData" type="hbeData" data-hmacdigest="39b8e6f6c161febdd4617bfd5b2a0159aad098c3ec2114eba83fa36d3b31d857">8ade9e8308e767f1a274156f57751d9a3f5b26898da3a0bd68eb817414d883a0206042b26542125b70bdcc523644cad4e9a4ea799731395b0a77003ce61b73b5966381b8634277c91cfee6abff129ac21ff3b747020d6da2788e1a315de81770e4341437408d7d0c8eec9ba2246e2922098b2712219e936c477329faeef741ecf3cf89c9d74226c3cbcf4c9bb79dbb349f9202738c2b4985eebf8c03434dcb5ed61d4ea4c1c0a55036b549b8d214982b99be4a2f26d0358b4e56ca3a765d792db909cd76e714a1893e9b315ec2f5f87523aab12f9e6145a1adec06b6b3a72f512dc34a058d728c3cbf81afd35a4ca8f2ad2b909d93bd464477e56b7d4c1daaded21771b2b5afa02f080d13dc80b64eba9ee9362ceddc863ecb7daa3f93fb7960c7952a372f703dedcf826eb07d12c3465f691555aeb86db7855215c026ae5dbb4c32a21bb956bd2a1445ca75bf01bf5fe7154db779bc71e77ad8118b013417fbe4482ebef6da74d7e22113eafd86694f550316e0848acaed6af1aae0f7e319794e62afa39392d3914de1e53b80914d64296930e80a581e17b620b544787871e2414f35f0ae1f44613ec0fc99094b1d8b5dbcd173a67a8aef4b3f06b6f9deaec0aeb0b28241491b0a8344568d042a57f668225556dacf073f31cc6b6afede00c04b67477a4b74bb5968f5eb178813276a1b57c59127e09c8366f5fe55b3058e0557b2d682ff7f8631314a6bc22a3d21eb023213267e9b57804b772eba9062d111d7d42cabaf312bfc58ec23084bae7f609ad966197422ef79d1861cc4d5401312d75f52df026e79d6cc7ba4e0f5b46d7008bf08ef20600087dc6fd9c21ed8baa74a78d6be5e8a4c6c8485da89fbcf1084e844d49373b27d0ee5874948ddf9204d8596d8ec4963c4f7e764e0aa218e6b4b4707d946bd82f4066f8eeffd70d40d03f34ce503bbd9a51dfbae923a0b28e47d869edc46cb251e6d0b7533321bd840146a5fa53107f87b5b6a0925b9a1d51d2faa901988827e39befa31e893a7a1509a8058f7429aa67194d0d945236850ca6f5bbe796961be1bd1f768c4a2b0a405a05565552a8f6a082cc0a0ad6ee42bcbe8023652426d93a68475bf33e062b5e181d5c0671a3424c25e5cde9b408dda4cadf9bc8586a1434ffbc178eb5801a6c66e75112b3576df24c16403eacba2f481288840989cf4f546eeebdc88e09d67be023f8cef2f7e35ea249e062ec71fa04b733a68bbf5f181cb07ba735ef805e048251aaf545105e2d5760335300057047541f485d19fef7d861e67b7fd07d6e710a9d11638fd365e1d716507e828b68a81aa8ea52777d123d9e61830ccd9f74bed2e8e04926d18d6c80120c82a1d5011ea42bc5b730d4ef8be3cacd16514739ada21de48608dd7eaca8805246396c0e35143ce989b9a5945b7cdb3825bc7e458e48251250d70b706649fbebdec2ee09f4bd44f50fb453367586e40cae2b4d3366aed631141dd0be2aa0e9a58fa75bdf4c67db62f9d59e6bd9106073c02054695c74c9e84065a4f1363012bf15e578ac04f799b0830875cb1448e64c3bdb6f1fa8863766e88209f9ae2d269b3e55da35fc21ebbacdf748060b76aac8595404e7ada5cba5c08b0c15870e2c32b23292bd5d44c30956ee5387a0961f869c22a546e9a6c4c504600f3bcc7c5f0d9c49a90959080b915b5fd7741a441451d0fdce91bcc58eb471d9403cc2852c54908fd61164dbb938f0408863db7a32eb0ee3cad021a78e85ba11c499efbd0d4820ac2cc429486be3346f6d9f3076e2ce03de1b0a48ebd02e9177a1a1e6f28f6990dc47cdafce20badd08ce8d727ad7d9c09c098512d18c23a14bd3b4bacaa6915a6cc981a2eb1fca0f57a9836a53c644e9bb63a094c605c609f28c02ea7592c201a30d9c213174d5a88652356ff6183c73c99af1f1de0410a8b95f4f77118d859803296f273d8eff35e96b5597b3e9f5d50975cc84f2b99e4df1b958504e5057b11a9de627119a8233727f648884a1953a9a9b4b6cba28df8408a867d2ea61fcab1ef84f664deea888142fbcf4455e01bb9cf227f29af5b7c85ee339e13bd081a5016c6277c7b5ac99f0862c618e21d0785d1fe645bf7fa62f3a43bbff021c743471e12ac9ededc806f3c9aa49cf1964e958acab037f40b9f583ffa7a02f907e32bbaeb97b792254a1a68fe628255ba08a4e590ab61a74e16357097d278f1dd139860792b3be56f504aaad4ccc94be34b6def08ece0b51b9d3ee5808355dc14d415f01650a63234500f2e8e7a0566760b5eebcc59e2409f2de31381062564fddbec1ee26c3493cd699ec82c11f1e493c29fa8af389b01a765e3e6d78a6e4901da6faf372acdba5e0a440f6d43020bf3a8337c572b7026a13f0c9e2091644f978407ad12e07b0cfd71df30acbadceff3b3bbdd07d3c3d06af469882a0a7a908f18e998e036c926904bc6b281aca7dae6f02c7f015a836088c5fe16c6b23e60f7b354ca3550c9f6ff4bda4dc0d57673c60612284076c171044ce6c729d3915184b585993e96957c28bec118afc806a6eb8d9dbe9072a288a84c8e195764de61fd41d5cd73408850a3fe16005c9e9baab35309c70ae2f53804619fb1e02249ce161580db626585d0eb09417961994cf68cb7bed64f69c196a1fb15bef7e74636d65a5781a2cba0b4573e9edbec42c85603b25a73e709eaf6370882fb8159fc0ee578be3df620ac91e5324e6478d789ad14492eace7924b1dab7a79534d7d8b2120f652949c5a0f8306d1ce24cb92c7eee7c8ddff63938a0ec0f07efcb32b6e0cdeb77484713e2419c5749515f9789c64fab9e0ff8aca8b840a6ac1eac3b35f3096fc9d958b30fe8fdc6da98e5453e622828c89453aa323b0fe68e4df39e5078b4971a31a68182c73288860855f4aff3def60a097e107d1a5fc560b65e6625a4f5ebae75acddd0db338ce9587dda15bd14649dfaae8576e91ed11e233e932431f844595636dd61fbe1026dc36e63e4e34723124414b10f6cd5b3b9df9b1a9cb871510ef367a65570132edc18e58100b6953038891489fe3d5299fa9741cf957059da74e5bd5e26db238b5426f14e4e4e80d9595400345b4747aca1b7619fd2a74b6d6cc2cb9e37e1a025e42b4c0301fe930a4c9cd91428af4457d0325bd4a2020293887f00d41f72699d18f06310232b8f40f8ea77e8d102d630084b752001dd665af5e1bc2fe772aedf1f8781e970e877c9dd1096edf17a25a9b4fe5f5c18505b569400feba4429e7305d5037836c205851df9942347bddd606ad0a2d7c2af0a07ec8a6b05140815dda959298b9cfb7daa62f752ad8aab52841f1520effd911e2821c8f84b81bb5090a34260a7ae0a1fbf089ef59d52a3449ea1baa398b989c3e1eac99cf36371726be30542b505fff1ac0be8f3d162f0664dade762dc11705464ed57bfa0d66f391907d9d34184696d95e414951545faaba26fc4d91ef3f1a94084a8d1366a56c9e2e3e8ffa5e980e4c4075035445883f08f3bcc272e5f5185a262d360236ce8b3212b688f90b383784e49d4193f352ab03942e01641d54461e3670969755c331721d458f8440de8ffbab7d69e4bff9c554184fcc0ab18e7b3bafcad7a8013650b7a0737c34fa215b210a113b068de64fb0e40671f00eda96e2dac8541484f26582b2408f29a7bb758eb5c4ccc84e7feca91142a690ef313ec1fadf9d6769a447bd7d84d2ae28473794cc2fd73274e0790b4fc46dc71c7aeb06f61475be097e3e152920b79f0a677a8180c340efcd021d8a4c1748c9363109d38fee975c192b23dbe8f3f84bac9bc686aeaef4b1995a602a9e06effa65e51cc0af0a0893f33dc58526496c29a7f2649134be2a00d69f4ac966957ef545f277e6ae911e3af09af20ca72b7203f949cf6ac107210639aa36d1091319d31e6e2d0f7b983ed216aef7ac90e812052dd2a30992449f38d3541642ad1f50f64fd1123a098e712cf03ca117275a979d1de85b0307afd5fa6d9ec3769cce6dc3da77154e57c85e867032a7f5d24b35bf96f26a87579daedda7a9b040d4e010e7a65f0b7b5af252892d0cd1b91a623661289803264db42013d204d2052466700767f46eda3d232166bbc3c0536ebf8ada71b24c70aefe07e88068ac92811c2b014ee17262ab876af34d7f3ce7d4914072675ecc7e9095a57def7cb1f52d670bd761ac29515bf8c9625a80218b3dc8e2d9840fd07c455cc62c35b488ddb89e60a029fbcc40c863a3d8830b7b06a1ee14b2b15f9a6d8ee0f67df5a4d08fc7ebaf7d6d81e8bb4075e219a4c672ec24a47a5124edb8ab06ebc8d332ac7537c7466bcb309dd8ed826daedb0a9402e675cad39ed98fc328d63d73c6054284348885c68d532d9cce182167d61278dada8285b7246c32651043c43924f2e97389c4e31145be158d1072418505e1173ff267d1b98fc2c7ff42dde8b6f8e60d60dd40e1a3867a61be41885d61e6d00fa31df2d911ff46420fd67562416cec7520e7808dce0f2ead9a3fd1640ccf07dc87f6f2e03fbec31b2eaa27f64d2a0d461f9c9cb50ee967c7101af855d1935c91d3833f090c7a978d3acdebbfc4ad85aa33385a7f7a91efc58c98558804d4116aff435139b5112a74383e573fd261a75df41ef56e44c3c2387a725f451f8dbbe1e0261c8b52dfaa84af5d6834e26f9c19e9f351ff867b015eefaf69965fc8acfa3c23b1864b4abec5b2b020ed995e00185908e58338eaafaeed0ffdf2c938916bee1b3abaa6f085e7fcd0f4463a6d1c025f28cb4d3ee0786a910cd77d384e7c69c78a55b3a6a2fdff2c0ee203756e53d64854bfa0b9541fa892ac9827a1669d6616f2ea1b626b814203eed1ca3538a695ff135e20f42b2d253f1c8a83d20f71a58431fb225efc66720f757b1ab86748934d5fe4c6bc6387a28988b0853d7e4f97b90dc03070f1703d22be01018ed39ad697108f6d3a0e1ed99b048c9d7add4c71b2337b479e5c59ce9293fc63df44d58d459a60117e95d5ceb04d85eb45f0dd58158c415c64cb346f73c960285a5192d516bf7acfdcf08f7b669d804109eeaf21021d6e052c99a236034caa14b440a2149950f0993bb3a102575737ce77b5e58465a66785b6376b4052ddfe9ec9ee64f4ed047ac03ef9f0210d008938043e052ffc053bac33fc8e5fb913ea1803e3e8038e3aa44d85100c282089a1d9d443ad6e2d0c13d7944ef4b4f9fef3c6127ffb8f9644d8fd683b7fa5c0e6e5f3b447ad98a9069bc5757b8e78222f243d8a0c1b95b0672f7d8224b980eb8afb9affe21b31a3d5765cdd0514aa6182d9c7773e5c649462d4e4be88803432f692254f65829b0c4bee19562e827a6a2f56f1adc1faa75e27e4f67b0f8f1f7bf3be9d5c6a4e02c5f1f59bec06cbb83a788432650b0ec6eb7f74f23ac3d2cddc4fe32e5b0fa8b60a0d4ae2e777d14b9175abdf21ed65b68be1db1549060f22efba347d5fc43122c765140e024841d2596d58a67ba0f3a555cc0ad25181a8ee846bbb3edbedf68841628a0324635f9dd18cf9d8aba9d3579a533b52ffb315e2129a03cad5759af902ceb025e301d249672a11716d43ecac4ff595e82c926bfbdce47dd53ed94b674654ed9c0fd91abe77c074a7638b7e85c046a10458c8e0134c1b31c5b2bb88c4a677c35fcc4397bcbd13ab6ef90a5c7742c2908e5f6fa966b01b876e6c779a1dcee9f3c3e985213b2b346f3bb2f2632c914b2964ac128df6f96ccf338433bf5c7e042f2800bed44bc1c8cd76b09035e2c729d75e1962834e8334ce250fa4ef594f370c4c1c17445e3a8fdc919a8806ad0729540a90fd0cbf5d863ae39b6d581ef08d21fb19b8ef5404c3f8720e323ea3651208357bbc12d74f39146cedbfe4aff1d445f4ef3e8a944a35c88a508a6b3d32f431902fe444ff99ab438d179cad8caae5656d266f86caa3798b526acac142ff4b52d79effb41b40ae0e714f5eb122489aebbc71fc81c8b4a9b4a5340202f4ee56ab7b8ff50f8677cba9eb4aaf33a9398221747adffafeddb9c16025f411265ac59ee46a38efc258f40a0619a5a9b63b363b8d6856441a48fc66787ce52c3f50f6c2c38d8f0a19c1f0b3c3e2d7f2887090fcac50428fae6a3e7b2beb00e8e2eb757fe968d09018977246fcde87872912cc0a124f791b9a1791404a469af4e79c59eace505e58834a1df3efc7ac8d96aaca40c644b8d4db821f71ab9e618c690102530aed327e22cb5c2e437cb1d13dfb72c6b2bfe91de2f043f81bc645c9fa9342b92dc178ba91b1bf124902b3de1e0b307db4dc3fb9ede520d387ef16df98d573e049ba95709c1e7f49570ecb45c38c94a8f854330ee7803c936448afef63049a1858c3c2a8785b62d4bce81afb553f34e4e8da39fab32ce0a4ed9e17a3df2b97edc7ed7b8ae896efaac311e2cc55f77548113c859c69ae8a1e8a8a78f2a203eb28e9018b27cab448685a54399e0c337452104c454b6bc506f996e41e22a9918e15fa17315de143ff48f9d087058b7e44c2d7da9b9a94d0adfe02e457a7e6b02ce7c89c78571cf6a45639c4551960376d89d0aec6b5c69016fae360ace0751036b6894f8c98ae44cd95053063858574a4944745bb6d4f9d58112403228b3a8da2b7b47dfc29c3cf1f5034247a9cc75314a10c2d6fe61b95a5575dce9cb4f3978626e30fe4be301800cb18e8c06c3ad388a378247e48b39f56ebc96909b49eb98c2fa1b475d4ad0b4ada97a4b95706c50d679b3b0ddacbc654ca6c5373f34602de689cb7bfbed0a1a9e00f67e263c142aa6f750687e1729ad3dbfdae5a44c41277a0c8d0188b5d0314bdf9ae2c4a99b124bef013e5343902a9fb741a0bbc19b8798ce55b21b04b4eb7cbed68fa52cbcfe07448ec01ddeda152f7345c8130c6642088764ad74a40dbb62ac26c9b28d0fd88866d9547b75e89a8310b5ca83ea30c257b983647e30614b66c0303af166387c0a1a06e1b1ef6ce5e2ce8bb49ba143a9e9aea74c7b4c1b948d9e589865148e3a1a55077f463623ffe0dff7f6b388cf3d212b9a58249d6740e4831eef7d546477f8f3cbd4d8afe4335397a6e8e745f90bed69e4b1c4427b25860b90f1c73071b7034f36f3817800b7081e3782ea9a6f9f03269b242aefed9a023339ca38f4fc444e4d8a54905256cdd6581bf83220b6eb7aa4c15c8f14a999ec0ecd066fd124f17a05ec9579a56553f545d1fffd21350e4578ad983063153f8bc4221d483e50d2c95d8278281c20d50e4c4226eb947819f79103fb9188222ec8a45996c6d74cf26da345d5e99d4aae1de934d6b410d70d4f2f4168e0b11afd08a6bc48c9a554fb555776dd558f0d03fac89cbcacbface15c2e0749d446ee7d9f77b43c59dc9e67ad468803157bc04ecfb7d2bb426976714ef920f668e685149164bce89b40d7f459bc3ce03ca9794421d995aac0f05e86ffc2b63f6b6c7fc2a33090cb21f7b3ebcee27115dcc818757cb8cc131cd0a9f0ce8ee1f8bc7686b04cb7a29af9898c6859441f1a43670a3445d807c1a523a3e3e3590515e973c436845a61ca4745b472af8cda81ec9c163d8c6cefa5671c347b7991901a7c27a786bd97298192d3d0a60c4fa4bd843add5019df989f53f6cf9ea3b831e7d2945cc68cf8a4336678e05761251dfa157e4536baa615ea189019836dff46121989572ae13bfb5d0aed5431212260ea0195829c0cc46ca25dfd9ecf32c619f4b159d9a1f3fef0280361fbe47b1ffe2fcdcddc6c57b0266aa5345e603438225ba3594b1e05bdd8138ddc387bca93850a31d30657b0984773ca20ac838ec2db527ad1faf46205df3d97c380e4fc06eb6c65760e0256ac54f8ca4b705441c26d820a79129c7fbe7889bb129e6b77ff0c6ef43507b2064cf9505bf87cfa61865c2137a18c6ba6604109f5736e01491099cd8ebe6101952d04e371ec87e6a933c26f584e1e4706ad9db41d095f87570a8dc0d579be155e68bb2031d7b5446065a8bf0fcdb7a388589017ffb471ab1cc880b87680ed367e134093c56bede59c5a38d1ea9423a82040b04b5c23d0749c4f8da36c3a43ab9c488713153223f3b76a2118df16cd6ab2f94d8d9292e9e30d819e348a1eb56a047b6a9b611a8cd4270da45997da43d15f414001b471dfc0614149b975fa65f0c2fd06f8a6c6b8c24a190a714853ac598148ed8225aba2f267c2385d44c00c0ec6af160bc03b5750d264767ff3df9b35ee147b139c4233c12350563d03b2c8112a87eedefec87d62c6d4531bcde399b4e7862467d22417e936266ef9db528a9352555ac509149a401751739b1158152591b55898b5d4ca0cd3c2b8bcb31a78e64a5dd2c767ed197c628783b5d3ba9fef1f9baa9af1f247bbcd0dfeae11a32d63447f0bb6255f69bc70f1a622ff19f46c6a842aa2813236dac97813e112b4911b2554017394406e6819f00f60fe4f2b9392ff77dcacd2a2d20390d3266bc84b395f2ce4e5a5c33560047442181ebcdb18980a1258cc7be7a56149c518e10330296941ee748b48895454a8938b9486b7c76b7a8a15da03054c78af6842bd9b80fff60df87ad136a46421943149723e21c7463b06df94c53f830854153ef64b9f2ba2e823933ce922e196e15ae54f3b6f96f01b32b1f222b9d6f9d4aea9aaa67f19e3711d9184a6b0bf30eccb5b9eb0ddbba5971120a7b4ace6a07ac89d567f9c3e97d3b3fb6f8970dd6b61a420ea2cb6a655bdee21a00d7b5614e6bd86d48f9149bc9e0bd91f0bf5139fef550fd33b32de6da07a03b30db54a7f15de6b12dc250189cd1d7d955e8c68d4adf89f689a2bc552be6cab08e89a89baf905ceab227ee992df4ab1b5860b95c97094955631600bfc8983063a000deeda724d1e136c3cc3063e34713d308ec7ac02a57e1a12deb47b8cd74512ad52ee615ff4eb162fc531abb21fbf45f362ec638eb43c82e23576c3f3425847f08fab5a12727f9a70796786e2e8c029654f201105dafaba0fd335612c8689b6bb114dfc04f14458e53b382be7995dad0b7d3eb50a7ffc6050f513be08ec9831fe546859405ea14b290c7a96489650faf0ee9caf87462d472adbaef10758fb4a794c3cf1cadf17094a3b80bd1cb272512b1e11464841cb65b6ae4ab4cb7fe315b98dbfe413d6c55e9869747e7855a8b4d8d7f26beac5d550e60bee5d58aa539ea787a1577d8f26d658e7659e7a01e3009f78fc482abce5429b934d51621548035b9cbaf33c9d6d85fbb5a82015a7d34066a87b937a5bf55673343d744e609b233cee153664dfe688d352dae2a4834550cb36ac2bf456fff71cb4f4c6d03f7e16fabf3c3232f712b0be46d6b04b3ca156fa2dcb6f70923324ba79896cc9d4fe6e3a2a344a649fae30bd21b1a1eced7de85bbe48ea3c920c6cb10c3a72422aebdbee842253e666ad4dc9be0d59a9ef81c37998f78331a9f916faa5814a5557dd3f2161e94104915fab1611268a963c9f1a6106b9ac4ae75b76beb8b87edde3d59c6fa587d989dab8644db15e5e3300e7feb0c0ea05338ebd68f24e54a2c29efd7115138f39f24f51a429717d66d282cb9014e2191114123d7b449230a5e3c2b75f7fa0c5c760846f20f0d82a49655462760664705f869cb4e26bfafa73e14d7dfaa68fac26ea9e5f5b2669d9fe26332e8c9ae2c6dcbfc2c459aff6a162889acc199d2642c9bc5c86f5c2ee0c4239888ff38c2e10df451796d2a63efe152de6076417853413951677d8a5e41d7498b2619d1bc49d97e6f831601653c069f1a0c4d6967b4a1740690ff57eb826c014d206d25b411a1eb3f1aa65a175765e914f77e7747103f6c06644cbc44fc782912e8e96efc84dbae7748b652920ac3e452d8ffd9a7e31b87c453cb9cef27fda335b3d6282da01c8a808c212f016026fbcd0f444fe58fee04f603b67eec05f08d98b68bb3da4043d3f30fb477a3c5c2360f90f9a811fbdec573b2efcc4f2b6701fe0f8990a2e69cc77d5ec61d0805ea452720562127f286dafce1c1a043ba306c0f4f6a60ac2bee4d10122324fbd331a4aec807e9818f1de32c5b4ba7b563a581c313f89ec4c4e9b4caf3b2e3fee11ee939853fb0987f3877b5aaff3d48fde8c1afc53418513f49c549dbeefc6c5cfb9bc83889de61c88c860d3e34ffefdde8208886998250e063525d26381f2c64f75478ca2fcb73d9488b6e6c403344f0229f28372cc6536a372592a402457fba3eda6fdc41333a8a9faf9aeaea23ca68a5e212f3fd1630506cb8d6eeadba529c8e69537fde8f5ed16891d92859b7672fe8099e93072afb49ebb25619931b8a37b74fcf42ca8c188738010068190c47a650a5e97ad0506fab8d7a021dc9562eebf9da38c2691ed075ffdf0968da798bb826d6480c4f12ae6326c7690091966503fdd715e40ec9cddba9d14d9b6ac0c77a2253c226650a4120c4a2faefba8d537819508c6c0f3298505570729a2b1c99bf563ae0dd865d72c54fefb2ae6355a0909704a1c0da06464ae3faf2ed650bdb1a31dc2182f2da05fc23bb4fdbf17147c0b7bbccbd73aff4aee1608e09e332377d1d9c13389a41c39a408a55660f2292d94933b3ea31b2b584eca671ae9162c95bce3a7f8afc6687dbbf3d0d92ba92ee8d7fea8ff308746ce0ea409361e6d570d765171f4b370793547eb19a1fdfdb6c5cb4151a9b6c80543da8fa01ba47c05d1b51bb31a3496df5d01b6161f4ce6b9b074926f52269badb2301b3167f2f1866ed6210b741869513385dbd25dd668795b36cbf69bba72652434a7fa633e50fbccb7288f83128aee2046325b6e314ed80e7bcbd1540935b274ba4f041e38b05753bdfa77a81530cd07bb3f8f3698a852bf5774536685624c026186385215f265baf9599fc70b2ffd86789a7eea54b94d60fd23c3fc9e74d7390c475742cfa5d25c160d4e4c7b33c4f99d3de23d76d3df7fbec8444d9aa197eeba909c58960ac872f6b4a2f22ad93ba780e8606f9b154509f28334c846d657a7c959cabde44f70e18200ac311bbf57bfbb630f341d4c32bf59d2024c380e64789b4f0f36fae4838c9e52665455d5e8b83cf5a1ff056d9cec4690d8c85d97d2d4568fa44d85941bf98d8c785bad91288e88628cad1e156455c981e99aebaa119627ed234b0442d4ad2528e285ad675740b2e202f5db91405b1db2fcd6a852c2dd0f69e3c1ea1b0ecfb67d269f16072f3edb54c30d1613cb41502715d7949eae9d063bad5540b19f0c2159d755c2828200962ecd0ecdf815bad1de3fac7562ff2535a0fff99ef4212f5f10f6d186083b55237f3147dec84c47d3927d03aa98283655b652a7143c9e21af6bef6c43801204572c3fc78d7dcfa4d84e9483e3d61576845834ef890a0d40fbfca968e94430a4d5630b4b76b236397594b131bbc96ba7e9dfe9fe4a93e9f078e63b6eb9c3d7c0dd9d4ec7956d7949cd6fedea61080d1fea1f77fcc178afea97dafb6044348e1b2298976c1fc35f2d29e1b4b26992171d8a6304c9289123ad911bd74b41723a647d0071bd4af517ea3f217b9f9933b4753ebbcb1f5d4adf4ca972785012b3b800e8479e16ac4d723a12fe0b30deefb8ed47ed3c58f1ee56f48d3306801b0da67b71600f73e830179252764422d619872202501c89c0149e9dfdbaf1de6037c2eb3dce5899250169264993632e7998931c40596f037585bebb7aa38f583a387e026054f5be74ed18ea6c9688e72c730bd562ead68ff18ac3ce0b78288e530867a3d1eb0df134e9a26d5334e9996e296d6ce2df04642c49c59c0d07cce7002b3ffc1cd780febb33834762d22abccfe2b82cb789f1768d5765fa795b1ce7c9f218b34e03dd707a60e89add0d163b7a81eb3c8474a2810c547d648add941d3e346dea6e63829b26f027c6850131dc911cf1542fd2fc9272447f55231c2624988e4f44a0a01d4e013c8258e747c8af726c4e324a17b68cf3587c7e896be6d7c61bed5f815f36f4a1b2c98e400921f41b9b1cfde76878742a5b4f64406d23de65a20cb598f0be02b62809e32eca4bce2f864ab5e8d7941a481c4f7f8ef062da931d6387e052388e4c1e64b6d2fb61b2b171977e349ac369d9b1f6a3fd2384d0ae2b0885a8d1e27f7028fd4d417552bf7936ffa2f7beaff244a5179cb0f5273aa892971ebff73f72a6bbe0a2a38f2682a4b7d61687db894d8123d7f72b981daac15b3f404b05b4bbadfbcfde417f4e64642942b680d84a9c21b6f05b5243fb5153d9766b8afd71dfe730746543faf04787b52159bdd5f980ede6f017c54262a57d38ce89e0952b30e11becf6879d879fc1b6ed777ae5810675ac322d16820eaebb40fe888a7cec8fd6287d2d15990892ade3f7d27d97e13db2da782c31812b995cc372d838483721e1e8f3443fa110e878a45757345243745048ead51014f286751ef068301586ffe3cfe1f2b0afe5ac5d9d516b63f1d01477cc059d4f18c00270c0a7983cab47119ecfa804457817fc91da962e429df36276bd72d6c7e3e4a9f876e0fe1b8749e26a9505d43e21dab622cb2ffd4fff4ef00b3c14bf5ec476a454b9442a30c8040c3e008eaed9af55e8a4c0a3194ad4caa000d006c6b1b915632b6086238f7713756422bf5d64bdca6f3276d73be6977a48e0b3335d91858352e01b538322ee384565295c864b4b66c956f3dfd557d41b19dfbc7a894479d0ffc2e18b6705e9425726f929e4cda2c5cc7650e976ccfb1c7e9b3cc43391c99d2002578db4719a86821dedd79ce89e6bc1973b2fa08dcaebcef9406132fcdc0757f26c82f0d717125df26fb8937600a0cdfca22b317acb5f067128c4dd325894e4cc39c14b6886ce75ffeb61e1c2d27c2df030f2f71441c7186858bcdf2a1880bcf063be5d194a3d1ed452f2255b0dbd2a5b098dc14d4556d894bfec94f206b75fa50f65b0bda14d9e12b224b19e096315cab6e37a2c85751a7a5b4d6ca53e3d848b2a7e1289111ca5fb963b7c9c04bae8d9ed555dcc34c26daa04aa9943652ee0a77ca583cb8932d861872f7c0d7acc0086e31eb6ac7972e7eb17a8b3b06a4b00af77b502b99a12f252dd793fb7046a626e964502967d905f41b3a1c2f013b496cfe8578c3a6ed8077b1a5388746c2884abc4c63a08c80996f8e05c801428934ad0cc8fd231da301da184aac574a5fe5cfb53752da349a3e6deff4adbace5da49755409db3dd387bcb6e9fbe25a44dfa22c37c2c7437d0270f23fd18ee10ac09a3c37f282b486e6d3b861c93c4208679e1b630ff43962b81ff3e287e450510fb218e58aff83156f9045913add0b3f8722bec0590e45eb64aa4ec210319b912f51bf9b5b605b5b357187c3830f8e30e0452e147e645372f8896c44f30e2daae8df6a47be7dd49b41bf2ed609bd97c2c54ca4f798d605338f4140ee7301815bb01341165269af4047519ae72a02b032c8fb2e87eb79a9b521fbfcd927eacf453b923b8da355a0cc1d1f68bb5be80eaeb695aa55c129a68479ea3ad3dd51764ba85427931aa5524cf7ea2e8b4a7544032ba60f00b6c0c6b15b5f7d2c1dc2ec71c4ff3b8f3c584200d051977439f1152e181c4dba66d18b72a40113d274b0e49c2373938af542bd6f31038a89d9cf383d531a46d3b3834601c47cc244380acce91bf5ebff860ccc3949ffb8699abc10c2f2d2abf04fd1eaf26c87ef43908eb54992a5219fbf157c068ff5b4effd715f23b29866912c2c74307d8398629fba9ff84a12dddb5775850236087420021fb663219a019deda4f1b9bf72bdec61129fa442f88d0245ee4c8fbd2e190c4bf0132121db7c76dad8eb585a9cf6243920602f347a6bd996eb780f79c2c37a6e3f741c0986a17cdbc59341bf1bb5f903ab19997c48037f4f47fc919a3e35f0b71846a0919624f592a05ef9808470371758d759883dc386da82ef84f2f7f92d92e2a69596ba47e2a8a4b6d6f82da2e36dce3f118f740018c9cfacd08582a4813f992cf1ed7466ae98b2d863298d930644ea004c79a03e3ec4a9292b461ef5600e8c57b6b8fd5203a8567ccec8b3e9782accf7a7d901a5b6b7fa2672774c1e5c719ab557619341a6598250138816816b0eadc453560de31038758982b4cffc853e183f7e3be4c4dde53d850a323b4f32945d724881620bc9c5f4c2840f804e1e782e0d0f6e15bcfe3a7c246ac104c392aac6a8eb60498aafc08d572fab00eec8ecd05f81a614bab16fdda6543060ee47a9b91f179d8fae1264394d439fc047cb610da6f6c8a12842df9594244d7adab6fe011ff93ce2668496c701eb461747c196432dc9b41ba9c42a9b6bc0ace451a53073436a4d127a34aff1eafeafead885e7f5963b22437d6cf6805e7d1c231994706fb7188a01cac1030db13708ca7137a7e0079d8428f328a45542a212c49e0aac509d86a5fe3311ac3f0921ae65b85303e3241a3f050db0a7ff0403b534bd7ce0f600a17feb07f7183ebba51b3ba2f4b5d22fc36dc5268c63c2bbe509b30872ad86551c0e7eff86e1a5fcafdb74fb8a8b142b66d3b3431411f8cc01bfe34c329ee6cad910ecc8c206a98fa0dc29c227fbc1b199de8c9ab93a6042bd351dab187e76da06c20fabc000ec4cdfdb97df170610de44ffd74cdef6d2af9eacaa8cb22602be070ff0c30a57dcd680cea4264301751b75891e6510432df458867879b5bb48e1e30b2bded423def40c4d4699fde6bccd736f8d60208741e9c758f8397c8232355fad73a62bae1cfdcab99356dca9c77b64c249cf525892f5d9b515d9b227092a1275990f43e6b812099226ccec871dc7a856a5f6b74720b82b6a1190622b7e2a9d5ffa05f744adef02e110a2e9a2971863ea10b6684d16e1e8369d2d6107f1b46e8b6325e616605c99706150847cbf899a3bdf12040c6242772e25e5f8835c878cebf0badcedd362a92ae65036188e4b947f53357d9b597ba1d5cf14ad9ce583f39d3bebe5b00114aa51678f198828aa21489d37303af2cb869dc04bbe48e8d5245a5474ad94f7f142291c564ad4ac026ea0c025f3500c853592bf6ba44b8ac6527d4d0b111268671e6aa424acba44cd8add2c2cc7591d4eefb31ae128312f51746624f13933a4ad015ce07e2a5b476b6a0fc23b51cb985d3c14169207e4a1af2b80bc71a7151a3020c49e5b6164130c0dbfb996515fb4b784c48a7a68f25002d9063e1496da2872dad6565d949486e7286a010a4ddeca65d0a6d0c1d9d5e9dfdc1e7a4ff5be4137a922e32b72f16afb96aee073fc5db1d031bc0b81860da0a2d5751a65d64eb23c13fb29391e51a7bd58f2960f12ee930f8db38fbea3b73697e3b768db99c26f5705e4246a8bde10906095b4f54d5419e5850fc901b34c3fe4ddddd3b054117abc2bcf68960490c4689649d85d6c62d6775a23cc89d58c810925c750fdf40ad650bef51a947cfacf1e7bb4d05d2310e91b4144b702602bc289a9926e38b37f1d6d4ed8388d53ea1ac61f02549ca8dababfac0d49ca5b2f5c3f20a7bbb4b9a82e6d93ceba9540a5f03e67a42e7309f6bba7da7e5a39113217a94aa8f97f3060e8f797d729ea534bd8eface7ca8c1e51135a541523545f74c81f925ba53bbc623ffb1a4f57153220142235f555415eb828192bedae2698799a9ad46925170d4de73168eeee418daa6d1413f5e9d5f46c7f8f08a91bf772df7a88528bf4111d5b7e2be4ec67452f741b4ac0fb7b11e105960f69887441c8ff1c59f655ceac7cab65270e1c24c4d73d1189e16a691c122832544204c462f11a7e582c9fbe1e1225992adde943045fd11b6ba3294082965fff7df92c632b2166e45523009b29088846e32c5f8bd5980d14908d21521b92fc134207a7454ce8712b63dfb5139c3ff626b2334479872c01dc5b384939a1669ec098cddac89d2af71c65c13e290c4519546e5507a4833bf619236522757994063e9b62ab92d758bafee0a754e23ad8b7074403e3de056ee79b6929160736ffeaa309052cb5593bef2f93e20bed1f8e2f4816eb9cfa280d5aa0dd6de217747ab0f61c08dc019b5f38d24a7aeed22c6b04bfaec1ecae56914aa59af0a4a5c95980a28b415e6c6d083c4327de8dd08a2e04015819bf7852dcc06ed32a2fae961935fb15f98f8986cc968b7d12f54ff1d59c0fc09419b1de877012733df1a0f29cce3d372f2ec6b3c370a0cb9c3cbe28877f7ed57c84f8efb294bab8b764586c45f5df5af9116711d28daf34d526085db8c37b891a3bd50080b3ffc0c6d989cd8a69182a158750414d1004f4852bfc1e89657967733809fa722b9bab5a7c2526d0dd0830c6b2c52efd1b745d49f0be4104336e84cd270d578a94c5efefad3e4713ac721fafcfe068d766b83dfa224dfc719da4c4a2cb4303befab059769a977629405726501f4ec4d65397eed1c57481cf54c71ee25c3c6dcd2f53d95064bd23c143d68e375e9fd67f550ee8b90a8de8e5c174fe719671b60c75a6f5ab51577c599c0cbd9225bb242062a4c66a29c5ba445fb3664fb8509516ff493ec154d115ad5faf0c205c89a835c54e26def17efc68f2ea6f91b059e326f7601de10905053ddbddb5822ab9e88538b8518eb12bb7e299545bac99f463036903024552c85d5d8ca99919f33ef03283d5a5642e2e86058cf0e42fb88f88229c3eb0d9491da72b80b278f9dd330f0ea6252b37e06370b116d8cae471f2287a336ef80f5a61d201c69fb9899dc582eb8a9e643fdc9255b57c0c57c298c275ce3dd2dd735e0d3b8b1ec54e3febe4e75d1b83df6a536a5bcda047a30a20bb06b347a7e3edfb6406232886bd553ac5e6fa367f65dd3bd1f7d10d46988f76e62d362fe71b8b47e3c2b68ff6f96812f05849bf6b6c6286a0d62ce44ad8d30fe4dae740b8cb21d544d0db88b68ec7f8f134830b937f46d6aa3f37e3348b0ab1a959f91904ae57c7e812a11a366f468b9361546cd468137ee15c92c36a31a3350a7b7b1e89775a6ce6333faf5f7046c9ed0e4997290b76443448cd973e0458c342491ba2f93c952779c1302810e3cf790bff1b16a92b260cd77816513714411e119f1691aaa39e6e1ad0216925a6aed2da9016f336a229e696cd7b4849d2d181613f380441c924dda8e2dc53ea4b8860d9bdaf8fd86068a2c6db7bbc2a2cd3009d9e03fe4608b78d8dc8faa476282e2cd77581a6842e2e103b93d97947c86a36fb52bb4f00f88bc75c600fb0aa8203dc2a19815bad7aec798f37bea1aa8ea222746854b4f1a679585386657ef0da2630e03c3d0684d475c3fff07b11df376e2e7ba0f35f8d653cf37644058729336f88d59926c2d0d05b2c22ed848693a3e9a31c47280cf51a688de98504e6e41e6c86aeac567e416190b7c1342b2d0ec72902dbe320d55b4e43ff59c87ec9cdaa0a09f736cb88d98e8fd93d0b588ce246b1cba1be7300bafbaaeaa5bbe7567df1be40627eee26c67a827ab8f8e735e56e579246c0f7df95664201871e84a5245283d48387ded3e7736e0d741e6de9b496be8da3e3e4ed35cfa7f7ad2c2a94181cb6abbd0d27417f38ba244529d9b6fa337081f4ad3608e119e4887463131d02e9da1f67d449ba981bfab2bfd88697df078fabcb64bedc9f91d3ae1aa1ea6b1de87b52bbd9344908853f2cc63026c8c653f62a8292013665fdfea0a05538558d26c088ff5a78fd4ce5503614595484fe4d98e1132a5cb55e02ce56f85e4f2d72360d1f2a32888f5060c3a726e85307ae52ced15ddd631763a286decf7b5d0d08fa4708bdc5df02cbf6651d373817653f6e455f35ac4e22184429b01c479a080f521c74e121553a10b9515481de0862fd35f3ceb593e965b475f7e10a9c339c9c45e018cca3c6a239f685215fa6c574b161d8f4e8c6fdf73b4e1a0114bcf1d236694a691f6637a05d5effa1cb86810a42e24ac497ff30336792eb1969fe89bdbe7f4ff92828e8fadfae2ac1ed1f6ac31ef0b9b888787bc2f33887087aeb9e28f74065a70bdaca6614c908c61553af8e5efd90af8c32262abe7fda33754959b2054c17989ef3bda8819f5be61102df5c1edc8dcfd8427f829c6f62eaa8ebaf4af67c209d76a8cc2eacc842c18eba727d8f9eeeeaee4e420906f06fb9c59b1cdbc4ec91327d03baab29a98b8af35e4b47a5e837054025410428a8e09e818719edd47352d59b1d957b9db5a5caf8b995ab857127e5cd442ba347b109e37d27004ff4d7f3b6b4b75baa7f5b4289461bd5762c2604ae0e4f0cc459c6e6ba306ac6cd44de7295661d718d199aff8f03e1d370ee432bb53cc6fcbc733ca31eb82e6eb9834863f05b69f7eab5afa4ec2e1ef63e63e583b8ceabd6508eb4c6c244625a4a00c99dfffa11c12e13c4c9e1ba64549ca3a4b9d6c549634f64ebe86af5791e403d90557ab9c18f5e036e66c4d9cae305d920b0fcc620a34b0afc7c6d1995e64f6252898c00865a9b89e074a9fb4897c35f05c317e307b7757ef0090c4c4249f64645febc5b1f7e34f8ef97a1a35c63c5706d95a50237631a3b393f8fe965dee8739791478208f112a4a109347685d64ea77d2c2ace644bf0cea92459d1f70f5823d252c1729bb0eb7dbb36368e3a07b1288c16eda36c88274bcb376fcb31f8d1b3bba7b011381a5c20382ed40b40c8e8832be8255ed210d8cdc421bf0fd1aa60dc518b099266394fc0b97cdaf5c7b19bf933fcdd2bd2ef05a28a4c138695ea17dc7b7f3d7d3a30ab9a4387c7bde3985c2c0a40db8742140a130cae6c3e962d5fcd6ebfac6b948a63a78d3ad66f34600797deaa8bbd7f268e7e03c857e6162d04a48f723810dfb4b92f9caf12e3d9cfbef4335c0a226a892b301dfcb765b30a68955f4fe523110838d97c9ce73203471421d616fff4b711ed97daa5da7467ad337002c84166733c1983a35ec12c96071deeb8da05d7af485cf82e4df58d8b205e0cea9aac32ea4fc91470c3f4aa664af86df8e2ca59c8846c966cc6b7edeb4183c658c407f662cb9b76adfcc934b6e7f96f022fe1dc34b131e3961acf58686a4e20158506bd600542f7b46dca1fd1534f799896fd6ac45cf42d7bce52c9bac95c515d9fff1d2bd99b200d14c653c78b50b245a4b100d45a45fe5a81004ca000ad6d4126bf3368e0dbbf06fbb42d925619cd162a54f645593e2ed6ca746e998460684cb684cc7a6d14136bda44409465314da3e75a62e6e34b8c61f44fbe20288eb8495e9139b8346b24f86fc9c74c78e4a40e31daf538d53e641224f415f50d46b56135df0b96298355bdcb3439f411b8c0db77bff56712e63a9c48876a2b7fdad8877c6428010f493f1c65f1f56528d4dfa88bea394830418a34564eb222ac6e9300be5067568a519ec97fd2d8a0d665202c4037b4cec670b4191f0859c12c53f0c063d552d196bd9a043718f007fa5db2e30f17af3f3bce0d684e3864f4b65571010a459f949b3736155092d29c8234390073e43762d24041c97998fcddb676c9059fe24a901aa626cb968048be4e116108532b83895a042c3f451302a7f6daaca03f72e5140f2c0f623af597cb4deefebca155675d1dcbc5004d2e4f36d440f85448184d039a6d0cd9327119281dccc5a7320782a3d71dc73dcaf2f05cdd6d2ccd92b4dbfa0bd708b6dab7d76f116d9453dcfbbf47503b7efe37ff2fef071f1e9d60fb1913e41178f164aaf0da76e11f51cb5c04d010bf8d6ff0bebb39c5d22f411e150bcba35febdf4000031db8a06b6423d4dc84ecbf26f79fde967de11ecea7fb94145430febfa7de97a361a21e7ab625ab14c2d889e2657ecdf5d7c5d0c70abd95e70709dede3097f8c926093c140f989ee567dc989fbd5f077e1e3538867887b232a6f3e9aa5ffa5ac67a4a034ad6c994787599931649cef6aa4c2adce0f8e7ea7588b813358c01b05854578f494d150eabee67926b237eba7ee81c3ed330d551f20c754345e54796eaa48ad5ccfcd8e22839a62e9f0a93c35bf2c800a5df90f1093b3b7337c4b2ee30e540926099bad45f61efdd8b79e5bdd8cc6123cf4bb44258963d2fc3009b0cb9a210eff6da446d2b3d1d83c9881d90c2853cfb704b9e51633258407d548b0d05513b8a9819c509f3c68d85b1ce9dfb5810420b282d6afaa668408f36a69e5b2a2864fa3d1597053219a3d9f9062885c3699a0365aecccdcdd41e52da42b81327febffb83ce24b83d6ddffca69112fd9cfac6d20e2ae7ec3536b61f557fdafd80d6ca2a3277a290a0861dd7276fb5d665fc5cb9cbbd518efbd1f6b07fc27c654ce3af2642844e01661ec1d6573fca35cb09486aad1b140b3b85ce6cdf2080e0c520cf641ba9d0bd92367a2b5a0fa6f0288604e015d555c2113d2a6df31de230ef90c2d62fe37638b22d36a0a5d8afcfd2e9808ca639361eea13ead5d503a88b49e72d1b7d6b10accd2d533a1da104db38e57fc7c1c8398d851f6a881998aa94efd59d3e4fc7e0c43a464ad1682ff2c631c12852dd0b8ae754a95130503f3b15a9b0c9ffd30d4ee2621570e746ee4cc427ec490bf106d9c54b630275e82165da548d6cb7027d6aaf95620e2c314cda5bb28d475399c030c9e3f3cde042223e26cb7105e8a2b61fe8265741968215c462e3ca75d22950ebb07997ccac9bbea2c2af3a38aba6664b6266b291860679339684bf031b7de9fae5633a436ec12804ac99a8dcdf006f8be8a18b4f125d144f03cd5bdad243cedd9f7ed2abfa44115e0dd59f544a4b2651c14029ccde8a517d925045b42f09075e3e3dcebc4605d77198c7eb3952bde972f2181b8675a9d6dd7b0ca6616014556549a51d3999c7810e2027f713f66d1a33eedfc2dc904393a25ae2c1e196e516b8520ad75f541400e4fd6d0ca7ee956bba9045d566381006d2898a77cc2c2be3d3c3806c4c23620f3255c4a69b352621befe878b5b1460d1ad9ca7c78142746002c9761586524f67b7be2d742e223b3f1710417f2117f6e6a75eb83f730708f905b13333dbae481d660289ae238e5c4fef0989a8b3cba1988be79116dc263c5ef1df1a3af1ed6b6d4cc61960cfc1d336b3cc3a02b20d3b08052324a0ff13d0d37630b15e45ff1d106d7ea92fd302c60615bbdb14c8c4633761fc94faa177b248bf497c4fc6ef18292d6d1a2ee4439418be5f8657abdd67be93738878ddfca17551a410d0760697cf504e2e42949944513b0062c036a8112cc8c88e831843f335d86523a0211faf46350fad278181b6c6a8277ce6c0dad3806a3f1f2c25aaa4b3abd71b0f04674d2e9e096d0a76c40774299595cf40c3cf45da56ac216309dc0e1c03dcabf50e2b78cf1eb2f0c56156523dbb724a78c27b3c720662c986817b433a7b268c08de5c5973eeba2bf64adda910c8e8eac3d402079f3a91cda9c54eb0095733bf55251ffa207a3986097a2395766f8947fe0f7b8a44991980079a9ce343180bd64c9ce2d8fced54df50ab3cd82eabb436966d83d0762cbf7b969415f354515172a38c637fa2e1dd847bc7a0b5ae0612eae9dbb8b135bb612826e214d00f471ebb6d621c5e98eaa25c6447fe722818eaa62afe168f867afe781f8582b94b6d45487f95017c3d5185ed47927a6823a51147c148873d16a529b5d91650dcfc1c6b84387648809551e22162a77feac0abff9889895b313ea04b750820305e0d30866f5b6936e1770b0bd0131761d37f57807cecb971cad11a8fe55f6b838367335c76c372b53e791b3b53fde2101c13076b0745b903a63d4e1ce51c87b7578ee22a8012ffd350883695e830752304d44b921ebca878513e7c8f0a86959843912d0576e26d86bdbccbf1c180f19e01b4f2422be36f67e94ff36c8dd4ca661adb4147223c14a2f2a211acc3e4013ef9c004fa8a3b953bbc9ac45a3a360516c655f30ac91cabca962214218f021a36dd2c89fcca9aa456ffedca8809f85adb520cd7518cb814606f7683993a3c28fdbdf2128646c69ee3b3ac342b6b527d655401d30997e7134d15a540c92129027f1022839e1a82da97463622a37dd70a8a4b3d741216fa4b6610d73b895353152333d1de4fe9021d7ecfb03eaab95375250936b49739fae3ee117583490c89b404379f10105aa5c99221b17899c58b4224286d643db76cb7c6eaf1bd21b8a6b49dabfddda7fe49010ddf89fe520a1de5d694b8deaf276ca76e5367bed55a6fd144957736b00c83d3fd1247af63538b3bad29c1596a308b52c3ff0d2132f07c948e3f52de8a52fa69ff487a13532f03152db2289e45f2cd8d740d04a55d0d42894eb53b3b08b09c6c7b46336f92ef12b8cc4477f7fd69e86145be3eca1d877a4a5f124a7cc9e6a9c4a12efe092090aa3503d1659503cc3ff7e43b72f800c6c76353a18691bd81bc75fbe4f16b62b5d813624661459f00a0fca06b68542e922398323bfd6770b9d9249a01cc635df8b6dbf3e318f89b336302d0acd0706fdb5aa0b585deef62f84eeac8853a4d9d64692f2e8ebc8bf81c9e040cf74f5d5a8b837afb9c16cbb00cf1ea6842bffe5bd31c4a5d94149f558ea74d55a5c800e69c4f0a8472fab89ce7b50d67615c5d5562a02a998c7f116e78984260d7b2e28fb9153dd55e540204ed33ccf64d7c841b90ae78c68b95ab810f2adaabbae670ad4124031349e8d32d4d6ef4bc71f0b8768cb1c80c3cb1e9a442776c7bb91cd770319eb2ca406f0c181726c20ef25b30af183ca33a3fe5db9e717e95e43e83763fcf5208e3f29038c5d7dec10a8a4f0c64b1f4a4187c554ab1e52af2ea94032c15b210a8bdcec510a4b3709d0420f91de4b24a415e733d7def40e41573364f5dacf0981f92aa2019e16d152c789ebec42db1665ba5b752df43e33d0ed65ad34f3d50102dd634162e890de8f2b83929cdaca18b441b24d105e142c49491558544ae0c1bbf625f4fb2187e82d5d8389edd6188f19a9ef0023bed2607aaf97d8b82748741bd4e2d02b2a642893fa4c1cc427bbc3ebd919b3f44187cc3839766a3829bfd372e268d55ff14ddc2408a5b1fe20822d509c6becebdc08fd9abf3685fff6b8971f5c90cd6181fc2f554560d4b846ef01ee4cf45047fd78e252697d48b289f0854ad3b2aa2dbbcb308d9ff41234564ff3898278c192d4e1b19a41876ad03f4ab82eee104079afc6fbf260f53ba53c9c4912e96737eca6d67db5f604c1fd3f9a7883f85e0425f79944e9432f2cb0d96271451ede2ee7227114427f3cedd2afa61dd7a34805b1bcc50bc255b2559c43b90557eb7cde337d1fabd127b6ae2f8e87981ae24875a97702a8a7a07c9dfed052a21d7a1ed690bb7ebc08fc169dadb50336ea1215d222ee084e125b095054fd81bd0221a231d15153912b96d1e63195e36796f012797285fdea547a7a4b8bea388cd190d440d1f46728cf16cdff15b37e5fbe1fe360672a34b2ad3fff5d671d44467d39de4f9867b1ea458e563276a5c7257e7ea7a6b61227a0ff975e722a0cd89acf657f16b60daea2bff2b4ba345a8aee04ff540c2c0193735a7474c25092d50f523251e7ba2978fe65fccf261885aeadc9a8d5ce3e6edb2f26cf3fa88990956eb606f8391a9b5a3f898d1e536070b13f09b18e2538f9a0bc56b971aa0ade4c865b9850d8edc111b8d4748fe37ed1ca030b2c754bf1132f914d7f1f8befe5f4b8bc61c2d8e48cd41de74d8e893e09898baa05a52f82859a3aa2be7cd8eab2b5338d1017d8bb14f95821d3fb6876fb67f721f71dc90127906ce7b98ee254f731679d755e3ca2f4b1c0211a5e95ef7f3776868c46bc679c71f68b3634ae01fbe833638eae819d4d792fcb14ad41eb7321108c05df3ff68e5289779f4d2c00b69d84b6f022566549d3266801850a4bc7f2095feabe00e11a28eac041dbb3cc7e32655cdec1bafa41ad09f291b53e7ea2ba9e96195ddd30e371f0f7248e9cca0bed8a616abaf37115b768d6b0a492e5e1654782ca7394409c78921cb0e4507b1dc7c7fed10070ee197555117b84776b94fac210ba183bd15465485d665939152fdef6e8a9f8108125efc12712396f09583f0d8eb7995f3515739c16443b99e338ef54a94ed89cb1876d48ea4b54790573fd0c974b68e0240f7c3854c67db7c71f73c4470ff83769dc9da420e148f36e93ae57492a962b44079ee19b46a3669a5c0487415165925f42729cb5d43ead4585e94c0725c0a50b6e0d0713c1b59f7d6ae579e42d395d1015cc2f328b3cecdbe1af9624e2eae18f078534c101cc58cae082b75ecb07fa0dea8c7bb7205bb05b1aa5a9799d6edb0d7c74ca973250c2bb1007904282ea304829dba525d138d16c0cf0b8bcb11259b766483f54d33ff0737cbe4e687089cbd8c30de5ad15b7bf66ecb767039b1e5295219f60ed25a8c76f42a4b49a7125f497bdc28414f50aa37c7eda8a709fc21e41ea31100736a7ea76834e91f88ba3053c68fbc3c3b826011d8c59541de4c139c825011ef7d10e7933180aee2e34043c661f8ab2c14182bcab4ad4f612fba5782ca813d56ae91a1ff6debc15d8326776a4ec8f7582de786a04c4a189c9d2d2fc47b096892c07470bcf47bad7fd0c4b3752db2b8742845a92ebeb20593c540bc951a74b6a6332b7ee25b1958f6d1b6ce499087a4d08e32f0e2fa527d66f6ef62ff0f7d907c8d15f5cc33cfa9f97e650c92773566d22cff8be70994161e0b82c9d648a099e63b57c148033962b33147566a49a47e00645530f59299a8a80ea198e3cee41712bb22ade4a86e79bc60b132eb8f25483cfbd5721db5551f1c5e9c7205d3340f0cad32b768748af15e08ff412b7bfde62859d6cd70334019ddd803cb897913dbe328aca80c49c47a6617ad7848a2c3315d7d345f0f0be24c47acef3d6fdd67f13d362d16daa6c34c8a22f5e234e78b9714b49c0940b56b0cff7911239788e847d026a327df0a8de563f1beff1663107f42db12a5c7f24a31dd60bb0dbd59fd951e0a15b214eeab6e87fe7951e17a6eab926ba1c860a25b910f3691b1e9d0dffb5a5ea0766a11d1dec66de223717679970bdda7aa7a3321a76981cf25226cab5f54c6d2b1f9e634337ae69df2ba08ac949a7a06c5cb6fad6914edfbb2292aa10e99272a8d8e162a48695787de33ecdd9985234f95c32d94cf35a7e4600be4dee40bb7858cec02b4d37673dc0ba3b29f05e4209d747dd3da33c83ec30d5dba3c190eab13186661e5168dc8120fee1ef2fd70a77ed57f379ed5d3a8a11f558ec483f68ccb2afe519acb75142e5cbdc3bc26f265b9b2aba36fead4809f9f0373be311a80848e41cf00ab48e586342363724a5285141334a042b08987d33aa105407c6d01e796c91364b8cb880a7e65b601354cd02a4d1cbcce83568b8bebfe5732ddab505fa7225f02a0057e5e99149598bb9905ef9f4f6441d4b9f0e1756c151cb9903b5c851a67aab0c392d8a2ed1b56f67676c00f6821a2081a6ffdff1b26e15105284ed9865ecbfc3eab4e748ea2db3b3e5b02f33713e65f8af73dad48da5570b371093c300a055b524b342cedf7667bf5282f4ada53b650c8d04be488969388bbf8a8ce8531f40fad732470cdb1fe8a7f798f4463f00ae9b923cb056ef39d2d3b4b39055eede27454cc242e2044c1fa4ee0b13c66672abc9da1e28cad0c197f87c189453466b55f7f0473c6084932c049da38b25f9b1b15a842969dee1423b3460fe6556555f3c1772a71990bebeb172ee02ba5675bf9b6370f1a7a9e6d20d6bc88aefdd65a3910169a850c5a0fa9c1e14c307b9619deed8529c3effe8a6ce00b46771728efc9ce0f023bddc1010598ba45368f27df58ec9c64d63c9566c181201eac28262f0b56ae79fccb024826f0127425b7f1674df5f9f8383ecf2a4a24dc575b0aed4d45279e9d0abf9da3d2283facf246b1acf3cddf63eedcb3117cf2dde696adccb405b90e9c330552f65ee14f1c0910e5dfe0dfb18f744034a72163befbebf3ea2b0e43be961716d8ff09b5f4a899ebcf5762c4aed02103f0a07fb96e451fa88c85f53380e27e4278ea740d27d68620a105b8c9730c04a779d6584e4b175feb756070790c5c28d4767838cb616adf05faff63eb16a1a6e8141bf007cf0e0a61d6b7961202a6a7f78d333b377f78c198acce8bbcc94c105b258aa044fb6902e9be3cc02c750dfc2333f098e70d220886ea3427c8c32ce26713e98c3b1434a9a3f6b884cadd6ba85a1d7f742e249efc2dd5605283ce540374d7e5c9bb10a4866dffc5f661f9ea0b020e64ab50e3ba7664813af5592610e433fac051a2943053802dee0c1ea27761f6a440f18df293aaeda714cfc610c8e34f8853e04e866a56d362b270c87bd2eead404dc87c7f4258c9ea27b0142f14d6be8c4d7c22fe2d0569da1a3a384daadaad06b09b47d485a8100dbaeecc48b818ffe2e6c1eed635840dfeb915e4ee5b8d1919ccca8fca0b9a2376ae65e1a66cb416b389fbf11e9e3f5854b9ba3deb5b91f381adeb6445222015c659febac39898660d67bfaedb9a71a420a6073e4317081b93d84c2cafd390ac38bc2aad20badcad9f2a91b6e87d35862695fe98fac3d5fc24dc0dcb1f6b72817ecbdf19f5e2f2e422bff9ea0152aa4e97515ec04a87b14e089c7bfab910ca6a08bfc08ea8149c114e9cbff67acfe6694a500bb7568e8901ddacf196f8321f2233e9450025c9aa6230d688372cee0b12115fca4b4a00d51197dd501b3bc7362af3a7b6844d92cf7d45eb870319f731a3dcfc0ace41ff259f2260b7311d659f902a97ad1e31753bd28524006dec167e96c6bed3cd8961d007042fe3e562ceb77080b81821a57fffc7b68df4b3cd41cb47709ddfc090d8ce63e14afa6badcb167693bd7a2f13c1500fba7b37ca0c6496a8cc35cc4d544e60e764fe173a34c86f5e6909efacc9c34461aced0be2a7ccfbfa2e6728eb19b1d2fcbe0be3429f0cabff1e3b35456dfbee4b43a1a8c939bfe8c2c26e43bfce90039663f1d05062a6241f2095f2239f6ea7f395682c20e7a0e0948d2c6baf41ec34c84d18d7d017db95779a3e7b8a3f4b905d1e2e26d1ad8f2e35135b843b054719594cad6ae7ee382d04e88f0e6365f034cebaf9a8a95fe0cb8fa7a6d9d286af760faa834443b0e70d04d2ea64b58dd25ce609c3829285eadc58f2e59764c981579d3c0d5e3c4edecac5e74dbee938edc355e3193f8d04a4d9fa395fadfaeb8bc48639a0927e2fe4fe7a89a48b1ae3aec3809fe4a018b397f5ce8c1b767c26e8cc8199f11157fccf97ee2b61009f143150b2a83ddf58b9ce34b6d0d930abfc018e7121bf56bf55d581cd3a59aac4703ebb284677fc1060e6b7cbf6ea2fa488c87bfb90acc3b6eefdcfaa6b162bcfca9beb61e79bc4e6538b0005b033e60319d1ce2aca5810ff098dbcd0b9c0adb8036c5ac7900045653634e4d5f6da8f8fb5d0258a287f87ce4f6fbaed71d32cf53fead34e530bb263acf7c38bc0b1bd3c77eafd470dd738db39384490a0e38c52b4f653d85b4b5be9fd17cbe4de7feaba3ea90ee22af2c60225be3b9ac0e6185986c84e3a016779c376ada35a34911a18ec5e143a095f4e3d344bd98e555f814f8c16933a12188664e424137e47363fdda53f77b99e0f1814e769f7d194571fdea35359ac9cbf2eb166cf9fd23875278cdfa2ee0a8506d4e01e4352513b13170e534a923738422b8b3d6255ec390e04a12cac8dee02b2ac0e718e7a19e6a21898619efc98499a4636af1e914b621c770350417df32cee801e90913d9063d6a22f6f8d32a02b6140604c647470e25460c06c77168c2641546ec7bd795d7e64a5276d1fc98354a77c00237f0c48793817f86e0a535f0298eb2b383f431d309b6181467c6ceb649685a9d6ddefaa28989b7a0c61aa79991545461f170167190479fdc843a3b2effd15c65512afa677ac3cab442a4a8f7a696f892a45b4443c7c3c9a6b961a99fa731000d2f6b876e516a4a19deb0950db64efddac796a5e2182a0c3792e4f59b91c80ec45588464da2ffb8dbab44d01634c0a088850345e642d25f93f875717b5f811b034faa99a018a50c7ebad78c9d49d2c15a0d79acfc8a8b74da5b4ac97468b4dbdd15cdc4492fa86dc70b114748e9da8cf5bbe28530559fe9a9eea3a21ffb15c1e2c14a72c640a533667cb01476e4e14da5152be39572466447d19a548b8aead25d0e2e0ac3ace9df33fafcfb1d897436f3ad95f35372b746592c686314cd30874d6dc465b07bd17b074fbd8111210857386ea2c36eb7b4976f401cbcf68b8b61bb2df8cdd37fca84e3cc3e2c5334468810c510c778f40235298500e4bd66f0be9c6339b602e8ead9181979d79722d9a422f3c1c84b739707040b4d13388c11165c8742fbe964379784d3ec198b268cfffbeb0c29a26025ca51b5175eec30a13ca974cba3f8a5f15e3b7fbddcb3b9c919f59f7555e0d9abd955201ef5cabb864d6857821d108b37eefa95c2a83095d4b0041bf96ba2b04ddb43a77ffea67213a64215515b5b7f6ed31422ac32e0629ff54e1a87e35a05a2b8998c950a7a564260f4868d6fcedddf6811905337b0db2edb3d74923867a919ab90d671a8e458e2778b39a59178469dfcca911b20b712c15b26bfd1dfa5098e10125bf8ac55ea51f909b8aea43ef0ecfa49f939dec07e6894f6cd312d179d06a58ac109168913de146ce11b7ad26a23f606f6d95b3ceaba4e0f5414be81517b86589872c7239c50012bcaf35174c8d0f07ef1cd9b4c01f4a5a9e5532326ba1b24fcf6e04b1184b9ac64f46db5663b1f90690aceb6c39abb978911599b3ab38cf1e502cb54bf28b91fbd06ba6671ac5e4527790cb8b51e49f9181ebe8675562a913e8eae2dbc336d75040dfde8a6b629751abeb97a06f262fb70c25615033864064a288516164ab2734b15486bf9ff8fa8f371c0cf65073b95e9f831edc149e4d7b7238f68724a1ac5a32052bb767873229ea369c69f6ec5225550e4afb8652d6dbca85dbebed7ccd73cc71d5487f0096484ac610ce08c9e2eb5cd83611e313b8757828909b91ab00d2747d839ea50cd013066e45471d0eaa0aef2ad5799e7c3ae3b9e7ab570093a02ae7c6c60630f29ad1ec57bc26f19141aa2a691ec3329d9b1624dc5a0091588d79696cdcf4642779d663cfed2d4580aee1ad7dfd06557f334dffe2b23fa5bcff343c8f4bd8fec99bcebd4140aa7867419fc8b7bd977b0c9605ef9568ffdd7caff2d3eed5480139491f2f7a2a2962614fa2975837744dc74c41a22b3e4c3f859bc0c3a01469325b99a8cee816a3d83fd4a8915cb9d0fa6c9807d2c1d880e452abdfdb905147e0eddd857b5caae8fa8efa1d8709a46aa1aac58bf11112035a8746578c982b082737feedd78842d3d37a75d4b053ce2cd3155ab6bc4184c159253ce0df01438b1e3413dcab147937bc2945c686201ee570265eb870ec60637761ffa42d204b6a02ad6ffcb56e383940623d5aec70612af80a05c95829f004b86d4f8a59626921c951750356b19934c655b0a315668be3515a8293bc52d0f68e3c5aa13adf0a8540c7da7b900f49d9e4119e16a5fddd494a38663a0700313dfbf8925bb21b4e1009c251a85bbb053881f74c96aed058ddc08dcb9ed859eb49f475f9228594e7bfbbea95e65dea60725f0efdc721b459fe9cfe54c5375b5c38263b60b882931c986d53529517ae9b3cc62e37c2fd91acc98a522870667616ae18b05c0367b0d79f08ea677b1b2aa422042cdef8c47ab8f98e832bf6b90e945e1a89b71f953dc75748527c68b3bde9db4fb60c13f868ed5d4f0afab794e9638176e32ad5c1076a1567c8a8c2f058c3569c87c7f43e9b760ca0ba4e43dc9146fec8953f5fcad414af8b3d2adc82049f1387198148f60bcc20f04d3a657d88851549fe84328aa2649e2bbec559aa88750e591b02879031578392f28950eb5cab9352ddb5d10d362eeafd67b61d26519bba06f82e207f4f1659122312e1814a97a979e10667be40710430585f003de27b60f3b92b51e81667863662bc4543837de5c6a8f6794dde1c5f4070a728fb2d20ef0b1d32022e8ea693cf191c33b6c659f642baa6b753e0332d9ac00cbb997f4e750c3048c8c31d91ea43469a9bd0ebbe24487681f509acecd950c35636ac0c14ef02b887f0d3beb34701582cacffd708bb558cf8ae6925fd4c8a12fa0bdbcf6f6b8d712bcce4ca9e28d2b054d7cb2d3510fa23af8566568bdf0af7682aed3c5578ac510f2e0b82a8a41ae886270e8a2ccfba671251eaa1c738363d2248a4a459aa896e7df00cafaa5a5a08490fb0d0ba97090b24683c8f9a0b74458f6cab97ec4c64b1bdd3566b8e5c47c25be256eb5e3f58d04dcff3850b21984821f8f8f1446c54badc68ad4beaf914e6288a3497681c21dd4e16bfbff4c728bfe72d55c6c05e642f67d4b3976598798a7c3eefc02b826280809c9d9fdcc38f1d7fc855da10b54daf47a2331f70d5cbc70d1c095a364826c6fb7db171795af0bbe3df52c679528eecd3a41e12dff7f36f65970c9d38f1f5fb1b7293d72bfa7ddb9218592352cae8075912207b18cca643dcc4125711ee34aa1c29bd4ccaf1c710898094e7c98a6e258a2e3174a51461afed1a10cf49f3978c59fc606f2ccfce18cec80753d5c2731e5c38db4bdc70004581d3b3b3acc0b7bd7edf9796eea2b53c99728acc091b7c11af44de240d9683f0a8efdfdf3d949592db3103c88efeb9d3a39d809aaa8f237742994fb273a38bdb29164ab43f03dcc93bd51bbd751043266618bc35f94063ed5bbebd313b9d7a62f66bd625181bf947c38ac33f2e2b583622ad9a78e51a86a04b2316feff16b84c2b0bab3f0ba127bdcf5230cf23f07db6887137a0e6407a0f5f3b859ecffc7de2544b47b542f0f7bf697a3fbcd2637df342875b24dc2cbda1083bcda2033ec0be99adc755f1b98def157c303d41feca121ed5b8497cb90ce077db4079a091713f81b8ae7dfc101ed0249b0e574cc987b05f4d0c0579348e4570e40c5cf298a7736223c12ce60f227723db25a56ca5e8bf9dafb8ad60581050e924dfefda7259da8a89dbc2e8610bb59cbc6ef44dca5b9a39ee215a096dded7c9b9c06b074050e1799f9d23bb73edbfdae64553c7f7d91cf73565db53b5ff2b6ff6517c540386d0bb1960c318163fd81b798d0f4d9ce634efa3bd65d52f806a870414fd6ac4212983431318265680fd6e15ef749ab7a0ac6cd4e47db01a6166c84e6531b381a494d1e5cd06fd306b38b88c6b67a2ad58eb2b89336d5e0ebbd6f70c4a61aab89108163ad4c0ae55f2bb4bdabb97261831950c264832c01e90723a60882a327e2f700b326b10b8172e5e23662e2f6b3080efe670687e714806f5411dcd5132740e49f67534c9000b1faec884be251d13f992ca5482e5402a62f9410360ab3f7147f18986ef4c1d3908480cfe94e088a44b26d9e6b413e8e73217753979c04c012e09d38ad50ed8e440081c97fd1985967765d61630ad06e307d0a4d4e6250edf8411da77be9224f125f6838344404f6c0d6f103ca151a88d2a64c3db88e47347ff37aba423403b02fc88dc6b0d1a780392cb31610ce8ded12a2d10d1f22fc3049be9ddf310ec3f77853ce608d1a00f403329ba0659e9363901db73b23d7147a4ad6c658b2127cfb0d46b092dac8924eafcf24429041cfa0a5d8e4a317208770a9dc8ca12ccfb657eba9fa09d1dd1bba92acd1b62f365d064b1b3289fab5735b3639da3348cc96d0f89e56218821fc83b168ce94c07aab29f04bca6a1e3988a4ed39ff3003cf10bf50e17b01473c123e81ae7016f834aac8732b583ceb5d887ae700d5abbe7943b7f0fbb868d9b56c0fc8ec0292098707d6848e7a4d8e634ac16381b07be4b77d55f563633f8bd831175db04bf0f3f8325d36b150d26e6cda2209f16adcf8fd7d218730f9bed0434748caddd7b976401713a910e80145fd5228a6be8fcc5a89b5b8e611aaa14c83f10d51ecff6859817fc6f0062551d9e13ee30a9a7f22560b381cfe68d625c57704b0242dfa383113ad16720466929ba109943349d7cff0d0ad855745d6162d822ff91ca969f18858a2f7a16f1bbd08ac0d16621660cdf78db38c031c260dab6abd3ce3910cb5ad120d860e4615be8aaac7f80399d2b5ad432fca810022587cb938094bbcc2488ade193122274de59929f25d728d6ee90746347b86d7734797143b9a8b6beeda0b54cbf812bd471051da8bd49930593c3db0680b9baeac2d04ca78344924dda00a892cf251e236b5e77f88be68691d68847bbbd6ac58a4b9dcaf9a337a0d11a79e8dfc33438f7916563e0ad52ef98d2e73fea0ca38e900ceae9cff76e4c07364ac04910bcf8255a11885fa0d863d04a52d29b30eae0d63f7483ddce9c8dd991fb44f17927f7f96f156238a38553d60f4b795fe80329854a0dfcd52285dfc269be765d23fe7755e02d6f2ecfc4a3851fb489158e528796a60d02d50682f65626e0fa0d6494b32cfbad990441e2b46113a40dbc40d605f7eaf7aa99ba18d0162609be6de26b62192b08cc01eaae006a2600786cac8d38527fa147ba58b4c01c80056e790cfd08bf4323fb04655be280b47d98b9721567f76b15248b09ce0cb1624b123a5deac64e4b9cc49ea36adfa41c82db7c62f4e43e8f6333c552f87ddbe5dbb65091a80847d2c4d609c7ba52231403dfe46326ced90d68a1545ecca8ff0e59806e855232f294db394b00cf7f01c4e763dc65c35c21eabcbdf3936028022c988f6e3d0dc1869ffd9dbdf83a7bbf4b785c0587a110f4dd51a1425f118784658b7291003ca8a2e1f739224124b45f148371e0ca8bd3067c268bd318de18fe26ff968603cd423c4c7dd15b119fe86bf8c24d90ff032e82a3c87de9f188c2bbd43fdbc6c9087c9a9d0737016f7c00c41be3300d9098429a505f428e38e61c89ae8dc9983c4028a8066d1422298d9fc5fa435bb6910b25fed5b129957ba15e201ca257bea5091938a962871528addefa3a3eee8e5b55b864c9a8c70310f8bbf61160d423189f97e8e2f32217a8e7e09066c2100ea32572bc45bd0d2ffe7b60ce853493050cc5cc3041864314653459e5766b007ca3c8f51ffbebcc702de10919de06e32bf5d338fe5f699b6b18c7bb261196f081ae8f0de96897ae6dd8e91e011957b479b3ff28f0f26e5de4dd157ee62048125fe450e1743c359af667eb898539c71a76594e400af8f46e42ebe364f2eac8cc89a9f3efffccef12f1217e7a7df6fee9b66d0537525a1efb4d8fa4489a3bb3a9df2bd0bfe0b16fe6510136576afec1e26f506c10476a6205c3bc102e19161410c622a4b401e7257c1092da473ecd88073db6a6bccb1d190f3953bcd85d9a2b64dc72188bffa05abb56b31f8b0d98a1c7d1f9302367a5d365bbe36af0348231a7b02e7f3ad7de6095bbd21cf1c9adef1de30adb7c8060c8c12bf0342e7a946064305ecbc55f17287b0ed566ebbd0f7614285c8b127dbeed674389f6fa58b4f2e06b6c9bdfda244ce236d5bc7701d121f734b4aea50b07ff1c2c18bda9c37656987456341b342c027fa8afd6f8290b0137721892289c75919363b2320277d35e17a592d160e8763fa60c08b79ec8a0abbaf507e398dde20a1bd6363f0b4d44765bebd18431763d83910ea94cbf0a589c1f20d8f6350550265eaa0576fb04174a4523259280cc30c9f23a4f428fc31c5fceee0609ae42af1350018a2478200097ed937817211da311308601c15972838f227e593bbc12ba35d72a9b55750c4c605965efff9c338de45d422891e8b53cba9a65c63b6310a8cf4fee3b051989827f17c3e83b4dfaa5e48c5c11089e5f026355dbee8af253da955e6d17b424d1602907231fcd68bebd665158a2eda80fc064c9cd9a85d9deb1a19a66f29a0b8b4478b6863e7820fb4a767434e85b59e08eb35e24e3af6fa8ea97cc43f251cc88930ae89a1b0a07f0cb1b0315de1198a799490db3f4e3ae468c5b69227e8e9528452b38e4f8b7425c904a832b5138c627ca12525487af0d1583695414626ed31f153342f453dd8d339851c944073dbfc2e4157ad68818b47162ccd08ca3d6406ad7462c637825b2ac66adc3da15a453f78bfd1811f6cafc927d2127488eeccf44a2f2ea9cb3c5ea304d2921d08e9c8c46574a5a94e8d5afd37ffdf70b69380d98cd39283b80bc01eed82c039bf8fbdc799d31ca4778b610343181acf9270d18c59c518b56e1c33dfee77050ad0c2b71a845ff70f5afc6c30f49aff4400fcf21ccc5d31acf34df9fd11b5556e7c82eaac104671776220870307218e272125d74cc9c96c7dacce7636b438e0967a48cbb37bcba9f3dbb110e9bc80598d3f2b9f212dad1a96119f9ef3f6f71b051be02e3638f8b527fbd77264d664d272be0d340833eb8f6a2235b3b97258f72fca84afa12862f19b28696cc72ba5e5f819f2b3017728d95e58aa916b228657099ddf2ddcc23df067aeb272766a47241ac36aed51ddb8a028ca5e66575592e23b5b5a13b9dc1fd898a82a1da297c834b2084c481bb515b2d1b798577ed171bde247fa40f8ac441fb8fbfdcb8f43949ff98e13d380698bdab4622e0fc31c4d9e0d39a8e6572d90343400b552d6660f6c7f7a38d4dfa67ba2187168875822a413839d6124006a53989162ea23f6dab072204b0e91990e3a2bd2c6fd81e5e60aaa7ccc0ea119c78bdccf44eff6b0c072c40e4bebcf029c433db48cf7163d0b290160a58018855c99be2b66556a4a3cbdeef44543f0d44d903502740a1101a679b46261dae8cc573a36356d86e577a91a7dd9ea5d48c1d23afb6c4ebab55e2f91746d13a6fb6fc8c25ff8abfef90ec9a960a97ba3cd4f2991d55a3517ad4f94b62bc74dd9b521a4b49163b482da0c4f3300c5f9913f2f0ecaeb4fb0d4677679e8e97f86fa28aacbc49679bbe5d0967bc99346488aa24243f3b370a9d9513330e387dec983a2f8e20b7cc3b07ff918197cd55627de91b49397a2ca3dd4eb8e9e4b741c322c783b5ed0ddf758c3b7e5cc835a74447a58f52a5258d47fe8d4167bb441ffc402b2a9c54e69d602e3374d49e79cd105f87756ed352ed7b6efab5bd90074e95c0189b77e95d0ff2df458fcf3f4e2c775b093bac246b129e5b6d078125becfd836f90eb920f07904899de7c437302dee6bd618aa4fcea0245a52e30addfbe535c1a508b44afd120c638590efd0578075236587f2f0af8e3a5673754aeb6e7b11380cf42eaee00427cbb14a62803b50a305d01adfba2d88e6001ea3ce3ae0b18fccf023c6154e702a18e23a507f345e1757355746086876fe599b6cc6c3b9c8972bd30a7a1e1bd990ce6c2a6a126483ed41e5aa3b1e4700cecf99e0542be0a2408c1c6a8a3163adfdb5c6cbc64419dc3da5335ce6f4f5a472a577c74cb142e08f7d9c6c045593b065600c1236f71aaf078b1d2c21f8df9d4dc4aacf6df26c8b32e465cae7245481f0c1d85cf3efe3c0a9a35d8036eaea324c482528bdaa72c24fdb704bcd5c4c83d470c4581af4585522e6fc93dcefb90a095bbb030744263b6bb96184048fc8c4ff79b25ef7e1e33c2c9e9ab90e332b15914b100c29f15a5ea8ed793ff6bcf6877c6acbb494bc24c27aaba0bd81047abb469c45d8f3840a839899fea4cd62e57daeefb94cc25f4ffde35fb204a1ea31a16ebf7239d57ad8821959e157f92ffa7cb9653d61a94a7a1141161f6988f1353f53ceb706ef15666f4e43c42cd03508794e6c2d537f7bcdc5cd90c978b09f122088933c8b385289922ab5cd0dacf628fb813147456fcfda3a2bde61ffd4ebcebbb7809fbb43e2902fad7c12fbe7dfe5fb29dfc421b04a1dbe9e8b96e100f680301d95c31c5cf05ee26aa6010f03844e17ecb926dc814e1af79426c12f7f459e0fe87d24f56b50976eff96ce1297feb0e8e31dd6ef79f514ae4162dab3596d6ac13fd930d06d18ab619ded12a6737967a82966de37238ff9e3df92ccc7754e795ee965e5f74801e9c2d6b6d7fc04f1944e86f713944f9059a4940fd373cce1e7ce3bb22593b839a3948188d0ffb4b543b1c9735e1dbce59d6568e65fe7a2e8dc7e0ccc56b4388821cdd68852289e402c5d9eb87ea6ebbcb08870ffed649b1d5d074c53439eaa2af4a9c1f9d2c211b9ffaabd404774cfdd0270446b99f4d85dff0be8b2441078bbde5f6d70254aba5121cf99ca754463a0e79b0c8c0537c8fea2cf004c2d0a546acc19f6136747f2c3ec0a89d95a08d01391f4d46f66dc3349c3d59c5ffc8ac4998d5edc616ccd7393089a68db5d62670a64ee34931622002a19e2955ea03f756e8d35f824ceeebcc703d81a3348e9ece954a18aa6e124ab04752a309ad3bc47ecafebdcad2c72bbed230e7f93f2f216f7a8973149152a0192ab121978e8992da10cb5481906949b27b854cebfcfd3bb5222070ce3022c47cf5dc487e0977c365fcc503953df58c5f7e2f260ded87a9db678e5fe07926f5cd47c68374075256f27bb1ded5fb02e046d958d7aac94652f17c300c990816bc626d2d83be8549234e9bdd3f34a061495905252e6a087b521804ee8d34733a0363ffe1f243194eb9d4dd0103a009343dcfddf0dcb9e6bfaa24e155e7eaf3a42276cbaa532685287d9ce4d7b3148b6603229b3240ced5db84a1459315b19570a31126b2545770ff2571be2ac99efeb7e431e2c27ec7340eaee1bff87a79512e0d2e7f1ea5c6936bd660a33848e30cbfffa3695f27d63b00804754ec5ea7c081c62e0b9e6122cec0526d9c472f6c67c10578803b2b386a68e73a1484ccc98708e6f63e9e1723dabd3777a0c9a88ed23872270d9c25df978b3dd8488cfca36209ae3f17b70be5e1a76b82bc0343209398e1a2306cfb35953192579da324c90811b4b1d6d0b0fcd6d4e47450e64b54988d7278e4868d17fad3332fcb561fbbc8e4401858ba46f1b0c578da8e01de5a230e7bdd6f018aa6776bffa7523ce51252d98c5cb02cd657c95c13caf8fe714eaaabb1b001f119737f874f0a23c6a8c92ea8911057e2cfe786b1fdaa4a961674f15239e45891b177c964eed7ca381151463ca881b22a755ff24fcf2344f349dec8098451f30779f6ca58b144f58ada1a6feb0a99527908c0aead4c908aac88726a153102ef6a79ca9b81099bbb099d5c5a1a4ca58445191f44274c70e83c639be3db898f5f1b785ffc85bc9fae44038e98e37219d38e8929f3d9dba2063a00ec4e8b89f77249c37673891bc9640325583ba23d1d3e65e893c5336999fcf81ca11f0f3d3fd23003525655ccb7572b51c24773c8288573ca17d62509bbda266887e7fae11a8702f43a973fd08e186df69495a1e16935d75267917ebe3211d36d9541c05b3a0cd6fa981d17acdbb7d24a082dfdda42f2eb0e44b14ab39017d558266b549a254058bacb354a50410162d9e510c3d3f27dd62d0daa6c63f68e57739eb866fdfff45a35884d27b78e3fb5cc071e7c0665cf3a3c77018d0523f210058c2ad44715066aa380be205968d96ba31b21e19944d8bc43eb5b722cabaf88368b39c99554f472e10c1bee342c659869bdc2e19b691afdd469db9ba56962d469af729671515cb5bedee2cfddfaed84a801ccab917d5fd76418c8a4e672645bf784e4322650f3642f5be413eac9fe2b8bacf21a8abc470b20e6894a7d5966c2ee0ff0fec313e9cf2196bb52d425daf4892fbc1218a8cde1c1ef20206bab18f81de8d52030f03fdb3192c4952905509fe6a78245721369dfcdb275371a46282cb9d2e893a112a0f8ec7d2b871126ac082e24de20f211314102ab7ca702dadbff136f6f7d97158a2393446e2875dd7e329a95e165118dc874b20683efe3dd7d5718478a7c594014ff0e8b98319f9c9a0007ecd5c196aff1ce310be4762e3b9e2f13b3c7845e768d1e9b935e9f2128af9f468e126efb222d845b5c8e7ab7dda50fd939d166e2525fa8af959af7952d0964b14bd00751feb141fca880091d43dcb3ff0843c4028272bb9cc03008eb7a73d8aa9df2fcf429d318c997ccf2903a26bd448e92476cf0025f7b3006ac1230f3bdce117ee4c8d04edb324e8be69b548e7f0e85a4f8ec9e13a856d26f3abb39657b27d148cc4f94b57bd67c1736274161b5547f39176294fe9bce260e797e71d0d3223fb9dc0d7aba2df0e28d8d8a83182468df6b11625a22feb493576371a0f0db4aea53661058700fac1f5935863bc4e79de0c5bd600b02e1cf9bf22102fb53691e75b1197e3e693bfc5c16f905505824ab3740c31730648136e9b5bdc72f39aafacfe0d7e3011108e644978e53f2a16abdbd44a5b19888460d5dd8e6bcc9bb64086fd49384b324203176e21e4d97574fbdaf51020aeb930148797794a6e75edf62c01394dd656a184497b35f2185f0383421b95826ba1df4b878d8390a39d3ac563a58b9414d02d7a2d6308fc0e093a3a89ab09514bb78d40370c936c6c4ff9121ffacc579988a2de9258d88f0c145626b56a9185a1b48ac43152f871001a11d4ee3ad8c86d2b1488375c4ec8c87d2516177cdee27441636921ec1aef3a1863dc6e821b01c60edf8d5ddaf660be4d316f131dc3a4c999f78ee92e301faa2f1c375b1979970344d277d1136775e0c2b83304b7e03070d87c5fd602663af5bb474ce5889dc9059d0b7c449b2855fb07dbae189c67bec32324fc26dd6fd9a2b900475413683e04afc79e88e1a0cd9a1dc700964d90ca0e08d3a11eeabac5f4b28784bb959e3881578c689f39a489da27797ac2687d1d050b2b90b45863cdf54c5eece97e5f8984186175559211fe0562ed5b72dca376b3da99e2433708d7eba386b3454176998f5f6b73cdcd9f6641354d3c8d1119e447079e5fdfe747c91cb96b7940f0e99ae8de9504595dc7164c1889e7eb65728a0ac6ba00eee12cd9b4cea12bd359aab69691e7273148720149b2c213b89931d2c8c4ef9cae0842eeaaefd54c9a0f95899de081543d2939dbddc913a5d5f631bfb86c03a7c6dc4c64933c78390ed6895ffa1426ba4ae72a8d36fdcfe6ca3687f4516e6093d7ae8b5ec565a36f9bfbbd9a6b1eae2a22917c8473e5a89775c46cfd652d9bfc6e84d990f9cc86fdbc9c4abc001431b7db9ae06eaa18df7e6b576f7faeae2d3062ae0e3b7a2e7ea7ebc850c06a4bc1db7577792bb42b03568a240a5be793c4428d9ee1bcfe097a88e2d7a71f05ec1288ac13abccac9431c96f99f25f8972e8cd476437d574c8056eace56cfce481c9b609c01c6279b734678c5fc7ce92d9ca2a863ee5a254fd996ac190bcee3f95110bcb47802a10ea69fdde4598a8a868d134297125277e7fb045cc57409836444a7e817cd43528c770e27411182c8f74feb24e7597856fa5f969d34d793475573d598b9cb8726873675fa33ea9c3832bbc53e428ecf8ad5356408d1075f07a770a07e45f8ba768afcd8e5db705d4b42eadf83f437e785bac13e3dd9177a5b8214853d53dfa040138bf3c39301b115b84df06eb42a38d20a9ebf7cac3d9d03d8906c1412a1956d1096e8d5cafbab4097502dd41ab1a1f4f20131bd458afa8ceb936e5fe031c95882bc9574c3036db28affdeaf928f6240094497cc7cd5c23210a587f45f61e8a24ac639798330453681fae551f18af513c25031337f63faf2996f58f69786479a68fea701bdb7d047e1fdd6a25bfcba50e05ab6dde124d77874bd1626b5696a3c47b476e7ae5fbc3d84c7735942495232ab55e6455f7007fc89f133ce81f37aefc8a1d0b59e312dc8398c304df1d3e2c8153e4bd0205297bdb70bfb8c666280b4cb6194272c2b496553d3c0c947634cf646e24d765b143b1aa90cc76241284b8f6ea27def16f233e58c0e27b3287fe7e48e43302542658dadbc501c83fd08917d3ef744b690d5fe91c58e8302a9798c2ff9582beb6d4ec1383d12aa6c370698442ccee3304d802e940a19bba615a392eae92aeb6be0d9f29e89b90b18195e69c0272198bf0456e6b7c16bc54bcfb8da44d00de6b6871a926aee162dc50d36c0297964aa82586afab4abd23658b3d8758579ce8375370bd44ffaa8714966288f4c235fe5adb1fd599b47369fe563ce1dbc16a2ee9f18b304452d0c9a4de708080e68a3761ec2015ce0cbe70fd0f9b54e4a0479f4a14a4997f9b2c316f4d904c2a6530cb256dcee3bb9fd912211203c57790c1642543ef1162159727ee0c9383210ad85bb9d2c65c2bb55a888dcb7d8c7b3a8c469dcea048262f274103e0b609c556e5b95f4bb75771fdc6f9d7b7f2c78ce55073d5ae90f7ec4c48217042315391251bb5ceed7ecbf746a8bb5ce5ecfa99427aab3487cfbacabd218294083a1d1abf4808444e4b3fb3e8ef9247acba379763002769ae8935ec9693b82dc282c81c3f9fcab8ef2901818c253952a55ec28378226641ba7ab4c803f20db45fade9fff4b63781e72a0a12cb0a4b3cc2e6dac2a11a21878018f8ece0ce4cffc06e458e2864766430c793dd7cf492b6ab6556a4307f7ea03ec19799ec2a07e07b0208ce8125a14ffb3b4d355962c2d5f317219ff24a46556d8176e327044c6b24df8002dec891441bbba48319b666d00d869bc6cb2cc044ce87695f214b0c256b05fb4e596de15360f0ff15cb528c9574ba3eaf985c26c7e4dc001684c1cc45579ea03f223b5cb334a763cdb6b85cdc57c3ef71d00a8c6233ec0a271036a7e1e6836c0bf677274baa7036eaf8dac1cb561c20c6aaec49483e5b970485b3ad508998324e3c017adca15508570cfaf676797c11850fd798160e6b693bd3dcaf599f0f01c2d864af90716ee6811e60ab1356999f1452381154054f3c734a3ef7e8e9bf755bd757f42b943da4d2c52de6dbdf476f7ad658f9bceb9b023b494d91e64876260f38439c146e9d181da2c5bbd63310a484d60baab3b7e5af7653b72d78ed683d2b15a015b310cbd6f34d765af348abcb4b3ce078f8aa48e1c510cae882d3d23cc97d8b4f7c8a5c2f77787d181930bbba7dd578dd2dc1259ef9d79b8d41523c77322a7992c2ca190544d0193ec2bbe5edbf26632245ec9aecea69e3b683f0166ddcb2534830d84d7ad1b307eba0d44118ef9276b4622acb0c006470301ccc3c57d3bb3bd52120b896dbce665a8a738e30736b7b0de5a8e5fe54385ad591be7c0f842166317ee82e8bf78909f2c81b8d9c5f91686c555f46cbf1bea293efebf3dce798437c65efec74f95e4166e1363e6446f6424c87c029bb5ca97b9adc43da105e772e35ee53883f7a0bc31598c35bcf84ba5d8850919bbdd84ce9466d8cea8b2974f2bcf9e3ce75f27a63199524c9e58a900385dd65c7a7de9b0b1ed02d801a90435dd09051ed40feb1076fa982400e017f575d9770530bf7562c7ee98ece13667e0ef368cacbce1527c1ee891f9d765b6d59d54d7e6e8e789a517666c1cea0dd9e1f077c26a6bccb25d0d682fe0637323412ee90abceb43a95b5353494147e5e34fcddeb04dd66b08014d32a5613cc0578f870ba85674656579795c06b170e41d0b8d033ada9f9dbcff4ab3b7ab4d5000e9090e2ed2cc4d82a05fe3d01e7d5385ca8243382d1913c53cbf3b1b00a0ac62a4434b0a7fd0408969cd5c89a8e881682e832ae29f3ffe792f57562cae96052a76b556000bad49c1004f1c0569e9de426a8572ac5bd0dfb6ff1bb996d61917bf4de3602bdb585ec28906f483da5546d211bc7700bc8d899702719a015b1edd64b2f07af12f58534f792cffac88dd52617aeb552b1ae932991280124b9a277e16127f4f47a5204d03db1c6c996af3a45e4c8617630cba353653a673b78e65a5212718127c54bbabf7e92c9940a96f6ec15176550ff2a132fe13fc0095f98bf6140a5bf14a5983cf80c735090ad9b3b86fb1027959214107e58215b81c29cc9c8e2219ff1c96b9630153dc743b77b8e0c24f40fcb0f8944d6c95e63a1b32bb71512ff1391e32d35f21ed9d8fa5f5efec222feecf5d918ac33ddf3cabc731fcdaa8b3ce5cba258c3dcc10bc099fa15ad7873ab448a3582fec5845605397dd68acd51a436e9fd79b459bd15456ee566fe20d75039d1ea6f6c11a20d152ff553bb83fcc7d5f24d86dfd895dc23ef9e7197cffb2fde566eae1bc8d5f74e97198543cd33c6aa591325a5cb7d89ef71ae518559119dc91133d58cec2b305541d0d3cb5543b4195a44585d976cfafad7fc77bd0b49827934ce6f267fea9e90174ebef917d3bc9e2726615bec364185b261d74e5485d284b252206000b07b8d393c5253006bf59d66a4e33f48dedcbafb953de15261508c5a3acbdbff2760133d2e09eef8b094d53d3c3a34e738788cd84f9679ea64c733258e4c263889313b97467d376c9b94cefed8c34046c26c6154db0c35ce1f7afbaa9f2c74fc4476b2d6c3d8dac2c246a686217fabc039ea9bc7dbcf091b23f6b801b6ef712e045949bf9049b1c207320bafd9a1b475710cb29611c2e3efebdd480ea983f162099ee4cb3fb79bc9b3b26cc8d09fda613be5f8b6bf5b5dd930b8842a9639b3936b849c432f2e22f0de191cba98ad9823f4703c854125e798aeef45efeb77e8cc9f0d067565c05cfdc232191e46d335bd2f62ec36b8b0d75cb2e9c2d5354dbdb802d4392c97e434bcaf4cc7584c549bc2bc8f57da31bdb7d0229e5e68775c76043e95699cffcd7758eb19443426a9b121abf6ccdb75fac6acd8370a776001d475665317a113fccd4eee7534d2d9be05e83de4f6b5971dbb8bfb6d526c7b427550b8cbd18496ffc24f975aab45953e0c0162da3814bcce514b2029f5701efa37cfb5b58c10395156ce42d51fe9cd70d1964cecdc8c534a9ff9643529090e3b8d819dfd62371f014834908a5ef9259b4f8c14aa113f01b28391249c3365c67e6b99745320da226ce8d5b06459322e5abcfc787ad4933d3a8fdba4ec6bd80aa7ee53157fbdb0a556e16dd7577abb9e1ecc2aef411787ae489032e98e65a0a28fec49e716d7473c89c91347e7075609265a1076c53e76d432b5ad4623c3d277f33209062f3992cde494e638783c87b030838fea05336254df2714b0c27c7ea584bbdcdc6c204cea9fcccdddfa57d57bd72c99cd8a3a94176983aebee007435d93539cf79a11b2f274e993c7e0811c6ef533298a059f2b35470b8fd975e9afa0c426bab8999006e3e1ac0dfd6e00d53bf03d616a3241d47a8ccb7b357bbf6a25370491f1c9465b756d371053c45bc585190c55ae65b1f0e6d86f072ca27bf107e05739ed490995b6cc9fcd56a09101d880ea5dd52bd0b48e445537be9cb8eaae4ebce162e2c62a51d773f5fc0fc82e747313916ebddb51d52d5d8fe800b4330cf295e726556490a727ca0e0f201f7e97085d3d1b6736e3216f1c715163b982fdc25a8e656fcfb04116262829e539e647c27a5bbb86fedb7fdc369d8b273f935e476e32e45b0174764be4f75ab17eed9f7778a085203b3aa22df5f363c85a6c25b7f40422ca1a4338f3c4e2a77f4c05064556b05e6ac17a0b9b1119c0e049941e80e41add4d3827e0fb06172859e28fb847550cc2a4169823da2afae7686325eaa3685c21d9517d3459357f1e1c0acd3aca0797daeed5fd7f210caf8817ccd2221ba23e4bf9a242a75ac0c58926d6ea149eaa73fd4048919f5b76caf6c79b8a8042c3961d1976bb5fd6e31d732f36e154e726a95945cbf642a64790e30327df9c7bbeacf6c2d81e86e402ce50f8c4879fc5dec2320e6def66d76705c16190c90eedf0a44a75871e189ed4a6aaeb662fb17a87ed577e84b91d11d4b58c7a7aa2f750e73c94ac214ec710248f74009b1422eb7ceec8eff699145374ed2b30990a298e4594ae341575c6c8e3241787321c541a8fb2346d91ece736445a5abf1aff5995e1b364b6e58f12f348e71806b1fc433fe6dff3bc57f4f6986ba748347a0387ebcf7b8df338ecff41cfd385b8db39958c7e83c5f4280013b3022003e9e445b52c9b995d6a69cb42e08f1927362c9f5ca00eda8e82386cb16485f69b1653bae19755c6a98fb5dace3e0357c9267eeb4370d6d2de0b38467dc45618b6c89685975147fd75d4f51ee6b78540e28fa859a400cfd8bcebe97001215ec373fa313fce0db832bd116918ea6c32b32ad7bd34aca102b094a024b54758474f07d70cedac6fe51f9ece6446d1a7706eb70cb3c8482deb7a310bf9b2e0af6b456c16ac8e278827586db50cd305f2463fd083a85c69d41b3a890a7fef832084bd96cffe877d8f8d26dc173de94af3314003d93a3b7bc1476c498493767e6705a1aa8a379361544a528af5d22d93acd5af5273ebd95092145b51878102e21a394a1b1ef9c61f07286acbefac92bea855e469dac5d487c137324d4d39ee737046bf03118b7e58fc07a4f6fdec83cd5c253081a0ee781d8fda437c42abcdda7d11a604742007fed4325688f1bfbc83c6d092f0825d5ca6f9a99b2b83cd82180a65c4114785f9631d77c469687acf33a7b92cb3a0a3c186693f151f3107dd106a1c5287d55dbd0dc646d0b9c8f85b6d8975e5f48f1d5e53a362a3b9de280d1cf6b8a6976d554754a9da1cd362b321409271e4b1686fc799a1fbc094c2d5e00d6ae83cfc5ad150135cfc83fa4e2943be4306b2a776eaa3774ac5d0ecb91efcf3b4735076b51effa6ba0f9b70ba01cdb46ed37c78807ea551275e5707aa08e173c755b9316890e58cf0f7853201ceaeec114cb3952adb6d06e966fd152f3fd3dbcf9a56f00fe82e46f7a7d8320fc685144b17ea7febe8fcdf0f3a40244b62e6945c1feb7f6f22785e58c3fb3fe036ad2c5344244f2baabfef84992b169c6ed96898cc170070d23333c9cde3494ebc5f91e164069f423dd3a991d67a9f3038dee0eb3b58a1e07dd348cbea7ce02cc56d51edd41a7a638c1c97148fb8f37dd7177f8338304de63fb17c916db46e0f03afe3b96d8170d68add1962c583a098fc2df172b4acb57e087267e6d701bd5eb57cf9ad6b9d081b84b213d8eaeccdef5c0b5b6679f073fd9a2fc4350d49de2aa0466024f373faf634c555808c83ccabb5d41b6c6681a8791ec197e68592ef1cb9462903ce3167842bc128476b17c6d4eb03a7eb2e8ab84b2eb000b3f14bbd9cb0fdd02e357a79100cad57862098edbaa65affd40faa9b4ba0792617221ad955e4e1b4bf005ee98227b9c089f94a879b800142d81b3a170bfcbea3da4b59bd0e6aeb43d31f9301499681b760178c57e65fe5b77c1a24426e59bad283fa7bce2146cee5f5d89c998533d105135be92c505b248936e307e79b80ad62056bec786cfb79e41433086dfc9730b29a79198e33c611daddc51b04c33750bc48648ec83fc2a4dd9cdae448bf55da99aad82443babaa2dd76124db9f711db50ce33d34d53c918eff57ddaa3e8466c9c44bbadaa5a2a55ba6e47c253e3632cfba6ff277d93764dd4ddcadc214b11f12519897d5a3dac804072cb3053da416046bf1fb5ab403b526a6f8e49fd20abf7af94526e629a655bbd91d8a370425cce03b32e2c8e6b66ba00a1a4476b45a81f8b8e1fde69688a2e17bf97b5f452ff9415b9101f1b476fc07eaf7ee0891489ef099a6329510a61e1d3902dc88ec9518d5b545792240962ba1bf763d5415720e2d7358d9aa80aec1a4e86ed40f46cf5bfa478959652fb4ebb77afb96d35e84e87ec2999cfe7a59a89fd9f650bab5acf87273d92b8760b85f4ad63eabbd65b5424ce8060859faf81ec0aca580289ff92666d71cc67f7515d84fc2724eefabbc4a9044c606b4f14869b28e17b991afae6a663cb5e8ef2215c670d9730e1e0717460f202166a4f0c0160818884f8e879b4904233639cf752b38f51a7d2358658a3168f635f1c50254f584ccbd70d767c42e9119fd0f5c246cab3c42200ecc0d224084e54cd748d3438b9b2ca9a1aec8b1e6e8880862da164cc2eef56c7a3fb3951e423b6c8a68511638438fe4d13cfce027be97c6e1c3547fff959275af22b24e6ec5611078fa6c258454b8fd95b9cf52cf6d36b2e9436533b8f2036f367f633febe8d2cb072d2651b96421e916de8c113ade9253d811b3da2b10d5036475b6543f4c09dcf518ec51f0d9ec869580123419ee614c4e263616ec10d141edbecc81d989e732a10b3135fc257f4b2139c525d8c4fcb4014c3b1fc8ba85788d76ba94d0839beb60590a1e19bc3f9a8a7199ed8aaeafe6f6297ccb286ed11eb2c8b66422414f0b3c2ed503f45a611bb473c3ebe5c1c2d8fe2b145e55561e6bc102636129c5488a01b179839fe79d1255002dead96674fc2ca66e4cee0067dd4a1adeddc822a47b423428b0641440feb1a949934dc9f4afee7935cf3b447835298199091249e4fda7c647440ad8031dd2293183880d3672a6278c8d150901de45938f27ce7d71830c94b58ba79370073f649766ca1e0042afb531852f59a9c8869705c16a7006f3962e80a88629556d30b77d7b267564c64f25e57dd49447bbe9e9572b04a7f26f946fcf4da60bc0e44a39629cf6d4de49c47299bd561794980c5432a5f59e91aea768ccfc8998adb71d984a79aa752652ce19f8786899edb08968deb2719f0aaad059ca1972e96f764efe837004b6da52be873ede36dd5705aeb6144a63bfa8c40845beb9eb921031b2be988bf4593c9f7ed3a1759679a5dfbee72797b290ed9a30a9e002aa7a86e0d2bb582f5a6dad9fe7b64b8be048af9cf5c3bf2ffe521e63d2da32370f13b90de0bf03780bd1ad2ddec96ace90194b6b8ea3a7d3acb43837ee7ef14187fab6432537e0be6269f7ba50312819b0305d016ae8843f41e3da42657414e0a86543c753c4cb8031c9ccb23b4fb41d45ee76de477dce8b06faa9f54bb09b963755f6dc1c48f5e1107db6d99858324a878199f5577c3cef21038d1479763da1c942353ec6585106d87865aff571ce822cbec7ebf46b1db5dcfe5ad4fdd7fc7e3afa0a49e1e4a16666a41fcc9041f0c89400ff2fcfc4f828fc41c595e4ddb920d3049f535e1ea3461274f29295a3e912bd32a21ff94d4b8a25636f29d81d74f8bebae9d315e9e9b5b14b5fac9f8b7017877284f3cf71f0a199c6ac39a1777d4bdd52e9099873fd6e0e054fe4e9900a64853cd18b13411912249f8f8a6fc5546f0bd84d355110e23dc262c26cbe33dd81a138d8cdf95036c0cc4b9f140d1265d46ada9b4ab4cbd36ebcbe66236f0871df8145536ea0bf2f3fbb3049beb632501430962b58bb95cf1aec725575e3aa202689a9526f4234fc5982cec266ad2d545a60c5d7909d6b237575937958ac55af9df5f3cfebfb15ff83a3576252d937ca638ac96fc2760844abc8930c5f574b29ca6b13b434d8eeee255b393238b811f1fb7bdf7ca7da171fa0b6b8cf662ed85b3269d503ed1e8624b95658fd4e4af05d75770ea14dbeebe5a64fe9e4974f1929db16a4cd8f2f9c8168a92afdea2e7f41317595b72544bd820e82c1e0c8554f7c590a7fc61c9fe4ac02c5fb6737cdab5d88bbf6e6425f7691ea8f655b977e3964a3c52a36b54a350ceaefe9f54d03f9ee0ead4f13bab30b2a2b00f7f66c6c531ffe88f830e73b60f4315359bee7ada6aa9e2e2ff3af84a1f3819936610125ae8ca401262c937dd020aa3d898c955c161743b9121a86df0436b26c5b86ab1c757823be11ca4603fb0d8af8a6b490c35dea3275e70a148ca1512131cf39bedf3d0d39c492a6db36488729d55afe06022d884bc02179b49f32fa2069ec4239fac05573f436d204a8fa7cdd474835ca6494074104c09d68d3951d9d2ae85b3fe1647c0e568220d7e315f2cb51baf7375007dcc260133605415e25996273e6e93e4dc944be95978958870d8d254a7693990f6eac53934b579f9dc775af5b50327147b1e89944865f12ae1b07cdf2369a04bfaac858e42e58957c51c57f0c72c61fecad0fc9e7087ab26d400a9c1f6f09d4093b88ce8979938553f65f17a9398ac83e8cca6d31c59496e415d695c06b09464eae93c75a420a2a17a2c37d20b6f9284489c3d698a06609f0c91132c31b05fc3dd8668ec9aaf6471bc3c88e40bfcda8924762e4b7daed0c8e90786dc905fff9d559dedd1a08960d56e7f94e2b1a48962d5671bf841a51050013dd59a0b60f4796e577fe65d400a94408a8a0726e273058659c0ab321b8e3879f70640259a9dfa9fcbff72d87e66b94b88b0c9fba0c411728fc20d9ae4359bfc7abe8e82e67b9d398fb2c31d2b6f8cab3106f4ea478655ae21988829f7a8fe9ba12306ba843d09f48eec5321066a7284352e15157c98bc7a7bec5a5ab13a1d7a85fb2e3fb349c1542f57a49d09e2a8413b9f9772b241138e2bee7081e5d5e8e7adaf36db9af924b13194ec98b6243df05395aac02f3b404c378987c16d43372b40d45387d0425305b3f8c5f145766da73a9a0f762d9d5634b6eac474b6b63d98e61f2ceeea2ed971bdd72f56c29595713a12770359e4b70049fdc54a9e36c4c4422107f489918d6d64759282966349483eade81bf1bdb30af1eeb3bc6378e627bae41db58f4f2a3d566aaa1a96fecfa1335f6542b367934bd364fe4588898461797ee98c8b65fd68019bfad208c894acbe6912699543906de5759a8ae6f639378964cb6e1fa235aa53cb0b5b460edc88094316edc5511699ac7a69e21b43ef5034654db27f76dc716942262ccfb8c219a9443a1f58be71911b98609bf29fc6924bae2880f7950e5356af8d1f1598f8003d0affbee6dc3bb4fb3a65841da9f864360ffb2fc091eb9a10c0cd78addea5c131674d9b1b8e4699da7a6c3ed5a25a2da97ecce256ca5e2f84fa932a55e55c7364bfab27887b105a78d569a3a596983d89719be1b1523bcc40af46403102ff3dc6a226658ab35de405e53c04644e3090d01bd3b31b37af319c466ac476ab44a42317c04bef96c9121a82dbb70e6715413b81cca0c24d0338bcb437b324b053e851f3bc948ec041fe3ca1ddec2b7c9c6cef1f1433ad17669f93a78a0f1fcf553eb9eaceeeb9177dda9e71cddc5b499c0fde7a11196ba475da8609112920dd54e63e8da62f6c843d5ec1b01c02df1ec64befb651862f63affb0813664b26b7605806a558f194aa12f5378843ff96a73842b6ae2b743a3fc7dfa828eec08e101b43304f43ce353a3c0245bfd0d9385902fde4723642a88e420a1a1aca29963e8db5c6a5ce86c235b549bcba31234d295b01fae0ac48c9256255ff203f520eaabdb5083488047f803d447ca6c9cfceb7fe3d2d7484287e541e64107feedda3a022ba505a3104bda985e09e9a97ab583bbed524baddb2e3e58a8add5d3c0f71f274090f27c2a4718a884dff41ac744612a84bb31c0a4a9574bffa4f06dcf4aab14036dbd4632c29313db60699525ec99ec31ef54a267cee70ab182b32a6a2b2bfd5dd8be2f442f29368b3e39a08ed5af0c9fc8d9f71a65d2e68486009dffc0eee36edf8712f4981ca3394cc9ca7b5f98ee7426827f7d69a6545f51946be0a4e28c821e70afbfa525536134c6989a03f7f11e82cf4d6f8cc2c23bcc756f146d5191c64d80119f5ea06226e38bc0f9f8e686c7f4f606bfc0aba20b4d9a50b2d7cc593aae14b10f9a2065539dde69c75f835aefafaed7418963e5eaa993ad5d33963be16bce8cfafe8a32b5eedb7d83c0bfc7d15d50fb99ddfd6ff5ac9644483caf916de6759e39c762e8f0a215dc46a47fbcc0e6d2348977991a5fa33923389ffbcc145174c36ff684981cd13ba167fdd7439a5ecd7e3b6df25c39950f9ff145a3d89ae63a55756fa184010df3baf7bd7c42ee4f0efaed9f9858a4d2527351a3bb3bad5636d93f05773f8669b08ee0f131172a0bd9702f8d64b87c515ea6ffbfe032f90973c5dd111e3eee0a270f1346b53c0fb1b0444b144fb4937f902f72be8ec250229aeaed52f813ec0a85ca6d690b0eaa470f1f1a185f33da6d3f7430a1fe395944160b87a93f7dbf35bd22c495c1f51c8de36c25232c75b7dd2645cb971cb69bf77650727b74f67da161d2df88dd69837e06772eed691236f66a0fbb4c338d0d892d304b04fea2ef1f9b94669c6758478c19028bd8636b67d9d37a38123b2553e718599be00b0d20f696deab836efb72baf9da1df0bf8f4d6f8d09e54ba477d72c2891ad2b77f941c41cefa8580fbe10e7404f60822c86989349f033679f61229fefb15f56fec59357948a393842252e21f6e714dc50bf383ef8dbaaee7363e849efca21572da619e0664e84bcffd33d8c180eaf327b40dea1ca1d5f20ee0d94d20a3a6a2f0b7ea8c3d9dc4780086ab045894d7612f2c1a12289e547fe50194a079b531899b0d3d14531706be4aad050a4ac9a23d370fac8a3bc0b6c32556ebf33fe4cdfc0942a5570f30b20026c3eb148cf00b0416e3889eb4e9f1cbba776eea22efaff5b06f3bbfd06e60f1c0ac024aec55d3895a398774eecd500c3d7a44f991d2ae9b136c68e15256a400b4067d613eb68c841c77c454c9f96448bef31324ff258a5527b09c52f9f8bfc0c99813175f9a8feebd2a969f5a8351249dc6a7fdf51277626aa369acb2180405ff7a1f58e13ef92fe556ffe434363e1633b459ba7caf740f02584c027a2af956c9521d2891eec45275769c4328c91963f1646f5aa3112c851adbdf4740072164e6446a7f2e7af34d06063f8776d9362bb296eab5097fa2c385fdd51890a5e987021190e97b56a076a81061df4c0144f776d260a56cd89a5b880b590208749081d5784ac42f19a951fbf7d63ceeb9a5530423d4622fa824c3346ffc8b2e10507b3d09b01e936894a5fcd4f732d994472f749b302fa197063c4c77438b4b83be2bf266f12182359243f0f0a4c8a8e1e4c83dc65990fc60f2c53f5136c143361692198c450b9704dbb11e52cb945a6cdb45fb17182510e2672f5e67dbb382680c6998b3f6b7d69a46cad105a541b825a3fa3263ce7f9b050859f64a67a76700d3fcc33fc30c91ea6a21ed85d0835d515b6d263025b93c48a18d0ed670b80d3c7fe35972c4d0f1362453052bcb2eb156b3802bdb41f9f06938ee2539a049c14f009a8e2f3e9ceba4d949ff1504f16760856498f6938997f122c29cb4f7c46ab5ada7b25e2ee316a4c26338e272a0d4c276ce6947185124d629c8b38f727d62ecde4ea03d7d0c45b6572f158e2d41f4b1f8c580c90412bd85974c8176830051ee2984a23c3b230ba6ba56c19b0ecfb18fee1f46a9ce6b66c478d8f4ff07d0f81290f289cb46450bdbc4c879852743ac7a54e6ea36723673fcf7b476724cab789e8dd7ead9877129722964ac29f85ae5512d835b8cae9b4d63c028df58391dc921e5daf7ef045da50a9640e5f2bd841ffde1973e7fdcd428f1f9196c1a51a183fceb3847af90d4599ec803c77bd6eded695723248925eac1ec8492f235f460fb991c409cde95fc3d9d5a9983a9f24ff5267029b6b694c406bf8ba8601adcf35000f6f0c9da920eae383b7797dcdea8d38b44f71045c6da88c28eba42a7ac820afff448b0d8e1d27e942f1e2fd02b7ff11e86d0ed2801db0718db8f17825b115baf3250a1bf3c87ec0b386715a765fcefb532c04ed812271da786bd83d0860490940af94408ced103e51d03bcc7034396e5fdc22ab937806435da4397cbd04705ceba9b4a23e60929da0c57932c184c92d651be7e2a28ec0dfd893e94acf30f1e3eb07a292ca5c836ce749923067cd0f9eb1a6238732f2a0dbf8219f415a9791f404e63aba0c49d3ee919b56ac60ad403b8a00d6564ea9ad32a6c2aabf49d252d1c35a69ccb2417e67e0080f19e53c716babb4e1111cfe5d5f4fa3ee54192d9dae6425a1265b83fce81b21b0306d60dab99ce49c5d486864fe638bcbfe655fbda0c5b979bc01427de362929b0d9a3fdf26a4d727bfcd48e67e39b38534ac5afd614b0532f73775358032b7111f9f3414d6d15c3d50a443bdf0da9b329c6614c3555ce888b1518b6b06963b100abc18f6bbb58c21fd0d958e3f4911a29275016edda59796a6195780522e4556ec8081157fcc211df885dec40b8beae5e28e4e7b9cb7c008464775345fcfaac29395e2146919d2423c3049f0c75a9aa554cc0c49c2b806406321724b9110c44e3506ddac5c742565d8bfa818af3bfa143d091f33ae1efa818e5a901fb7768674a97ba3c180fa893056d99d6b0498d7365b2753d67596b4abe59e0fab7e160ba78b1a0dc3f7a02378a00ce27b824bba5d812dbb92fb662cdb71877536aa4214a7da7f5f57be642c87330967dfbf24059d4784de4a31d83762c489bd84ca3b5c7809a55180f66869259765f12b36b8df778cd5c33097b7fa9b727adfc783d925d105cad556257ed3f5fb25d87451d3a8e6f53767361ba24abcb0625b8a2c19dc1cb27db5c09d27f9b4f88e7858343e32431e3d7f4ae306febe18c9674fa86dfa3cbea9bac6178d8e88ad2dd4902cf62b2d4f3d00c1cadaffec5508da10a831de6dd8366ca7706fba9cd65b8009ab42e47e77e8884af6d8a0dd1c46043f5cfad95e02ae2392014af350b83c940eb558f3e97493e8aad01f69e80d25955fccdd97e41e2c07344081a9205914920cdcb43209e19d06904d9d86eb05da562d32b6eedcccd2aba50940d076f2e6f2081168e7597cce6a4dd682d751255ccd58d400937df75f6f7c61a5c6f52458e2eac61fa21069011521eea2e3b2901e567e4912b0a8d1e0bf519fe87893bbe34749a0a5c577d1de305c4220fe1c1f8dc16e604bca45bc5bb4c11afd9140e6cb235c4080c4e14d01b90b2d79d6a2da98bffb6b9295cffe70991e833d0d82eb9c28294b8c24ef684336e4837265b6ba9833e4dc257a264655f91b4dcaf0f37f70160e54bddc477290757c73ae0d3029a72ae7dcb5090824badeeaabaef5c7875f1290d6e2fff8948da9eb2c4b95e0d57ce18b0a866db47a217105552b974a9081ba564d21cb03de84f7ce63e6e92945c35a28d5ad2370ae4f03efc7b95931566104a58fc41c6cb98a98e4dfab02ff4170408643ba52a29adb304135cbcae9029359840f72900bf1f91511627d3b7d2de9283558634db14756a5daafb23b83b86d2f3bf6adf0bc7a02397a2917aad08525734d7ebfbb2e5f55f5cc0dff9a82eae8b5d442a0776506165c7770b07d2a3e60ca030c03f75026c35caafb5c4d021cb162d8c1b6f01418fd67b182266ef720bbf8165393bc14a601924b1ebd14e83c8e1952d80ea33fd38bd19835e8234659fc1d569842d6e905630d1b9a8002c514f74549ebdae30aeccf46075b73e32f2307d4165ac939b693decc7012a49a0a8a32ee6bf1f2911c310ab1ad1fd9ca787d4586582977b13ab202a1f22cc7cae5b1f582c652053314ec3cf9eb1c419ba560f19cb96a127b4a6fe522eabe7778fea67c58e3d58d1dfc261b8c5d26ba85fe6285a89a677c0206d37ee8f7da08ae7ea3aab6d16eb4925de4ca47b90bf031c56aa179aa875d76cd93530ce15d232c5949708553489d4cb9e0492598104367e33e8e3ebf8ce8b9f40e8aab8b7b7ef8cde1417e58d712b79f84dd06f0d3a06683718d5aab41801f68e50d9cf4a3e13c16478db24b845d33c922062599b853df55a2d66b551f317bc92213e91760091afe86b1cda8310349798a942f61cbe7a04141ccd87c24186513170b5b72fa80e74b13faaa697663a594ce26ad281d2cfe492e42069450ba41f10e03eb7b87972af77a45e5c9c168535e20c63beb582c578169191e2acb6207b0a7e20bcacb538b78e62168778187f1cde5b59db4135dc42aa12c76edbbdf1ba2b64bb13a96ab8ca85e4c1eec93f19dbab8ecc391bb6e475317c99a4e8ac9193a5f1eb5a1b559d8bc22557ed29a24b412153966219764311785369c4eec583df6d1599712a78511dd52faf69db127234536aaec3934cf15a759763ca7281a4cf61d422d77c0fbbc3ec48592853f0548bbf52179907c0276ecd5057577282dad19366e4fa249596941fd9f90ab99de9450818b0779c059c60338bdbfeb8159d4e05979ea218f0c5fe9f3c945a6eaffb5d7ec3ace51e6dd3ce55ba4f094c42bbb9e6bca404f1958235be31e1744288fd750a3d4e2e4a67fc651bf6569e13c73ebbcbd7fed1ba5dead774148d84494ff08717d2ef2804aa9a8e4518933f8c1bc35710d409b6e6b5596c1ec1f8e7104eabd6d097587af2b3e723df2fd9a0a4fba3751575e63446401c3cd2dc02b9952c7daf1a5cbb9788c54746fea03819bf9006e788a99aef24e6ebf9381bfb65c117f429422dada79d833bc75df5feee60f9d5ba6c30001b27fb7ceff07d9c0cbcd317d228ac85b3bcbd330d2d38ed6613669f6c17228ec21d56867c8c838f442705b8e33ce635d88e0de8113b5bf45845dc8169095585670d2ca57d3afbbf99cc03481e68be5b751549b32b0b9673ed2e570f71dbc23d2d223ec1a144412b5571c9ddd15a34c8d0e8f5bfd1c23bc99e0ac84a48b8eec1c5707ec99c8a9eb1a70569ac8b7bad5900e73a4404bb9ad5518a9677178155dfc2b74273eee3be36cf2c24397fb33c74bf76ff2c5e19706848dc1e4dcbbbf25b0351c48241f8e5c6bd00c6995f93498d604c958979878b47ae203c1774e7674b831e36af6ed4fa2cfb9a07fa7ccf5a0c5516e2b38fc7e5a197bcf18b614e18be65de82ad1dbbc6759ed39d1375344230ef8deceb47a04dad5ed7e1342e692fef041355e89b2db4061c70f48828a6d20057bb4be81c35c9d055e5754a8b3272c1a2203986c148903898ccf43ada65a00776bca6664347306dc851f8df5524d9680009b0822ede61ccbb5e2f2b8d461904cf61a84cda427569704edad65bbfd9fa7fa85e2b7a0ca98947b89a5b6d4e626723bf9783727f47978209d642b41a75bbf768e54e76203e36661d511812765b447cfa2a07a98c56efe1d46c6800a96ef5a254c14d7856aa118c7f29f8741d1f41a73699639f48a699ac690a3829c259fc08d2a336b91641377cc411f19ac7e77f482de2039971bb807c8cf535bc21a2c89577078b3c09290d74b2e00ad9a5a2b007e9dfef761ce323e32db5d2a6d271cadb6a57667417c36a2194fc97071f6467a76670b8720ecf005fa308ae0373d916b6f12d64cc981b8c4eee44f4dd01f978a4338efc7b2eb09a706fe1c0eeebf72087271d6f4675576ed909ebc04cb9b74f3d38ff62206cf9d851575dab7f1c01463eacb61108737a2158eaebee57354ed4dfb69e5517295644fa6aa8296fb3763e58a61f82003069c2277f16a6838d92da2767c2b85b30475615e1f7d40d330d2746629d3324afc1c7199dcd8c48a79c2cfccfe8f729e29d3e703259c2e3cdf1cbf490ffeabc996e9b451b2511156213160f6e9816807da23b87c73116b5fb30ff26d1106abcd5851c95a2d64e06b231038554571b22361245e7cbbd60bb82b808af96df063f72a48f3f8c476d1fd0f5090d6630c077ab77f8a44b1eaf20fc68c4716779cf677fa9778969640ec25dab2b04bcb4be46b876401ac3790db6f916e79c6bbf9f1277516a1e4093dd44d7f84782a688786ff938e0e372ffdd3d6df057a8e1ccd29f5972bb39ef3ec410964aa93bbd7bbf70f6cb58465995d68b1f9fae3763bd252f5aeedaef7882937c662a4e9784bdbda4ae035e5319de5f5b2f47c64c53d7f59b6c650a29c68bb4533bfd8d1b4c0a40c058962da5b33a469d482c68a438a0732107a4972d3751357b4438aaa06b4822756f8eaab98307bc3e9512935b0593d0e29a55817cc8376f2294fde71bc27b8e9f757d534c4e2df6717e1e86c5b520a4fe8585bb87276258be14768975064480e9418cbaf2221010c3afcb7c816502e9a262d7210097a91e99e63c426741210d9779156e1354082b9533d21bafe4903702f9d1b336fbc968c1e01a45aeffc9497835ef30567eb2a7da03e965a0da03f5e525f13bc8959dda750acdff14708e9753d4022ebbd97a8c18d9e64b25fbd59bd3b9d7dcdba8cf2f21b5d218a1f441788eba67c86bf590970411671b9995dc5207c28e982d0a4adff9310c1e57691e885a77ef8178d980a9b86f89626dc1c3d0722d4eb26d086e84654c40adb01874380f5003e69eea418a0357365318271c1bc2b59c9ac3ae1d773c23207eee33413f89bd5fca2aa9478c37b4153c443e6519781639e5aa3df5ae8599a366e65d74c580f9cb47566c227151ca10c1f0ab37e4d759120f1deed8ff4f0d696b736836fbae817f76c36fc7f1d92c5c3a801f7a698b4b1129675ea0c7e6cdab2b2f611cc6d8a85044c77ae1a5a8100bf4c64bf5128ec02cb7b3453d3c22d1416ff22c1b0f8678e5a2057cc71ed2004512163f71abaee5f306e3a50189c3f107b26eebc75ead2d42680813242a3a285a1ef8a2a88c578dba72bb1873dabafecdc94cfa6e2f15ed97a629d859e21126a282531cdf6003a146df018320e26115f43ec0c39818a95e32e0d95c883d8016fcf2d21d132df3f01c937e86653819fe4c07b7f57aa13f5b5dc3a0591de4fb7601c5c4a8683233eb281c5a8705b869b3210ef25c45c2251171fbb33a0ad0ee4c57231df261c73e0c7e4887f9d7b863cf4dbaf93407090bf41c334769df2885241a86e545a4082314052ba71eb785c71796c2807fb7016e97b18cda898904120f676afcf49eff76af7ec2bc80a7f53e58e92cd288c4b64a2e1ad3a58e611c8ba11c711e5e9a138b49a5e62947b852ddb268b9793c01c1ad628e4ec776d5004ef211fd68d1b759c0c60281c9bd68b90370c8ae3098e388dfebbbcaa905eff25ea8f098a06bd36016f86efc4dd161a481369aa94bb1e1a050fbb58c9fe7aac0fdc607f450c83d5871b998b2ed5ab51ebb9a351e9cc6a5af0b203fe8772cd710522f84a965705b3010be7ce35e217941cd18cc88a4a5ae47b5e98409dc51bf0909b5df898a3ca77fc1e06c64825b43dfe2a088808174f313e8286050fa3fe848377bf692799a76e9a906729df655c65a889518e5244b8c495d8e4df375600f5abdb5c1834e0c5c618990563685e0126d946520ff719536f90788990e2b5af267926c42ec38f84e2d105f2860a0f3a391ab5d2b6742c7ec53e78d67433e654c25c61311eea20dd256dcafb6b854f76659b25af0c891ca32b27216d8be131eb7a203d5e5add1ed6715484bba3780d44519e253123c2ba063ff9d6a0a058e7d4f08ff9201e6d344eb553550979c978f725de58df607d479860e02293a1130e9bdfa6513eba7224ce4ead96b3ef863529aa7cf091a3396fb60a60ac62085467171524e683f8f0d74a10ee3942ff700a73b95a3b20eee2fca41aafadf743fb0ba03484302d7f933714f54dd48d220a290d4a341a171de0fc99f591fd835616e4189f29b401626d28f5d7260592d5a1b04d68692d39dfe10e6e69ea76fc3925c5d50c0f8686f051bcff687e5f0e47451dbe763dcd4d7a7af81e1e5d836233e35653f0dae7223767b00d1eeb36c4f95191279db2612971dcdc9d8d93bae76f61259d31a85bfffd8cb6b2e106413ea28c8f00895bdd19aa23e46695f2023d80385b17fb805891edb8722fd4828f69a4228531845725182025d57524bb4425174130b2e9cd47c64cfe70d51bab98e43da9fd6d40cf49545bc2b62e42e59adb713c0618e1eb2c393233dfc83ba20b54ab91099d88c615bf8f47e099e884906fdee6624ebcc43aab3245481d9b1754324d26b481d67f2f01daa7c464ac8d45b0638ec2659e3a74421001337bf4ab4f11b46c89f27983e1c66d99163ea3485941711d0e7564ac7b80bb5d3d4bf2afcf45ef6ec64b290ff14fabf8894f6e445733368ff0eb9addeba7e52323b02ca808ea44540358a9ccbb317a9409cad37bd5099ab2e11035edf4b3a7b9d627c4ac43207d20ead96aaa4ea8c71b76dc28fa37053e5d6a1521fab52cbd387a6def96e8df249331d8bacfce6362e9f881914bf6cd7e433d6d3688cfd01a37f21d7e9c6a528a48ae640083b8e2d9b63397cdc2b635dea12b6b7f50b5fd6c9056fb6fd450601f8e3a660b62d42e24df03e30ecdc8c71b879abfb31b20194d65fb67b2db0b3bab1b86e24f812e4eb337d1616588902594b9528fe9cc13a108e452f6fdac842b2c93458989e586e1e3c9b51ce5932a0b11de491dc6ddacdd073d54f87b3cbd820718816d4e9bcda2d89b2d908da3d530c092678ab3457eeb757e5404263e3d2acbd76d2b107d92f390397dcd16c6b1b67460f544d8b42985bd16cb037271559caa1d770b8d8fe779cfa97b7f6df995f4d1081acdf758c3a3616667f69a8ca31277e2ecfb8cd144dc97d1e720709492a90798187aceb5fda0e0e9e3468e921fd3ed8368ea2c0e2d8a30ebbe89acb95357f5d861d138e4ef0f0e0d2f870598d0c8913acc42a83cbc3b3009cefde05329c6bf34c330e7e81e26f414384cc57ebdeb6fcebd6f33a1e0e938339db32ff5d7051af42104ec7f1d889172b3dfb0ec5ca8ffffb9ca0d1a0097df750bc15d0a3a3fe4717ef5fd7afb21da11443b6dcdad5270d3fd6d169e429f10e7e09281979c4045560170a62ae0065b698410a6ce5a53e57aed7d7f8719fc7d8869a87a60b76c95a1c4b2c365703a3faa2f29559a727bc1e28543bdfad3505f06db07dcf2fe32a2f23226724323c233b38d0dfe90cf98d5e06f66492e0f4933fafe4326ccc486d452dd992dc919521c66aea4ad155b880fc8a49c71a3cf1ca7fc4874a2834bde0f86232a6fe2384c353aff4b635474b21191822cd6129bee06471b08cf37a818c11ddf2cc9c5761ffa3f8da262d5d08d01ec90b6c7c1e6651ab632061ab0bf5db3ae3f0ba990cdfccc2d77bd83410e797eafdb98c8a24a26d6bd58151b8a543b759c228b19fd4f10f393359d247142f7accbb6e7627aea20ff75ffca71a9f7791938ee1485fa8a7350645d61365093646ac10ca1e3e412848dd1bae2af3d345ded10c7f4ab3efbe1042f0c4d80babc1f2ee5f7b740de46ba162a5d5136d60f1146324c18e23c384c0df4995aa3611888e7b47357df7fa8d8345557917200b1d123c0928ac2001b5a2e81ee5e60fd75418547858fcbe4ac6d8e2a0f7c8d182a1bd09d95b9403623fb7904f21b89d5fcfa7ac6d1aba13578703f5db64d34c489f0ae5ba3feb8068540471ea8b501c0e65c67aee07a058c64f0d5cea073f9d8b4d15f2661762d4e5264a7e6874377569ec0df7ad55132c5f0507f54cca393af86339ecd1d28b14a7a67302ff8d1509e0364efae96f74b53fc7985523cedb206b0563e7ddfba6b9558e0225d3259d77b4dd122b48acd4356d209ff9d0faee08f8cf35b362ba78708dd829fc3cb4669542296f9cd46bbc7a3349c3849485d8272a4c243bcaf81ebd50d68bf7078062e18ee644fc9520842c91c3aeeefbd74e8eae00c7d46efaa89531c4fee990f5d87fc6846d772ac34dd376eac821c0511392a69adf62b2d6ec76212e970fb29e058028f50042622abb7fa6b1d535fd4d3115c9c516bd9a9597dcb7a7f2b555159831c864b9ad1882d6fad8c1808da9276e7d95dfe6b557b455b273999487e8d3babe920cc1a8e0a9770661a8993e72ebe34d4d81708b9feb8ed95c08e015bd4793d6d0425be4bf8978a5ab5c3e4e75474d5f74a0a595516ca2a07310125601f7cceaa7193f76144b89e608c6571a039e31a5150a4d957022c45b5d162c47dcd7edd1d9d03ec1f766054bfc08f8698fbbabcdbe2722046bd4a3b04cee88766f24f520d7b209c0a50abce532a0f9abacfbbd01e8d9158c083fcd93e8b7a1976d7471b90211848a1dcd608aa5a1606006f66d6fd4354b4798a805f2ff3e1be373974efe0f2ae383470cea94fb24cd4f4757a9536c3918921ffa6c687463bf6d6798e24345d709b3bd26a5bf2d6a86f46396f0b6a55ba079b9b6b6bcd873d9725542e9dc19955cee50f80f59172931b441f17cd1634c3a12a4051023df32b7e007718ce0ff0715533464093961edd72e468b0e5d62c43283e98b2477f880bac7e79eacf59fcfc727e7dff0ce20102059a5bc350c49de18bbd5155e1642226565967e8cacadc43555dc9103a296114314a5fd7345887e4291056b09f1eac23cc09d2f35ab8687354c8192c8feab8ffeda5075ac4e06b00e8f7fc0b7b3f4e906524089f1d9a6500a37c60ab6a3f52e2840914b90b7218c83cbed737a8fc2c97d91234784aada5021d1aae31415a43b90c71365cead7dddbd0e7b81832bc9d1833c19998e76232d1b26ea1ab0067991f5969ee6e29524750b51f6dd2fab5fd4187f8234997cdc658330a9da6785f052a31584a39c70e74c38dc4ac24c2e065fdcdf84a1026a1f2e9fcecf723362b59f89c2d54382edfd3280233ad64c3e51b755558785c415e6181219c532c8e2b0035ddb7d21c7b5ab3b9dea7ae0b3cc4c779a6da840ad22b10b07d5622defa55e1e906a9f351e9a5a578b692809d3a3aee6f22fb6e05a2b71aea9bb4aa5d82d6622e1b359c12116cf55c0c0c93c2ed9fa6f137efc73ae8815e2b2b879a0dd1ed13781479e65ac7e017206c5beb2c6f2712431d9983b5086de7cb5ce6442246ce4f49af6004ec441c5c96269d875515ead2a5fabcede0ecac9ea89</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">这里需要密码。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Kalthyix 团队周报</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串入门</title>
    <url>/2025/07/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="定义">定义</h3>
<h4 id="前缀">前缀</h4>
<p>对于字符串 <span
class="math inline">\(S\)</span>，从串首开始到某个位置 <span
class="math inline">\(i\)</span> 结束的子串，叫做 <span
class="math inline">\(S\)</span> 的一个前缀，除 <span
class="math inline">\(S\)</span> 本身外的所有前缀叫做 <span
class="math inline">\(S\)</span> 的真前缀。 #### 后缀
与前缀类似，从某位置 <span class="math inline">\(i\)</span>
到串尾的一个字串叫做后缀，同样有真后缀。 ### 字典树/Trie
结构为一棵树，从根节点到树上某一结点的一条路径就是一个字符串。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> c-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> c-<span class="string">&#x27;a&#x27;</span><span class="number">+26</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> c-<span class="string">&#x27;0&#x27;</span><span class="number">+52</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">	<span class="type">int</span> nxt[N][<span class="number">65</span>],tot,cnt[N];</span><br><span class="line">	<span class="type">bool</span> end[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">64</span>;j++)</span><br><span class="line">				nxt[i][j]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">			cnt[i]=<span class="number">0</span>,end[i]=<span class="number">0</span>;</span><br><span class="line">		tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> p=<span class="number">0</span>,len=<span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="type">int</span> c=<span class="built_in">id</span>(s[i]);</span><br><span class="line">			<span class="keyword">if</span>(!nxt[p][c])</span><br><span class="line">				nxt[p][c]=++tot;</span><br><span class="line">			p=nxt[p][c];</span><br><span class="line">			cnt[p]++;</span><br><span class="line">		&#125;</span><br><span class="line">		end[p]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> p=<span class="number">0</span>,len=<span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="type">int</span> c=<span class="built_in">id</span>(s[i]);</span><br><span class="line">			<span class="keyword">if</span>(!nxt[p][c])</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			p=nxt[p][c];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cnt[p];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> #### 应用 字符串查找，前缀统计等。
一些关于后缀的操作可以反转字符串变为前缀操作。 ### KMP 算法 进行 KMP
算法的过程其实就是在求一个叫做<strong>最长公共前后缀</strong>的东西。
定义一个字符串 <span class="math inline">\(S\)</span> 的 border 为 <span
class="math inline">\(S\)</span> 的一个非 <span
class="math inline">\(S\)</span> 本身的子串 <span
class="math inline">\(T\)</span>，满足 <span
class="math inline">\(T\)</span> 既是 <span
class="math inline">\(S\)</span> 的前缀，又是 <span
class="math inline">\(S\)</span> 的后缀。求解最大 border。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">nxt[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//nxt[i]表示字串S[1...i]的最大border的长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(j&amp;&amp;s[j<span class="number">+1</span>]!=s[i])</span><br><span class="line">		j=nxt[j];</span><br><span class="line">	<span class="keyword">if</span>(s[j<span class="number">+1</span>]==s[i])</span><br><span class="line">		j++;</span><br><span class="line">	nxt[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
#### 应用 查找 <span class="math inline">\(S_2\)</span> 串在 <span
class="math inline">\(S_1\)</span> 串的位置。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len2;i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(j&amp;&amp;s2[j<span class="number">+1</span>]!=s2[i])</span><br><span class="line">		j=nxt[j];</span><br><span class="line">	<span class="keyword">if</span>(s2[j<span class="number">+1</span>]==s2[i])</span><br><span class="line">		j++;</span><br><span class="line">	nxt[i]=j;</span><br><span class="line">&#125;</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(j&amp;&amp;s2[j<span class="number">+1</span>]!=s1[i])</span><br><span class="line">		j=nxt[j];</span><br><span class="line">	<span class="keyword">if</span>(s2[j<span class="number">+1</span>]==s1[i])</span><br><span class="line">		j++;</span><br><span class="line">	<span class="keyword">if</span>(j==len2)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i-j<span class="number">+1</span>);</span><br><span class="line">		j=nxt[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
另一种方法是，构建一个新字符串 <span
class="math inline">\(S=S_2+a+S_1\)</span>，进行一次 KMP，若某点 <span
class="math inline">\(nxt\)</span> 值等于 <span
class="math inline">\(S_2\)</span> 的长度则找到了一个解。<span
class="math inline">\(a\)</span> 为字符集以外的任意字符，如
<code>#</code>。</p>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束</title>
    <url>/2025/07/04/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>血的教训：模拟赛出了个差分约束板子结果发现不会打。 <a
href="https://www.luogu.com.cn/problem/P5960"
title="题目链接">题目链接</a></p>
<h3 id="引入">引入</h3>
<p>我们有一些形如 <span class="math display">\[x_c-x_{c^\prime}\le
y\]</span> 的方程构成了方程组，要求出一组解。
之后进行神奇的关联，我们来看一个求最短路的代码片段： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">	dis[v]=dis[u]+e[i].w;</span><br><span class="line">	<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">		q.<span class="built_in">push</span>(v);</span><br><span class="line">		vis[v]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们发现，这里通过松弛操作维护了 <span class="math display">\[dis[v] \le
dis[u]+e[i].w\]</span> 移项，得 <span
class="math display">\[dis[v]-dis[u]\le e[i].w\]</span>
我们发现，这与题目中所给的方程形式完全一致。所以，我们可以将解方程组转化为一个图论问题，使用最短路算法求出方程的一组解，这就是差分约束系统。
###题目解法 通过观察以上两个式子，发现 <span
class="math inline">\(c\)</span> 对应一条边的 <span
class="math inline">\(v\)</span> 节点，<span
class="math inline">\(c^\prime\)</span> 对应边的 <span
class="math inline">\(u\)</span> 节点，只要建立一个权值为 <span
class="math inline">\(y\)</span> 的边就好了。
但我们发现，这样不一定能保证图的连通性，解决办法是建立一个虚拟的 <span
class="math inline">\(0\)</span> 号超级源点，与每个节点建一条权值为
<span class="math inline">\(0\)</span> 的边。
还有方程无解的问题，对应图论中的负环问题。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span><span class="number">+10</span>,M=<span class="number">1e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,head[N],tot,cnt[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	e[++tot].to=v;</span><br><span class="line">	e[tot].nxt=head[u];</span><br><span class="line">	e[tot].w=w;</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">	vis[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">				dis[v]=dis[u]+e[i].w;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">					vis[v]=<span class="number">1</span>;</span><br><span class="line">					cnt[v]++;</span><br><span class="line">					<span class="keyword">if</span>(cnt[v]==n<span class="number">+1</span>)<span class="comment">//判负环</span></span><br><span class="line">						<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">0</span>);<span class="comment">//虚拟源点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> c1,c2,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;c1,&amp;c2,&amp;y);</span><br><span class="line">		<span class="built_in">add</span>(c2,c1,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他形式">其他形式</h3>
<p>若有 <span class="math inline">\(x_c-x_{c^\prime}\ge
y\)</span>，可以两边同时乘 <span class="math inline">\(-1\)</span>
改变不等号方向，或者跑最长路。 若有 <span
class="math inline">\(x_c-x_{c^\prime}=y\)</span>，可以将其拆分为 <span
class="math display">\[
\begin{cases}
x_c-x_{c^\prime}\le y\\
x_c-x_{c^\prime}\ge y
\end{cases}
\]</span> <a href="https://www.luogu.com.cn/record/204400669"
title="End.">End.</a></p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>指令集</title>
    <url>/2025/08/22/%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
    <content><![CDATA[<h1
id="声明任何情况下都不要在正式比赛中使用指令集">声明：任何情况下，都不要在正式比赛中使用指令集</h1>
<p><span class="math inline">\(n\)</span> 方过百万，暴力碾标算。</p>
<h3 id="简介">简介</h3>
<p>简单来说，指令集就是 CPU
可以直接接收并执行而不需要像其他代码一样需要经过繁杂处理的一类命令。现在的
Intel 和 AMD 的 CPU 一般都支持 SSE（128 位）、AVX（256
位）等指令集。以下以 AVX
指令集为例介绍一般使用方法。若想用别的指令集可以尝试把下文的
<code>256</code> 改为 <code>128</code> 等，如 <code>__m256i</code> 改为
<code>__m128i</code>。</p>
<h3 id="功能">功能</h3>
<p>指令集通过对存储和运算向量化来优化效率。通俗的一种理解是分块/状压，通过一种
64/128/256 位的容器存储变量。以 <code>int</code> 为例，一个 256
位的容器就可以存储 8 个 <code>int</code>，可以得到近似 <span
class="math inline">\(\dfrac{1}{8}\)</span> 的常数优化。</p>
<h3 id="环境">环境</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;immintrin.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>头文件是帮你封装好的，让你不用在代码中内联汇编。</p>
<h3 id="变量类型">变量类型</h3>
<p><code>__m256</code> 为 <code>float</code>，<code>__m256i</code> 为
<code>long long</code>，<code>__m256d</code> 为 <code>double</code>。
额，<code>int</code> 呢？其实可以用 <code>__m256i</code>
存，方式类似那个一个 <code>long long</code> 拆成两个 <code>int</code>
用的奇技淫巧。</p>
<h3 id="基础指令">基础指令</h3>
<h4 id="声明">声明</h4>
<p>直接像其他变量一样就行 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__m256i a;</span><br><span class="line">__m256 b;</span><br><span class="line">__m256d c;</span><br></pre></td></tr></table></figure></p>
<h4 id="赋值">赋值</h4>
<p>对于 <code>__m256i</code>，用
<code>_mm256_set_epi32(int e7,int e6,int e5,int e4,int e3,int e2,int e1,int e0)</code>
和
<code>_mm256_set_epi64x(long long e3,long long e2,long long e1,long long e0)</code>，这两条都指令返回一个
<code>__m256i</code>。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__m256i a;</span><br><span class="line">a=_mm256_set_epi32(<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">a=_mm256_set_epi64x(<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure> 注意，以上指令的下标是逆序的。<br />
如果想整体赋值，可以用 <code>_mm256_set1_epi32(int a)</code> 和
<code>_mm256_set1_epi64x(long long a)</code>。</p>
<h4 id="运算">运算</h4>
<p><code>_mm256_add_epi32(__m256i a,__m256i b)</code> 把 <code>a</code>
和 <code>b</code> 内的值按 32
位整型大小相加并返回结果。同理，<code>add</code> 可换为
<code>sub</code>（减法）、<code>mullo</code>（乘法）、<code>abs</code>（绝对值）还有位运算等等。<br />
64 位同理，参考上文格式，将 <code>epi32</code> 换为 <code>epi64x</code>
即可。下文亦不再过多赘述。</p>
<h4 id="访问">访问</h4>
<p>这里是一个难点，认真看：<br />
可以直接下标访问<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__m256i a=_mm256_set_epi32(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure> 结果为 <span class="math inline">\(3\times
2^{32}+4\)</span>（事实上不会显示这个数，因为是以 <code>int</code>
形式输出的）。原因如下：<br />
<code>__m256i</code> 存储是逆序的，所以下标要倒着看。而
<code>__m256i</code> 存的又是 <code>long long</code>，所以寻址到元素
<span class="math inline">\(3\)</span> 和 <span
class="math inline">\(4\)</span> 所在的那 64 位。 那我咋访问
<code>int</code> 类型？<br />
用 <code>int</code> 指针强行指……<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__m256i a=_mm256_set_epi32(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line"><span class="type">int</span> *b=(<span class="type">int</span>*)&amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure> 这样就输出 <span class="math inline">\(6\)</span>。</p>
<p>试试看：</p>
<ul>
<li><a href="https://qoj.ac/problem/8616">Fast Tree Queries</a></li>
</ul>
<h3 id="参考资料">参考资料</h3>
<p>https://ouuan.github.io/post/n%E6%96%B9%E8%BF%87%E7%99%BE%E4%B8%87-%E6%9A%B4%E5%8A%9B%E7%A2%BE%E6%A0%87%E7%AE%97%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</p>
]]></content>
      <tags>
        <tag>其他技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>暑假集训题目合集-2</title>
    <url>/2025/07/13/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86-2/</url>
    <content><![CDATA[<h1 id="day7">Day7</h1>
<h2 id="扫描线">扫描线</h2>
<p>一般使用线段树维护，具体地，维护区间和及区间非零个数。</p>
<h3 id="noi2023-方格染色"><a
href="https://www.luogu.com.cn/problem/P9478">[NOI2023]
方格染色</a></h3>
横竖线就是扫描线板题。斜线最多只有 <span
class="math inline">\(5\)</span>
个，暴力将能够合并的斜线合并，然后遍历所有横竖线判断是否有交。懒得写离散化了，直接动态开点线段树也能过。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> tot,n,m,q,C,cnt,type3cnt,cnt1,cnt2;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">114</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">    <span class="type">int</span> t,x1,y1,x2,y2;</span><br><span class="line">&#125;a[N],b[<span class="number">114</span>],c[<span class="number">114</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">change</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y1,y2,k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> change &amp;temp)<span class="type">const</span>&#123;<span class="keyword">return</span> x&lt;temp.x;&#125;</span><br><span class="line">&#125;p[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    Node *ls,*rs;</span><br><span class="line">    <span class="type">int</span> val,tag;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line">Node *root;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node *<span class="title">new_node</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> &amp;tree[++tot];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(Node *u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u-&gt;tag) u-&gt;val=r-l<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r) u-&gt;val=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        u-&gt;val=<span class="number">0</span>;</span><br><span class="line">        u-&gt;val+=u-&gt;ls?u-&gt;ls-&gt;val:<span class="number">0</span>;</span><br><span class="line">        u-&gt;val+=u-&gt;rs?u-&gt;rs-&gt;val:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(Node*&amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="literal">nullptr</span>) u=<span class="built_in">new_node</span>();</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">        u-&gt;tag+=k;</span><br><span class="line">        <span class="built_in">push_up</span>(u,l,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(u-&gt;ls,l,mid,x,y,k);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">modify</span>(u-&gt;rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">    <span class="built_in">push_up</span>(u,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(C,n,m,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,t,x1,y1,x2,y2;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(t,x1,y1,x2,y2);</span><br><span class="line">        <span class="keyword">if</span>(t!=<span class="number">3</span>)&#123;</span><br><span class="line">            p[++cnt]=&#123;x1<span class="number">-1</span>,y1,y2,<span class="number">1</span>&#125;;</span><br><span class="line">            p[++cnt]=&#123;x2,y1,y2,<span class="number">-1</span>&#125;;</span><br><span class="line">            a[++cnt1]=&#123;t,x1,y1,x2,y2&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> b[++type3cnt]=&#123;<span class="number">3</span>,x1,y1,x2,y2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p<span class="number">+1</span>,p<span class="number">+1</span>+cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="built_in">modify</span>(root,<span class="number">1</span>,<span class="number">1e9</span>,p[i].y1,p[i].y2,p[i].k);</span><br><span class="line">        ans+=root-&gt;val*(p[i<span class="number">+1</span>].x-p[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=type3cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=type3cnt;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j||vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(b[j].x2-b[i].x1==b[j].y2-b[i].y1&amp;&amp;b[j].x1&lt;=b[i].x2&amp;&amp;b[j].x2&gt;=b[i].x2)&#123;</span><br><span class="line">                    b[i].x1=<span class="built_in">min</span>(b[i].x1,b[j].x1);</span><br><span class="line">                    b[i].y1=<span class="built_in">min</span>(b[i].y1,b[j].y1);</span><br><span class="line">                    b[i].x2=<span class="built_in">max</span>(b[i].x2,b[j].x2);</span><br><span class="line">                    b[i].y2=<span class="built_in">max</span>(b[i].y2,b[j].y2);</span><br><span class="line">                    vis[j]=<span class="number">1</span>;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=type3cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        c[++cnt2]=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt2;i++)&#123;</span><br><span class="line">        set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt1;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j].t==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> tx=c[i].x1+a[j].y1-c[i].y1;</span><br><span class="line">                <span class="keyword">if</span>(tx&lt;c[i].x1||tx&gt;c[i].x2||tx&lt;<span class="number">1</span>||tx&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(tx&lt;a[j].x1||tx&gt;a[j].x2) <span class="keyword">continue</span>;</span><br><span class="line">                pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; temp=&#123;tx,a[j].y1&#125;;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">find</span>(temp)==st.<span class="built_in">end</span>())</span><br><span class="line">                    --ans,st.<span class="built_in">insert</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[j].t==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">int</span> ty=c[i].y1+a[j].x1-c[i].x1;</span><br><span class="line">                <span class="keyword">if</span>(ty&lt;c[i].y1||ty&gt;c[i].y2||ty&lt;<span class="number">1</span>||ty&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(ty&lt;a[j].y1||ty&gt;a[j].y2) <span class="keyword">continue</span>;</span><br><span class="line">                pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; temp=&#123;a[j].x1,ty&#125;;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">find</span>(temp)==st.<span class="built_in">end</span>())</span><br><span class="line">                    --ans,st.<span class="built_in">insert</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=c[i].x2-c[i].x1<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="shoi2007-园丁的烦恼"><a
href="https://www.luogu.com.cn/problem/P2163">[SHOI2007]
园丁的烦恼</a></h3>
将一个询问拆成四个询问的差分形式，扫描线维护二维前缀和，动态开点线段树代替离散化。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a)<span class="type">const</span>&#123;<span class="keyword">return</span> x&lt;a.x;&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="type">int</span> tot,ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,belong,f;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Query &amp;a)<span class="type">const</span>&#123;<span class="keyword">return</span> x&lt;a.x;&#125;</span><br><span class="line">&#125;q[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    Tree *ls,*rs;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">5</span>],*root;</span><br><span class="line"><span class="type">int</span> node_cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Tree* <span class="title">new_node</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> &amp;tree[++node_cnt];&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> val(x) (x==nullptr?0:x-&gt;sum)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(Tree *&amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="literal">nullptr</span>) u=<span class="built_in">new_node</span>();</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        ++u-&gt;sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(u-&gt;ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(u-&gt;rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">    u-&gt;sum=<span class="built_in">val</span>(u-&gt;ls)+<span class="built_in">val</span>(u-&gt;rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Tree *u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r) <span class="keyword">return</span> u-&gt;sum;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) res+=<span class="built_in">query</span>(u-&gt;ls,l,mid,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) res+=<span class="built_in">query</span>(u-&gt;rs,mid<span class="number">+1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> now;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(p[i].x,p[i].y);</span><br><span class="line">    <span class="built_in">sort</span>(p<span class="number">+1</span>,p<span class="number">+1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b,c,d;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a,b,c,d);</span><br><span class="line">        <span class="keyword">if</span>(a<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;b<span class="number">-1</span>&gt;=<span class="number">0</span>) q[++tot]=&#123;a<span class="number">-1</span>,b<span class="number">-1</span>,i,<span class="number">1</span>&#125;;</span><br><span class="line">        q[++tot]=&#123;c,d,i,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(a<span class="number">-1</span>&gt;=<span class="number">0</span>) q[++tot]=&#123;a<span class="number">-1</span>,d,i,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(b<span class="number">-1</span>&gt;=<span class="number">0</span>) q[++tot]=&#123;c,b<span class="number">-1</span>,i,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q<span class="number">+1</span>,q<span class="number">+1</span>+tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now&lt;n&amp;&amp;p[now<span class="number">+1</span>].x&lt;=q[i].x)</span><br><span class="line">            <span class="built_in">modify</span>(root,<span class="number">0</span>,<span class="number">1e7</span>,p[++now].y);</span><br><span class="line">        ans[q[i].belong]+=<span class="built_in">query</span>(root,<span class="number">0</span>,<span class="number">1e7</span>,<span class="number">0</span>,q[i].y)*q[i].f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ioi-1998usaco5.5-矩形周长-picture"><a
href="https://www.luogu.com.cn/problem/P1856">[IOI 1998][USACO5.5]
矩形周长 Picture</a></h3>
横线和竖线分开算。注意若出现多条线重合，则必须先处理加再处理删。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,val[N&lt;&lt;<span class="number">2</span>],sum[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum[u]) val[u]=r-l<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r) val[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> val[u]=val[ls]+val[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">        sum[u]+=k;</span><br><span class="line">        <span class="built_in">push_up</span>(u,l,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(ls,l,mid,x,y,k);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">    <span class="built_in">push_up</span>(u,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,a,b,k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;y)<span class="type">const</span>&#123;<span class="keyword">return</span> x^y.x?x&lt;y.x:k&gt;y.k;&#125;</span><br><span class="line">&#125;p[N&lt;&lt;<span class="number">1</span>],q[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> tot1,tot2,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b,c,d;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a,b,c,d);</span><br><span class="line">        p[++tot1]=&#123;a,b,d<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        p[++tot1]=&#123;c,b,d<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        q[++tot2]=&#123;b,a,c<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        q[++tot2]=&#123;d,a,c<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p<span class="number">+1</span>,p<span class="number">+1</span>+tot1);</span><br><span class="line">    <span class="built_in">sort</span>(q<span class="number">+1</span>,q<span class="number">+1</span>+tot2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot1;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp=val[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(p[i].a&gt;p[i].b) <span class="built_in">swap</span>(p[i].a,p[i].b);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">-1e4</span>,<span class="number">1e4</span>,p[i].a,p[i].b,p[i].k);</span><br><span class="line">        ans+=<span class="built_in">abs</span>(temp-val[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot2;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp=val[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(q[i].a&gt;q[i].b) <span class="built_in">swap</span>(q[i].a,q[i].b);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">-1e4</span>,<span class="number">1e4</span>,q[i].a,q[i].b,q[i].k);</span><br><span class="line">        ans+=<span class="built_in">abs</span>(temp-val[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day8">Day8</h1>
<h2 id="树上技巧">树上技巧</h2>
<p>树的直径的求法：<br />
- 两遍 dfs/bfs（无法处理负边权） - 树形 DP（可以处理负边权）</p>
<p>这两种方法的时间复杂度均为 <span
class="math inline">\(O(n)\)</span>。<br />
树形 DP 具体求法：<br />
设 <span class="math inline">\(dp_{u,0/1}\)</span> 表示以 <span
class="math inline">\(u\)</span>
为根的子树中从根向下能延伸的最长/非严格次长路径。则答案为 <span
class="math inline">\(dp_{u,0}+dp_{u,1}\)</span> 的最大值。</p>
<h3 id="apio2010-巡逻"><a
href="https://www.luogu.com.cn/problem/P3629">[APIO2010] 巡逻</a></h3>
老题了。考虑贪心，<span class="math inline">\(k=1\)</span>
时连接直径两端是显然的。设直径为 <span
class="math inline">\((u_1,v_1)\)</span>，加入的第二条边为 <span
class="math inline">\((u_2,v_2)\)</span>，二者不交时答案显然为 <span
class="math inline">\(dis(u_1,v_1)+dis(u_2,v_2)\)</span>，若两路径有交，形如<br />
<img
src="https://github.com/headless-piston/blog_images/blob/main/P3629.png?raw=true" />
则答案为 <span
class="math inline">\(dis(u_1,v_2)+dis(u_2,v_1)\)</span>。由此可以看出，若仍要选在直径上的边，代价会更大。则我们将直径的边权全部设为
<span class="math inline">\(-1\)</span>，再找一个新的直径。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,k,ans,dis[N],a,b,pre[N],head[N],dp[N][<span class="number">2</span>],maxn;</span><br><span class="line"><span class="type">bool</span> vis[N],tag[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">bool</span> flag,<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v]=dis[u]<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag) pre[v]=u;</span><br><span class="line">        <span class="keyword">if</span>(dis[v]&gt;dis[x]) x=v;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,flag,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,u);</span><br><span class="line">        <span class="type">int</span> w=tag[u]&amp;&amp;tag[v]?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> temp=dp[v][<span class="number">0</span>]+w;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;dp[u][<span class="number">0</span>])</span><br><span class="line">            dp[u][<span class="number">1</span>]=dp[u][<span class="number">0</span>],dp[u][<span class="number">0</span>]=temp;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;dp[u][<span class="number">1</span>])</span><br><span class="line">            dp[u][<span class="number">1</span>]=temp;</span><br><span class="line">        maxn=<span class="built_in">max</span>(maxn,dp[u][<span class="number">0</span>]+dp[u][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a,b);</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>,a);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">dfs1</span>(a,<span class="number">1</span>,b);</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        ans=(n<span class="number">-1</span>)*<span class="number">2</span>-dis[b]<span class="number">+1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b;i;i=pre[i]) tag[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ans=n*<span class="number">2</span>-dis[b]-maxn;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="noi2021-轻重边"><a
href="https://www.luogu.com.cn/problem/P7735">[NOI2021] 轻重边</a></h3>
结论：每次修改操作染不同颜色，重边数等于区间内相邻两点颜色相同的点对数。树剖+线段树维护即可。精细处理树剖的查询部分。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> t,n,m,siz[N],son[N],dep[N],fa[N],dfn[N],dfncnt,top[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    son[u]=<span class="number">0</span>;</span><br><span class="line">    dep[u]=dep[f]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]])</span><br><span class="line">            son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">    dfn[u]=++dfncnt;</span><br><span class="line">    top[u]=topf;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) <span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc,cnt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">friend</span> node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.lc==<span class="number">-1</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(b.lc==<span class="number">-1</span>) <span class="keyword">return</span> a;</span><br><span class="line">        node res;</span><br><span class="line">        res.lc=a.lc,res.rc=b.rc;</span><br><span class="line">        res.cnt=a.cnt+b.cnt;</span><br><span class="line">        <span class="keyword">if</span>(a.rc==b.lc&amp;&amp;a.rc) ++res.cnt;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> tag[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> P,DEP;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) (x&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> siz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tag[u]) <span class="keyword">return</span>;</span><br><span class="line">    tree[<span class="built_in">ls</span>(u)]=tree[<span class="built_in">rs</span>(u)]=&#123;tag[u],tag[u],(siz&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>&#125;;</span><br><span class="line">    tag[<span class="built_in">ls</span>(u)]=tag[<span class="built_in">rs</span>(u)]=tag[u];</span><br><span class="line">    tag[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    l+=P<span class="number">-1</span>,r+=P<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=DEP;i;i--) <span class="built_in">push_down</span>(l&gt;&gt;i,<span class="number">1</span>&lt;&lt;i),<span class="built_in">push_down</span>(r&gt;&gt;i,<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    <span class="type">int</span> siz=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l^<span class="number">1</span>^r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~l&amp;<span class="number">1</span>) tree[l^<span class="number">1</span>]=&#123;k,k,siz<span class="number">-1</span>&#125;,tag[l^<span class="number">1</span>]=k;</span><br><span class="line">        <span class="keyword">if</span>(r&amp;<span class="number">1</span>) tree[r^<span class="number">1</span>]=&#123;k,k,siz<span class="number">-1</span>&#125;,tag[r^<span class="number">1</span>]=k;</span><br><span class="line">        l&gt;&gt;=<span class="number">1</span>,r&gt;&gt;=<span class="number">1</span>,siz&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        tree[l]=tree[<span class="built_in">ls</span>(l)]+tree[<span class="built_in">rs</span>(l)];</span><br><span class="line">        tree[r]=tree[<span class="built_in">ls</span>(r)]+tree[<span class="built_in">rs</span>(r)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(l&gt;&gt;=<span class="number">1</span>;l;l&gt;&gt;=<span class="number">1</span>) tree[l]=tree[<span class="built_in">ls</span>(l)]+tree[<span class="built_in">rs</span>(l)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    node resl=&#123;<span class="number">-1</span>&#125;,resr=&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">    l+=P<span class="number">-1</span>,r+=P<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=DEP;i;i--) <span class="built_in">push_down</span>(l&gt;&gt;i,<span class="number">1</span>&lt;&lt;i),<span class="built_in">push_down</span>(r&gt;&gt;i,<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    <span class="keyword">while</span>(l^<span class="number">1</span>^r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~l&amp;<span class="number">1</span>) resl=resl+tree[l^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(r&amp;<span class="number">1</span>) resr=tree[r^<span class="number">1</span>]+resr;</span><br><span class="line">        l&gt;&gt;=<span class="number">1</span>,r&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resl+resr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">modify</span>(dfn[top[x]],dfn[x],k);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">modify</span>(dfn[x],dfn[y],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,c1=<span class="number">0</span>,c2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">            <span class="built_in">swap</span>(c1,c2);</span><br><span class="line">        &#125;</span><br><span class="line">        node res=<span class="built_in">query</span>(dfn[top[x]],dfn[x]);</span><br><span class="line">        ans+=res.cnt;</span><br><span class="line">        <span class="keyword">if</span>(res.rc==c1&amp;&amp;c1) ++ans;</span><br><span class="line">        c1=res.lc;</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">swap</span>(c1,c2);</span><br><span class="line">    &#125;</span><br><span class="line">    node res=<span class="built_in">query</span>(dfn[x],dfn[y]);</span><br><span class="line">    ans+=res.cnt;</span><br><span class="line">    <span class="keyword">if</span>(res.rc==c2&amp;&amp;c2) ++ans;</span><br><span class="line">    <span class="keyword">if</span>(res.lc==c1&amp;&amp;c1) ++ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,op,a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        dfncnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) e[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">read</span>(n,m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">read</span>(u,v);</span><br><span class="line">            e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in">sizeof</span>(node)*(n*<span class="number">4</span><span class="number">+10</span>));</span><br><span class="line">        <span class="built_in">memset</span>(tag,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(n*<span class="number">4</span><span class="number">+10</span>));</span><br><span class="line">        P=<span class="number">1</span>,DEP=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(P&lt;=n<span class="number">+1</span>) P&lt;&lt;=<span class="number">1</span>,++DEP;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">read</span>(op,a,b);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">change</span>(a,b,++cnt);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ask</span>(a,b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="十二省联考-2019-春节十二响"><a
href="https://www.luogu.com.cn/problem/P5290">[十二省联考 2019]
春节十二响</a></h3>
贪心策略：令两条链上各自权值最大的比较，次大的比较……则可以在每个节点开一个堆，启发式合并。不同于可并堆，节点
<span class="math inline">\(u\)</span>，<span
class="math inline">\(v\)</span> 的堆合并后的大小为 <span
class="math inline">\(\max(size_u,size_v)\)</span> 而非 <span
class="math inline">\(size_u+size_v\)</span>，时间复杂度为 <span
class="math inline">\(O(n\log n)\)</span>。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m[N];</span><br><span class="line">ll ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">if</span>(q[x].<span class="built_in">size</span>()&lt;q[y].<span class="built_in">size</span>()) <span class="built_in">swap</span>(q[x],q[y]);</span><br><span class="line">    <span class="keyword">while</span>(q[y].<span class="built_in">size</span>())&#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(<span class="built_in">max</span>(q[x].<span class="built_in">top</span>(),q[y].<span class="built_in">top</span>()));</span><br><span class="line">        q[x].<span class="built_in">pop</span>(),q[y].<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k:temp) q[x].<span class="built_in">push</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="built_in">merge</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    q[u].<span class="built_in">push</span>(m[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(m[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,f;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(f),e[f].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q[<span class="number">1</span>].<span class="built_in">empty</span>()) ans+=q[<span class="number">1</span>].<span class="built_in">top</span>(),q[<span class="number">1</span>].<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day9">Day9</h1>
<h2 id="数论">数论</h2>
<h3 id="taoi-2喵了个喵-ⅳ"><a
href="https://www.luogu.com.cn/problem/P9575">「TAOI-2」喵了个喵
Ⅳ</a></h3>
神秘题。<span class="math inline">\(n\)</span> 为偶数时显然。<span
class="math inline">\(n\)</span> 为奇数时先求出所有数的最大公约数 <span
class="math inline">\(d\)</span>，此时取 <span
class="math inline">\(x=2\)</span>，将所有数都约去 <span
class="math inline">\(d\)</span>，此时若有奇数个奇数，则会有偶数个偶数，必然无解，反之则可以按照奇偶容易地构造一组解。最后答案为
<span class="math inline">\(2d\)</span>。<br />

<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],d,cntodd,cnteven;</span><br><span class="line"><span class="type">bool</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">read</span>(a[i]);</span><br><span class="line">            d=__gcd(d,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            a[i]/=d;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>) ++cntodd;</span><br><span class="line">            <span class="keyword">else</span> ++cnteven;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cntodd&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,cnt=<span class="number">0</span>;i&lt;=n&amp;&amp;cnt&lt;cntodd/<span class="number">2</span><span class="number">-1</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>) ans[i]=<span class="number">1</span>,++cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,cnt=<span class="number">0</span>;i&lt;=n&amp;&amp;cnt&lt;(cnteven<span class="number">+1</span>)/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(~a[i]&amp;<span class="number">1</span>) ans[i]=<span class="number">1</span>,++cnt;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">2</span>*d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ctsc2017-吉夫特"><a
href="https://www.luogu.com.cn/problem/P3773">[CTSC2017] 吉夫特</a></h3>
这题的转化真是神了。发现题目中 <span class="math inline">\(\bmod
2\)</span> 很特殊，<span class="math inline">\(\dbinom{a_{b_1}}{a_{b_2}}
\times \dbinom{a_{b_2}}{a_{b_3}} \times \cdots \times
\dbinom{a_{b_{k-1}}}{a_{b_k}} \bmod 2 &gt;0\)</span>
成立当且仅当对于任意 <span class="math inline">\(k&gt;1\)</span>，<span
class="math inline">\(\dbinom{a_{b_{k-1}}}{a_{b_k}}\bmod
2=1\)</span>，我们尝试使用 Lucas 定理展开<br />
<span class="math display">\[\binom{a_{b_{k-1}}}{a_{b_k}}\equiv
\binom{\lfloor a_{b_{k-1}}/2\rfloor}{\lfloor
a_{b_k}/2\rfloor}\binom{a_{b_{k-1}}\bmod 2}{a_{b_k}\bmod 2}\pmod
2\]</span>
持续展开，不难发现其等于两数二进制拆分后每一位的组合数相乘，又因为<br />
<span
class="math display">\[\binom{1}{1}=\binom{1}{0}=\binom{0}{0}=1\]</span>
<span class="math display">\[\binom{0}{1}=0\]</span> 所以 <span
class="math inline">\(\dbinom{a_{b_{k-1}}}{a_{b_k}}\bmod 2=1\)</span>
当且仅当 <span class="math inline">\(a_{b_k}\)</span> 在二进制下是 <span
class="math inline">\(a_{b_{k-1}}\)</span> 的子集，即 <span
class="math inline">\(a_{b_{k-1}} \operatorname{bitand}
a_{b_k}=a_{b_k}\)</span>。则我们可以推出 DP 方程，设 <span
class="math inline">\(dp_{i}\)</span> 表示以 <span
class="math inline">\(i\)</span> 为结尾的子序列方案数：<br />
<span class="math display">\[dp_{a_i}=\sum_{a_i\in a_j\land
j&lt;i}(dp_{a_j}+1)\]</span> <span
class="math inline">\(O(3^{\log{\max(a_i)}})\)</span>
子集枚举即可。<br />

<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1000000007</span>,N=<span class="number">233350</span>;</span><br><span class="line"><span class="type">int</span> n,a,dp[N],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s=(a<span class="number">-1</span>)&amp;a;s;s=(s<span class="number">-1</span>)&amp;a)</span><br><span class="line">            dp[s]=(dp[s]+dp[a]<span class="number">+1</span>)%mod;</span><br><span class="line">        ans=(ans+dp[a])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day10">Day10</h1>
<h2 id="线性代数">线性代数</h2>
<h3 id="usaco07nov-cow-relays-g"><a
href="https://www.luogu.com.cn/problem/P2886">[USACO07NOV] Cow Relays
G</a></h3>
我们使用 <span class="math inline">\(\min\)</span> 和 <span
class="math inline">\(+\)</span> 代替原矩阵乘法中的 <span
class="math inline">\(+\)</span> 和 <span
class="math inline">\(\times\)</span>，也就是<br />
<span class="math display">\[C_{i,j}=\min(A_{i,k}+B_{k,j})\]</span> 设
<span class="math inline">\(A_{i,j}\)</span> 表示 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j\)</span> 的最短路，则走 <span
class="math inline">\(n\)</span> 步后的最短路即为 <span
class="math inline">\(A_{i,j}^n\)</span>。<br />
设离散化后点有 <span class="math inline">\(m\)</span> 个，时间复杂度
<span class="math inline">\(O(m^3\log n)\)</span>。<br />

<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1010</span>,M=<span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> n,t,s,e,a[N],cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> u,v,w;&#125;edge[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> x[M][M];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(x,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(x));&#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        Matrix res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=cnt;k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">                    res.x[i][j]=<span class="built_in">min</span>(res.x[i][j],x[i][k]+a.x[k][j]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;b;</span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    Matrix res=a;</span><br><span class="line">    --b;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,t,s,e);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=t;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(w,u,v);</span><br><span class="line">        <span class="keyword">if</span>(!a[u]) a[u]=++cnt;</span><br><span class="line">        <span class="keyword">if</span>(!a[v]) a[v]=++cnt;</span><br><span class="line">        b.x[a[u]][a[v]]=b.x[a[v]][a[u]]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    b=<span class="built_in">qpow</span>(b,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b.x[a[s]][a[e]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="模板矩阵求逆"><a
href="https://www.luogu.com.cn/problem/P4783">【模板】矩阵求逆</a></h3>
本题中的矩阵均为方阵。<br />
矩阵的逆：在模 <span class="math inline">\(p\)</span> 意义下，若 <span
class="math inline">\(B\times A=A\times B=I\)</span>，则 <span
class="math inline">\(B\)</span> 称为模 <span
class="math inline">\(p\)</span> 意义下 <span
class="math inline">\(A\)</span> 的逆矩阵，记作 <span
class="math inline">\(A^{-1}\)</span>。模 <span
class="math inline">\(p\)</span>
意义下,一个矩阵若有逆矩阵，则必然只有一个逆矩阵。<br />
矩阵的逆可以用高斯-约旦消元求出。原理：使用初等行变换将矩阵 <span
class="math inline">\(A\)</span> 转化为单位矩阵 <span
class="math inline">\(I\)</span>，同时对一个初始的单位矩阵 <span
class="math inline">\(I\)</span>
进行相同的初等行变换，最终得到的就是逆矩阵 <span
class="math inline">\(A^{-1}\)</span>。<br />
例如，我们构造原矩阵 <span class="math inline">\([A\mid
I]\)</span>，进行一系列初等行变换后，得到 <span
class="math inline">\([I\mid
A^{-1}]\)</span>。我们发现，高斯-约旦消元的过程就是将矩阵的左半部分变为单位矩阵的过程，非常适合求解矩阵的逆。<br />
无解判断：若消元过程中，主元与 <span class="math inline">\(p\)</span>
不互质则无解。<br />

<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>,N=<span class="number">410</span>;</span><br><span class="line"><span class="type">int</span> n,a[N][N*<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">read</span>(a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i][i+n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,cur,line=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cur=line;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=line<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j][i]&gt;a[cur][i])</span><br><span class="line">                cur=j;</span><br><span class="line">        <span class="keyword">if</span>(__gcd(a[cur][i],mod)!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll inv=<span class="built_in">qpow</span>(a[cur][i],mod<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=(n&lt;&lt;<span class="number">1</span>);j++)</span><br><span class="line">            <span class="built_in">swap</span>(a[cur][j],a[line][j]),a[line][j]=a[line][j]*inv%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(j!=line)&#123;</span><br><span class="line">                ll temp=a[j][i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=(n&lt;&lt;<span class="number">1</span>);k++)</span><br><span class="line">                    a[j][k]=((a[j][k]-a[line][k]*temp)%mod+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        ++line;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j+n]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day1112">Day11/12</h1>
<h2 id="离散与组合数学">离散与组合数学</h2>
<h3 id="haoi2008-硬币购物"><a
href="https://www.luogu.com.cn/problem/P1450">[HAOI2008]
硬币购物</a></h3>
背包+容斥。首先求出没有任何限制下每种价值的方案数，设 <span
class="math inline">\(dp_s\)</span> 表示价值为 <span
class="math inline">\(s\)</span>
的方案数。子集枚举计算哪些硬币超出限制，若钦定第 <span
class="math inline">\(i\)</span> 中硬币超出限制，则该硬币至少总价值为
<span class="math inline">\(c_i\times (d_i+1)\)</span>，容斥计算即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,c[<span class="number">4</span>],d[<span class="number">4</span>],s;</span><br><span class="line">ll dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(c[<span class="number">0</span>],c[<span class="number">1</span>],c[<span class="number">2</span>],c[<span class="number">3</span>],n);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=c[i];j&lt;=<span class="number">1e5</span>;j++)</span><br><span class="line">            dp[j]+=dp[j-c[i]];</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(d[<span class="number">0</span>],d[<span class="number">1</span>],d[<span class="number">2</span>],d[<span class="number">3</span>],s);</span><br><span class="line">        ll ans=dp[s];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);i++)&#123;</span><br><span class="line">            ll sum=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>) sum+=c[j]*(d[j]<span class="number">+1ll</span>),++cnt;</span><br><span class="line">            <span class="type">int</span> k=cnt&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s-sum&lt;<span class="number">0</span>||sum==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans+=k*dp[s-sum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="devu-and-flowers"><a
href="https://codeforces.com/problemset/problem/451/E">Devu and
Flowers</a></h3>
在无限制时，通过隔板可以得到答案为 <span
class="math inline">\(\dbinom{n+s-1}{n-1}\)</span>，若加上限制则考虑容斥。枚举子集，则状态
<span class="math inline">\(S\)</span> 中所有子集元素均不合法的方案数为
<span class="math inline">\(\dbinom{s-\sum_{i\in
S}f_i-|S|-1}{n-1}\)</span>。这里不方便直接预处理阶乘算组合数，但是注意到
<span class="math inline">\(\dbinom{n}{m}\)</span> 中，<span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(m\)</span>
相差不会太大，所以可以直接通分后暴力计算。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">25</span>,mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b=mod<span class="number">-2</span>)</span></span>&#123;</span><br><span class="line">    a%=mod;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll s,f[N],inv[N],ans,fact[N];</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=n-m<span class="number">+1</span>;i&lt;=n;i++)</span><br><span class="line">        res=res*(i%mod)%mod;</span><br><span class="line">    <span class="keyword">return</span> res*inv[m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,s);</span><br><span class="line">    fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fact[i]=fact[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[n]=<span class="built_in">qpow</span>(fact[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inv[i]=inv[i<span class="number">+1</span>]*(i<span class="number">+1</span>)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">read</span>(f[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">                ++cnt,sum+=f[j];</span><br><span class="line">        <span class="type">int</span> k=cnt&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">        ans=(ans+k*<span class="built_in">C</span>(s-sum-cnt+n<span class="number">-1</span>,n<span class="number">-1</span>)%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans+mod)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="csp-s2019-江西-多叉堆"><a
href="https://www.luogu.com.cn/problem/P5689">[CSP-S2019 江西]
多叉堆</a></h3>
并查集+组合。考虑合并过程。根一定是 <span
class="math inline">\(0\)</span>，设合并前的大小为 <span
class="math inline">\(size_x\)</span> 和 <span
class="math inline">\(size_y\)</span>，方案数为 <span
class="math inline">\(cnt_x\)</span> 和 <span
class="math inline">\(cnt_y\)</span>，由于子树之间互不干扰，所以 <span
class="math display">\[cnt_{sum}=cnt_x\cdot cnt_y\cdot
\binom{size_x+size_y-1}{size_x}\]</span>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>,N=<span class="number">3e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b=mod<span class="number">-2</span>)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    a%=mod;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q,fact[N],inv[N],siz[N],fa[N],cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;<span class="keyword">return</span> (ll)fact[n]*inv[m]%mod*inv[n-m]%mod;&#125;</span><br><span class="line"><span class="type">int</span> op,x,y,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q);</span><br><span class="line">    fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fact[i]=(ll)fact[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[n]=<span class="built_in">qpow</span>(fact[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inv[i]=(ll)inv[i<span class="number">+1</span>]*(i<span class="number">+1</span>)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i]=i;</span><br><span class="line">        siz[i]=<span class="number">1</span>;</span><br><span class="line">        cnt[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(op,x);</span><br><span class="line">        x=<span class="built_in">find</span>((x+ans)%n<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(y);</span><br><span class="line">            y=<span class="built_in">find</span>((y+ans)%n<span class="number">+1</span>);</span><br><span class="line">            fa[x]=y;</span><br><span class="line">            siz[y]+=siz[x];</span><br><span class="line">            cnt[y]=(ll)cnt[y]*cnt[x]%mod*<span class="built_in">C</span>(siz[y]<span class="number">-1</span>,siz[x])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans=cnt[x];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ceoi-2016-kangaroo"><a
href="https://www.luogu.com.cn/problem/P5999">[CEOI 2016]
kangaroo</a></h3>
连续段 DP，一种很强的东西。<span class="math inline">\(dp_{i,j}\)</span>
表示考虑放前 <span class="math inline">\(i\)</span> 个数，构成 <span
class="math inline">\(j\)</span>
个合法连续段的方案数。在加入一个数时，可以有以下几种情况：<br />
- 并入某一个块，<span class="math inline">\(dp_{i-1,j}\times j\)</span>
种情况。<br />
- 自成一个新块，<span class="math inline">\(dp_{i-1,j-1}\times
j\)</span> 种情况。<br />
- 将原来的两个块连接，合并成一个块，<span
class="math inline">\(dp_{i-1,j+1}\times j\)</span> 种情况。<br />
特判 <span class="math inline">\(s\)</span> 和 <span
class="math inline">\(t\)</span> 的限制。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e3</span><span class="number">+10</span>,mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,s,t,dp[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,s,t);dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==s||i==t) dp[i][j]=(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=(ll)(j-(i&gt;s)-(i&gt;t))*dp[i<span class="number">-1</span>][j<span class="number">-1</span>]%mod;</span><br><span class="line">                dp[i][j]=(dp[i][j]+(ll)dp[i<span class="number">-1</span>][j<span class="number">+1</span>]*j)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[n][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="csp-s2019-emiya-家今天的饭"><a
href="https://www.luogu.com.cn/problem/P5664">[CSP-S2019] Emiya
家今天的饭</a></h3>
考虑使用总方案数减不合法方案数得到答案。总方案数为 <span
class="math display">\[\prod_{i=1}^n\left(1+
\sum_{j=1}^ma_{i,j}\right)-1\]</span> 由于超过 <span
class="math inline">\(\lfloor\dfrac{k}{2}\rfloor\)</span>
的食材最多只可能有一个，所以考虑直接枚举是哪一个食材超限。<span
class="math inline">\(dp_{i,j}\)</span> 表示前 <span
class="math inline">\(i\)</span>
种烹饪方案选菜后，选择的菜品数与已选的总数之差为 <span
class="math inline">\(j\)</span>，转移见代码
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">110</span>,M=<span class="number">2010</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,a[N][M],sum[N],dp[N][N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">read</span>(a[i][j]);</span><br><span class="line">            sum[i]=(sum[i]+a[i][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=ans*(sum[i]<span class="number">+1</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=(ans<span class="number">-1</span>+mod)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=n-j;k&lt;=n+j;k++)</span><br><span class="line">                dp[j][k]=(dp[j<span class="number">-1</span>][k]+(ll)dp[j<span class="number">-1</span>][k<span class="number">-1</span>]*a[j][i]%mod+(ll)dp[j<span class="number">-1</span>][k<span class="number">+1</span>]*(sum[j]-a[j][i]+mod)%mod)%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            ans=(ans-dp[n][j+n]+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day13">Day13</h1>
<p>摆摆摆。</p>
<h1 id="day1415">Day14/15</h1>
<h2 id="单调队列优化-dp">单调队列优化 DP</h2>
<p><del>没错又是我。</del></p>
<h3 id="haoi2007-修筑绿化带"><a
href="https://www.luogu.com.cn/problem/P2219">[HAOI2007]
修筑绿化带</a></h3>
我们可以将所有 <span class="math inline">\(C\times D\)</span>
的矩形权值和缩为一个点记录在二维平面上（例如记录在 <span
class="math inline">\(C\times D\)</span>
矩形的右下角），那么题目就是对于每一个 <span
class="math inline">\(A\times
B\)</span>，在二维平面上取一个矩形内的最小值，这可以使用单调队列。具体地，按行扫一遍，记录答案，然后再按列扫一遍即可。<br />

<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b,c,d,x[N][N],sum[N][N],l,r,minn[N][N],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> val,id;&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">val</span><span class="params">(<span class="type">int</span> t1,<span class="type">int</span> t2,<span class="type">int</span> t3,<span class="type">int</span> t4)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[t3][t4]-sum[t1<span class="number">-1</span>][t4]-sum[t3][t2<span class="number">-1</span>]+sum[t1<span class="number">-1</span>][t2<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,a,b,c,d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x[i][j]);</span><br><span class="line">            sum[i][j]=sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>]+x[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=c;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=d;j&lt;=m;j++)</span><br><span class="line">            minn[i][j]=<span class="built_in">val</span>(i-c<span class="number">+1</span>,j-d<span class="number">+1</span>,i,j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[r].val&gt;=minn[i][j]) --r;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;j-q[l].id&gt;=b-d<span class="number">-1</span>) ++l;</span><br><span class="line">            q[++r]=&#123;minn[i][j],j&#125;;</span><br><span class="line">            minn[i][j]=q[l].val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[r].val&gt;=minn[j][i]) --r;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;j-q[l].id&gt;=a-c<span class="number">-1</span>) ++l;</span><br><span class="line">            q[++r]=&#123;minn[j][i],j&#125;;</span><br><span class="line">            minn[j][i]=q[l].val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=b;j&lt;=m;j++)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">val</span>(i-a<span class="number">+1</span>,j-b<span class="number">+1</span>,i,j)-minn[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="haoi2007-理想的正方形"><a
href="https://www.luogu.com.cn/problem/P2216">[HAOI2007]
理想的正方形</a></h3>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N][N],minn[N][N],maxn[N][N],l,r,x,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> val,id;&#125;q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="built_in">read</span>(a[i][j]),minn[i][j]=maxn[i][j]=a[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;j-q[l].id<span class="number">+1</span>&gt;x) ++l;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[r].val&gt;minn[i][j]) --r;</span><br><span class="line">            q[++r]=&#123;minn[i][j],j&#125;;</span><br><span class="line">            minn[i][j]=q[l].val;</span><br><span class="line">        &#125;</span><br><span class="line">        l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;j-q[l].id<span class="number">+1</span>&gt;x) ++l;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[r].val&lt;maxn[i][j]) --r;</span><br><span class="line">            q[++r]=&#123;maxn[i][j],j&#125;;</span><br><span class="line">            maxn[i][j]=q[l].val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;j-q[l].id<span class="number">+1</span>&gt;x) ++l;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[r].val&gt;minn[j][i]) --r;</span><br><span class="line">            q[++r]=&#123;minn[j][i],j&#125;;</span><br><span class="line">            minn[j][i]=q[l].val;</span><br><span class="line">        &#125;</span><br><span class="line">        l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;j-q[l].id<span class="number">+1</span>&gt;x) ++l;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[r].val&lt;maxn[j][i]) --r;</span><br><span class="line">            q[++r]=&#123;maxn[j][i],j&#125;;</span><br><span class="line">            maxn[j][i]=q[l].val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=x;j&lt;=m;j++)</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,maxn[i][j]-minn[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="斜率优化-dp">斜率优化 DP</h2>
<p>给定一个长为 <span class="math inline">\(n\)</span> 的序列，每个位置
<span class="math inline">\(i\)</span> 有 <span
class="math inline">\(a_i,b_i\)</span>，<span
class="math inline">\(a_i\)</span> 单调递增。<br />
对每个位置 <span class="math inline">\(i\)</span> 求 <span
class="math inline">\(\max_{j&lt;i}(a_jc_i+b_j)\)</span>。<br />
当 <span class="math inline">\(c_i\)</span> 单调时，显然可以使用单调队列
<span class="math inline">\(O(n)\)</span> 解决。<br />
对于每一个 <span class="math inline">\(a_i,b_i\)</span>，都对应一条直线
<span
class="math inline">\(y=a_ix+b_i\)</span>，直接使用单调队列维护一个上凸壳。</p>
<h3 id="hnoi2008-玩具装箱"><a
href="https://www.luogu.com.cn/problem/P3195">[HNOI2008]
玩具装箱</a></h3>
设 <span class="math inline">\(dp_i\)</span> 表示考虑前 <span
class="math inline">\(i\)</span> 个玩具时的最小总费用，设 <span
class="math inline">\(sum_i\)</span> 表示 <span
class="math inline">\(C_i\)</span> 的前缀和，容易得到状态转移方程 <span
class="math display">\[dp_i=\min_{j=0}^{i-1}(dp_j+((sum_i-sum_j)+(i-j-1)-L)^2)\]</span>
设 <span
class="math inline">\(s_i=sum_i+i,L&#39;=L+1\)</span>，方程改写为 <span
class="math display">\[\begin{aligned}
dp_i&amp;=\min_{j=0}^{i-1}(dp_j+(s_i-s_j-L&#39;)^2)\\
&amp;=s_i^2-2L&#39;s_i+\min_{j=0}^{i-1}(-2s_is_j+dp_j+s_j^2+2L&#39;s_j)
\end{aligned}\]</span> 容易发现，斜率 <span
class="math inline">\(a_j=-2s_j\)</span>，截距 <span
class="math inline">\(b_j=dp_j+s_j^2+2L&#39;s_j\)</span>，这样就可以使用单调队列优化了。时间复杂度
<span class="math inline">\(O(n)\)</span>。<br />

<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">5e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,L,c[N],l,r,q[N];</span><br><span class="line">ll sum[N],dp[N],s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">X</span><span class="params">(<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> s[j];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Y</span><span class="params">(<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> dp[j]+s[j]*s[j]<span class="number">+2</span>*(L<span class="number">+1</span>)*s[j];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)(<span class="built_in">Y</span>(j)-<span class="built_in">Y</span>(i))/(<span class="built_in">X</span>(j)-<span class="built_in">X</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,L);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]),sum[i]=sum[i<span class="number">-1</span>]+c[i],s[i]=sum[i]+i;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">    q[++r]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope</span>(q[l],q[l<span class="number">+1</span>])&lt;=<span class="number">2</span>*s[i]) ++l;</span><br><span class="line">        <span class="type">int</span> j=q[l];</span><br><span class="line">        dp[i]=dp[j]+(s[i]-s[j]-(L<span class="number">+1</span>))*(s[i]-s[j]-(L<span class="number">+1</span>));</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope</span>(q[r<span class="number">-1</span>],q[r])&gt;=<span class="built_in">slope</span>(q[r<span class="number">-1</span>],i)) --r;</span><br><span class="line">        q[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="数位-dp">数位 DP</h2>
<h3 id="scoi2009-windy-数加强版"><a
href="https://www.luogu.com.cn/problem/P13085">[SCOI2009] windy
数（加强版）</a></h3>
<span class="math inline">\(dp_{i,j,0/1}\)</span> 表示前 <span
class="math inline">\(i\)</span> 位数（高位），第 <span
class="math inline">\(i\)</span> 位为 <span
class="math inline">\(j\)</span>，是/否被最大限制时的方案数。其中 <span
class="math inline">\(j=10\)</span> 表示高位前导 <span
class="math inline">\(0\)</span>。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">11</span>][<span class="number">2</span>],a,b;</span><br><span class="line">string s;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> pre,<span class="type">bool</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos==(<span class="type">int</span>)s.<span class="built_in">length</span>()) <span class="keyword">return</span> (pre!=<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][pre][limit]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][pre][limit];</span><br><span class="line">    <span class="type">int</span> up=limit?s[pos]-<span class="string">&#x27;0&#x27;</span>:<span class="number">9</span>;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=up;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) res+=<span class="built_in">dfs</span>(pos<span class="number">+1</span>,<span class="number">10</span>,limit&amp;&amp;(i==up));</span><br><span class="line">            <span class="keyword">else</span> res+=<span class="built_in">dfs</span>(pos<span class="number">+1</span>,i,limit&amp;&amp;(i==up));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(i-pre)&gt;=<span class="number">2</span>)</span><br><span class="line">            res+=<span class="built_in">dfs</span>(pos<span class="number">+1</span>,i,limit&amp;&amp;(i==up));</span><br><span class="line">    &#125;</span><br><span class="line">    dp[pos][pre][limit]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    s=<span class="built_in">to_string</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">solve</span>(b)-<span class="built_in">solve</span>(a<span class="number">-1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day1617">Day16/17</h1>
<h2 id="思维技巧">思维技巧</h2>
<p>qmd 学长真的很强啊 orz。<br />
讲了一种很强的思维方式：<strong>观察终态</strong>。<br />
终态一般代指某个函数/解的形态。</p>
<ul>
<li><p>一些题目中需要观察解长什么样子，<strong>寻找解可行的必要条件</strong>，并尝试证明它们是充要的。这种思路常用于无法通过简单方式描述解的场合。</p></li>
<li><p>另一些题目中需要调整，<strong>找到并剔除可能出现的不优的结构</strong>。这种思路常用于解集过于庞大，合法解缺少特殊性的场合。</p></li>
<li><p>还有一些题目中需要<strong>观察解的上下界</strong>。应用场合为<strong>最优化或构造</strong>问题。</p></li>
</ul>
<h3 id="lis-on-tree-2"><a
href="https://atcoder.jp/contests/arc175/tasks/arc175_d">LIS on Tree
2</a></h3>
<p>首先排列是假的，我们直接考虑 dfs 序。LIS
难以以较低复杂度求出，我们重点关注 <span
class="math inline">\(f(i)\)</span>。一个重要的限制是 <span
class="math display">\[f(fa_i)\le f(i)\le f(fa_i)+1,\]</span> <span
class="math display">\[f(1)=1,\]</span>
这样，我们就可以将树划分为若干连通块，每个块内的点对答案贡献相同。构造连通块的方式就是将连通块内的
dfs
序反转，这样就只保留了连通块根部的贡献。这样问题就转化为选择一些子树，使得它们的
<span class="math inline">\(size\)</span> 之和等于 <span
class="math inline">\(K\)</span>。那么，按照 <span
class="math inline">\(size\)</span>
从大到小贪心地选是正确的，证明考虑剥叶子。这主要运用了第一个思想。</p>
<p>另一种方法叫做<strong>规约</strong>。</p>
<ul>
<li><p>首先我们需要解决一个问题，称为问题 1；</p></li>
<li><p>再加如一个问题 2；</p></li>
<li><p>若任何能解决问题 1 的算法都能解决问题 2，则说明问题 2
是<strong>不强于</strong>问题 1 的；</p></li>
</ul>
<p>以上就是规约的步骤。容易发现，它实质上是对问题的转化。</p>
<h3 id="delete-aab-or-baa"><a
href="https://atcoder.jp/contests/agc066/tasks/agc066_c">Delete AAB or
BAA</a></h3>
<p>规约：考虑将原问题转化为：给一个只含 <code>A</code> 和 <code>B</code>
的串，按照 <code>AAB</code> 或 <code>BAA</code>
的形式删除，问能否删成空串。尝试观察终态，发现：</p>
<ul>
<li><p>一个子串能被删空的必要条件是 <code>A</code> 的数量是
<code>B</code> 数量的 <span class="math inline">\(2\)</span>
倍；</p></li>
<li><p>若一个串被切成两个子串，且这两个子串能被删空，则它也必然能被删空；</p></li>
</ul>
<p>根据观察 2，我们考虑不能被断开但是能被删空的串 <code>ABAAAB</code>
如何描述。<br />
结论：</p>
<ul>
<li>符合观察 1，且串首位不同的串是可被删空的串。</li>
</ul>
<p>接下来研究原问题：<br />
约定：<span class="math inline">\([l,r]\)</span> 表示 <span
class="math inline">\(S\)</span> 从 <span
class="math inline">\(S_l\)</span> 到 <span
class="math inline">\(S_r\)</span> 之间含 <span
class="math inline">\(S_l,S_r\)</span> 的子串。<br />
考虑 dp。设 <span class="math inline">\(f_i\)</span> 表示 <span
class="math inline">\([1,i]\)</span> 中最多执行的操作数。转移： <span
class="math display">\[f_i=\max(f_{i-1},\max_{i\le j\le \lfloor
i/3\rfloor \land [i-3j+1,i] 能被删空}f_{i-3j}+j)\]</span></p>
]]></content>
      <tags>
        <tag>题目合集</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/2025/07/04/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p>我们发现：在树上维护一些信息不方便我们套用一些数据结构，但树链剖分可以将树分割为若干条链。树链剖分的方式有很多种，在算法竞赛中，应用最广泛的是重链剖分。
一般使用线段树维护。 定义：
重子节点为当前节点的所有儿子中子树最大的子节点，从这个节点到重子节点的边叫做重边，重边相连构成重链。与之对应地，有轻子节点，轻边。
<img
src="https://github.com/headless-piston/blog_images/blob/main/heavy-light%20decomposition.png?raw=true"
alt="image" /></p>
<p>树链剖分的实现使用了 2 遍 dfs，分别记录了不同信息。 ### dfs1
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	dep[u]=dep[f]<span class="number">+1</span>;<span class="comment">//深度 </span></span><br><span class="line">	siz[u]=<span class="number">1</span>;<span class="comment">//子树大小 </span></span><br><span class="line">	fa[u]=f;<span class="comment">//父节点 </span></span><br><span class="line">	<span class="type">int</span> maxson=<span class="number">-1</span>;<span class="comment">//子节点中最大的siz，也就是重儿子所对的siz </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v!=f)&#123;</span><br><span class="line">			<span class="built_in">dfs1</span>(v,u);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			<span class="keyword">if</span>(siz[v]&gt;maxson)&#123;</span><br><span class="line">				son[u]=v;<span class="comment">//重儿子 </span></span><br><span class="line">				maxson=siz[v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这里，维护了每个节点的深度，父节点和子树大小最大的子节点。
### dfs2 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">	dfn[u]=++cnt;<span class="comment">//dfn序，也就是线段树上的编号 </span></span><br><span class="line">	top[u]=topf;<span class="comment">//当前树链的最顶端节点 </span></span><br><span class="line">	w1[cnt]=w[u];<span class="comment">//新的权值 </span></span><br><span class="line">	<span class="keyword">if</span>(!son[u])</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">dfs2</span>(son[u],topf);<span class="comment">//重儿子的处理 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v!=fa[u]&amp;&amp;v!=son[u])<span class="comment">//轻儿子的处理 </span></span><br><span class="line">			<span class="built_in">dfs2</span>(v,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这里，维护了每个节点的
dfn，每个节点所在重链的链顶和使用 dfn 编号的点权。 使用 dfn 的原因是 dfn
可以保证同一子树内的点在一个连续的区间内，方便使用数据结构进行维护。</p>
<h3 id="查询操作">查询操作</h3>
<p>树链剖分完毕后，我们就可以借助数据结构求任意点 <span
class="math inline">\(x\)</span> 的子树的相关信息。
例如，查询子树所有节点权值之和。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//维护区间和的线段树</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="number">-1</span>));</span><br></pre></td></tr></table></figure> 可以证明，<span
class="math inline">\(x\)</span> 的子树所对的区间是 <span
class="math inline">\(x\)</span> 的 dfn 到 <span
class="math inline">\(x\)</span> 的 dfn 加 <span
class="math inline">\(x\)</span> 的子树大小减 <span
class="math inline">\(1\)</span>。</p>
<p>树链剖分还有一个强大的功能：求 LCA。
不断向上跳重链，当跳到同一条重链上时，深度较小的结点即为 LCA。
向上跳重链时需要先跳所在重链顶端深度较大的那个。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[u]]&gt;dep[top[v]])</span><br><span class="line">			u=fa[top[u]];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			v=fa[top[v]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[u]&gt;dep[v]?v:u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
类似地，我们就可以对任意点 <span class="math inline">\(x\)</span> 到
<span class="math inline">\(y\)</span> 路径上的点权进行查询和修改。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tree_sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//x到y路径上的和 </span></span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">			std::<span class="built_in">swap</span>(x,y);</span><br><span class="line">		ans=(ans+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x]))%p;</span><br><span class="line">		x=fa[top[x]];<span class="comment">//跳到链顶的父节点 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&gt;dep[y])</span><br><span class="line">		std::<span class="built_in">swap</span>(x,y);</span><br><span class="line">	ans=(ans+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y]))%p;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree_add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;<span class="comment">//x到y最短路径上所有节点值加k </span></span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">			std::<span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x],k);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&gt;dep[y])</span><br><span class="line">		std::<span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y],k);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> *注：对 <span class="math inline">\(p\)</span>
取模是题目要求。</p>
<p>如果边权下放点权维护边信息，不想累加 LCA 处的贡献，可以这么写：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        res+=<span class="built_in">query</span>(dfn[top[x]],dfn[x]);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) res+=<span class="built_in">query</span>(dfn[x]<span class="number">+1</span>,dfn[y]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>树链剖分的复杂度为 <span class="math inline">\(O(\log
n)\)</span>。而且一般情况下跑不满且常数极小。</p>
<p><a href="https://www.luogu.com.cn/problem/P3384"
title="模板">模板</a></p>
<p><a href="https://oi-wiki.org/graph/hld/"
title="参考资料">参考资料</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题合集</title>
    <url>/2025/07/04/%E6%9D%82%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="abc_405e"><a
href="https://atcoder.jp/contests/abc405/tasks/abc405_e"
title="abc_405e">abc_405e</a></h3>
<p>简单组合计数。形式化地说，A 必须在 C 左边，A 必须在 D 左边，B 必须在
D 左边，不难发现应对 C 进行分割，左半部分与 B 重合，而右半部分与 D
重合。如图 <img
src="https://github.com/headless-piston/blog_images/blob/main/abc405e.png?raw=true"
alt="image" /> 枚举 C 中的断点 <span
class="math inline">\(i\)</span>，答案即为<br />
<span
class="math display">\[\sum_{i=0}^{c}\binom{a+b+i}{b}\binom{c-i+d-1}{d-1}\]</span><br />
预处理阶乘和逆元可以做到 <span class="math inline">\(O(n)\)</span>。</p>
<h3 id="模板通信题"><a href="https://www.luogu.com.cn/problem/P12509"
title="【模板】通信题">【模板】通信题</a></h3>
<p>通信题真好玩。 我们只能使用不大于 <span
class="math inline">\(2^{20}\)</span>
的非负整数存储状态。注意到这个数刚好比 <span
class="math inline">\(10^6\)</span>
略大。这给我们对每一位附上不同权值提供了方便。考虑利用异或运算的性质，给每一位附上当前字符下标的权值（下标从
<span class="math inline">\(1\)</span>）开始，然后求其异或和。将 <span
class="math inline">\(S\)</span> 和 <span
class="math inline">\(T\)</span> 的结果异或起来即得答案。注意下标一定从
<span class="math inline">\(1\)</span> 开始，否则第一位的值无论如何都是
<span class="math inline">\(0\)</span>。</p>
<details>
<summary>
communication.cpp
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Alice</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S.<span class="built_in">length</span>();i++)</span><br><span class="line">        res^=(i<span class="number">+1</span>)*(S[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bob</span><span class="params">(string T,<span class="type">int</span> X)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.<span class="built_in">length</span>();i++)</span><br><span class="line">        res^=(i<span class="number">+1</span>)*(T[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> X^res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="mdoi-r1group"><a href="https://www.luogu.com.cn/problem/P6069"
title="『MdOI R1』Group">『MdOI R1』Group</a></h3>
<p>二分答案。 注意到，对 <span class="math inline">\(a\)</span>
进行排序，则我们可以选中其中一段连续的区间，计算它的方差。而两侧的值直接设为区间的平均值，不产生贡献。这样是最优策略。在检查合法性时直接从
<span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span>
枚举区间就好了，预处理前缀和和前缀平方和可做到 <span
class="math inline">\(O(1)\)</span> 求方差。 二分时，<span
class="math inline">\(l\)</span> 必须从 <span
class="math inline">\(1\)</span> 开始。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],l,r;</span><br><span class="line">ll m,sum[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=l+len<span class="number">-1</span>;r&lt;=n;l++,r++)&#123;</span><br><span class="line">        ll s=sum[r][<span class="number">0</span>]-sum[l<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">double</span> p=<span class="number">1.0</span>*s/len;</span><br><span class="line">        <span class="type">double</span> res=len*p*p;</span><br><span class="line">        res-=<span class="number">2</span>*s*p;</span><br><span class="line">        res+=sum[r][<span class="number">1</span>]-sum[l<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(res&lt;=m)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    std::<span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum[i][<span class="number">0</span>]=sum[i<span class="number">-1</span>][<span class="number">0</span>]+a[i];</span><br><span class="line">        sum[i][<span class="number">1</span>]=sum[i<span class="number">-1</span>][<span class="number">1</span>]<span class="number">+1ll</span>*a[i]*a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l=<span class="number">1</span>,r=n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">            l=mid<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="noip-2014-提高组-飞扬的小鸟"><a
href="https://www.luogu.com.cn/problem/P1941"
title="[NOIP 2014 提高组] 飞扬的小鸟">[NOIP 2014 提高组]
飞扬的小鸟</a></h3>
<span class="math inline">\(dp_{i,j}\)</span> 表示在 <span
class="math inline">\((i,j)\)</span>
所用的最少点击屏幕数，显然有朴素转移方程 <span
class="math display">\[dp_{i,j}=\min(dp_{i,j},dp_{i-1,j-k\times
x_{i-1}},dp_{i-1,j+y_{i-1}})\]</span> 时间复杂度 <span
class="math inline">\(O(nm^2)\)</span>。 考虑优化，复杂度瓶颈在于 <span
class="math inline">\(k\)</span>
的枚举。我们发现，可以使用类似完全背包的处理，从 <span
class="math inline">\(dp_{i,j-(k-1)\times x_{i-1}}\)</span> 转移到 <span
class="math inline">\(dp_{i,j-k\times x_{i-1}}\)</span> 而不必从 <span
class="math inline">\(dp_{i-1}\)</span> 转移。时间复杂度 <span
class="math inline">\(O(nm)\)</span>。
注意要先处理点击屏幕的情况，否则可能出现同一横坐标既向下又向上的情况。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b,<span class="type">const</span> Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Min</span>(<span class="built_in">Min</span>(a,b),args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>,M=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,x[N],y[N],dp[N][M],cnt,res;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,h;</span><br><span class="line">&#125;c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">read</span>(x[i],y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,p;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(p);</span><br><span class="line">        <span class="built_in">read</span>(c[p].l,c[p].h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        dp[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=x[i<span class="number">-1</span>]<span class="number">+1</span>;j&lt;=m;j++)</span><br><span class="line">            dp[i][j]=<span class="built_in">Min</span>(dp[i][j],dp[i<span class="number">-1</span>][j-x[i<span class="number">-1</span>]]<span class="number">+1</span>,dp[i][j-x[i<span class="number">-1</span>]]<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m-x[i<span class="number">-1</span>];j&lt;=m;j++)</span><br><span class="line">            dp[i][m]=<span class="built_in">Min</span>(dp[i][m],dp[i<span class="number">-1</span>][j]<span class="number">+1</span>,dp[i][j]<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j+y[i<span class="number">-1</span>]&lt;=m;j++)</span><br><span class="line">            dp[i][j]=<span class="built_in">Min</span>(dp[i][j],dp[i<span class="number">-1</span>][j+y[i<span class="number">-1</span>]]);</span><br><span class="line">        <span class="keyword">if</span>(c[i].h)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c[i].l;j++)</span><br><span class="line">                dp[i][j]=inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=c[i].h;j&lt;=m;j++)</span><br><span class="line">                dp[i][j]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]!=inf)&#123;</span><br><span class="line">                f=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(f)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n%d\n&quot;</span>,cnt<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        res=<span class="built_in">Min</span>(res,dp[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1\n%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="邦邦的大合唱站队"><a
href="https://www.luogu.com.cn/problem/P3694"
title="邦邦的大合唱站队">邦邦的大合唱站队</a></h3>
<p>状压
DP，每一位表示一种乐队。预处理前缀和计算长度。代码实现也很简单。<del>（很久没有独立想出过
DP 题了）</del></p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,dp[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],sum[N][<span class="number">30</span>],len[<span class="number">1</span>&lt;&lt;<span class="number">21</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; t[<span class="number">30</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        sum[i][a<span class="number">-1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            sum[i][j]+=sum[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,bitcnt;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)&#123;</span><br><span class="line">        bitcnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                bitcnt++;</span><br><span class="line">                len[i]+=sum[n][j];</span><br><span class="line">            &#125;</span><br><span class="line">        t[bitcnt].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p:t[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=p;j;j^=<span class="built_in">lowbit</span>(j))&#123;</span><br><span class="line">                <span class="type">int</span> k=<span class="built_in">lowbit</span>(j);</span><br><span class="line">                dp[p]=<span class="built_in">Min</span>(dp[p],dp[p^k]+len[p]-len[p^k]-(sum[len[p]][__lg(k)]-sum[len[p^k]][__lg(k)]));</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="可持久化并查集"><a href="https://www.luogu.com.cn/problem/P3402"
title="可持久化并查集">可持久化并查集</a></h3>
<p>用可持久化数组实现。使用按秩合并但不使用路径压缩。注意修改 <span
class="math inline">\(fa\)</span> 与修改 <span
class="math inline">\(dep\)</span> 都要新建版本。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T c=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>,M=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> ls,rs,fa,dep;</span><br><span class="line">&#125;tree[N*<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> nodetot,root[M],n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    u=++nodetot;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[u].fa=l;</span><br><span class="line">        tree[u].dep=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(tree[u].ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(tree[u].rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_fa</span><span class="params">(<span class="type">int</span> old,<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    u=++nodetot;</span><br><span class="line">    tree[u]=tree[old];</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[u].fa=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="built_in">modify_fa</span>(tree[old].ls,tree[u].ls,l,mid,x,k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">modify_fa</span>(tree[old].rs,tree[u].rs,mid<span class="number">+1</span>,r,x,k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_dep</span><span class="params">(<span class="type">int</span> old,<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    u=++nodetot;</span><br><span class="line">    tree[u]=tree[old];</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[u].dep++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="built_in">modify_dep</span>(tree[old].ls,tree[u].ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">modify_dep</span>(tree[old].rs,tree[u].rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_fa</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">        <span class="keyword">return</span> tree[u].fa;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_fa</span>(tree[u].ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_fa</span>(tree[u].rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_dep</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">        <span class="keyword">return</span> tree[u].dep;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_dep</span>(tree[u].ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_dep</span>(tree[u].rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> ver,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">query_fa</span>(root[ver],<span class="number">1</span>,n,x);</span><br><span class="line">    <span class="keyword">if</span>(fx==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(ver,fx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> ver,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(ver<span class="number">-1</span>,x);</span><br><span class="line">    y=<span class="built_in">find</span>(ver<span class="number">-1</span>,y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">        root[ver]=root[ver<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> depx=<span class="built_in">query_dep</span>(root[ver<span class="number">-1</span>],<span class="number">1</span>,n,x),depy=<span class="built_in">query_dep</span>(root[ver<span class="number">-1</span>],<span class="number">1</span>,n,y);</span><br><span class="line">    <span class="keyword">if</span>(depx&gt;depy)</span><br><span class="line">        <span class="built_in">Swap</span>(x,y);</span><br><span class="line">    <span class="built_in">modify_fa</span>(root[ver<span class="number">-1</span>],root[ver],<span class="number">1</span>,n,x,y);</span><br><span class="line">    <span class="keyword">if</span>(depx==depy)</span><br><span class="line">        <span class="built_in">modify_dep</span>(root[ver],root[ver],<span class="number">1</span>,n,y);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> opt,a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">build</span>(root[<span class="number">0</span>],<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(opt);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(a,b);</span><br><span class="line">            <span class="built_in">merge</span>(i,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(a);</span><br><span class="line">            root[i]=root[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">read</span>(a,b);</span><br><span class="line">            root[i]=root[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i,a)==<span class="built_in">find</span>(i,b))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="pa-2024-modernizacja-bajtocji"><a
href="https://www.luogu.com.cn/problem/P10350"
title="[PA 2024] Modernizacja Bajtocji">[PA 2024] Modernizacja
Bajtocji</a></h3>
<p>挺喜欢这道题，但出在模拟赛里我就不喜欢了。
显然需要维护连通块，连通块内出现环了就说明都有电脑了，连通块是树形的就无法确定。然而这里有一个删除操作。并查集不好进行删除，我们发现被删的点留在连通块内无影响，则考虑对每个人维护
<span class="math inline">\(id\)</span>，删除即为更新 <span
class="math inline">\(id\)</span>。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T c=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.3e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> fa[N],siz[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,id[N],have[N],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        fa[i]=i,siz[i]=<span class="number">1</span>,id[i]=i;</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            a=id[a];</span><br><span class="line">            <span class="type">int</span> p=<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">if</span>(siz[p]==<span class="number">1</span>)</span><br><span class="line">                cout&lt;&lt;have[p];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(have[p])</span><br><span class="line">                cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            a=id[a],b=id[b];</span><br><span class="line">            <span class="type">int</span> p=<span class="built_in">find</span>(a),q=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(p==q)</span><br><span class="line">                have[p]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fa[q]=p;</span><br><span class="line">                siz[p]+=siz[q];</span><br><span class="line">                have[p]|=have[q];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            <span class="type">int</span> a1=a;</span><br><span class="line">            a=id[a];</span><br><span class="line">            <span class="type">int</span> p=<span class="built_in">find</span>(a);</span><br><span class="line">            siz[p]--;</span><br><span class="line">            id[a1]=++cnt;</span><br><span class="line">            fa[cnt]=cnt;</span><br><span class="line">            siz[cnt]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="模板最长公共子序列"><a
href="https://www.luogu.com.cn/problem/P1439"
title="【模板】最长公共子序列">【模板】最长公共子序列</a></h3>
<p>好早以前欠的一道题，现在补上。 朴素 DP <span
class="math inline">\(O(n^2)\)</span>，但这题可以转化为求最长上升子序列。将序列
<span class="math inline">\(P_1\)</span> 视为是“有序的”，按照 <span
class="math inline">\(P_1\)</span> 的排序规则在 <span
class="math inline">\(P_2\)</span>
中求最长上升子序列，显然这就是答案。实现方面的话开个桶就行。
最长上升子序列 <span class="math inline">\(O(n\log n)\)</span> 求法： 设
<span class="math inline">\(dp_i\)</span> 表示到第 <span
class="math inline">\(i\)</span> 个数时的答案，<span
class="math inline">\(t_i\)</span> 表示 <span
class="math inline">\(dp_i\)</span> 对应的序列最大值，显然有 <span
class="math inline">\(dp_i=\max_{j&lt;i \land t_j&lt;b_i}
dp_j\)</span>，我们可以用树状数组维护前缀 <span
class="math inline">\(\max\)</span>，实现 <span
class="math inline">\(O(n\log n)\)</span> 的时间复杂度。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],b[N],dp[N],ans;</span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        tree[x]=<span class="built_in">Max</span>(tree[x],k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x^=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        res=<span class="built_in">Max</span>(tree[x],res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,t;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(t),a[t]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i]);</span><br><span class="line">        dp[i]=<span class="built_in">query</span>(a[b[i]])<span class="number">+1</span>;</span><br><span class="line">        <span class="built_in">modify</span>(a[b[i]],dp[i]);</span><br><span class="line">        ans=<span class="built_in">Max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="cqoi2017-小q的棋盘"><a
href="https://www.luogu.com.cn/problem/P3698"
title="[CQOI2017] 小Q的棋盘">[CQOI2017] 小Q的棋盘</a></h3>
<p>也是模拟赛的史，可以树形 DP，但我选择贪。
优先走最长链，如果还有剩余步数就需要每两步访问一个新节点。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(<span class="type">const</span> T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;y?y:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">114</span>;</span><br><span class="line"><span class="type">int</span> v,n,maxdep;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">    maxdep=<span class="built_in">Max</span>(maxdep,dep);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u,dep<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(v,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;v;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a,b);</span><br><span class="line">        a++,b++;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=maxdep<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Min</span>(v,maxdep+(n-maxdep<span class="number">+1</span>)/<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="sza-cloakroom"><a href="https://www.luogu.com.cn/problem/P3537"
title="SZA-Cloakroom">SZA-Cloakroom</a></h3>
<p>很巧妙的一道 DP。显然可以将物品和询问离线下来分别按时间排序。设 <span
class="math inline">\(dp_k\)</span> 表示总价值为 <span
class="math inline">\(k\)</span> 的物品能拿走的最后的时间。转移 <span
class="math display">\[dp_k=\max(dp_k,\min(dp_k-c_j,b_j))\]</span>
表示新加入物品 <span class="math inline">\(j\)</span>，我们能否凑出
<span class="math inline">\(k\)</span>
决定于最早被取走的那个物品的时间，所以取 <span
class="math inline">\(\min\)</span>，而我们显然希望这个值越晚越好，所以取
<span class="math inline">\(\max\)</span>，则只要 <span
class="math inline">\(dp_k&gt;m_i+s_i\)</span> 就说明合法。 初始状态所有
<span class="math inline">\(dp\)</span> 均为 <span
class="math inline">\(-\inf\)</span>，表示均不合法。<span
class="math inline">\(dp_0\)</span> 为 <span
class="math inline">\(\inf\)</span> 表示不选任何物品总是可行的。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>,M=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> c,a,b;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&lt;x.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">    <span class="type">int</span> m,k,s,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> query &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m&lt;x.m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[M];</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="type">const</span> T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x&lt;y?y:x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x&lt;y?x:y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,p,dp[<span class="number">100010</span>],ans[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;t[i].c&gt;&gt;t[i].a&gt;&gt;t[i].b;</span><br><span class="line">    <span class="built_in">sort</span>(t<span class="number">+1</span>,t<span class="number">+1</span>+n);</span><br><span class="line">    cin&gt;&gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">        cin&gt;&gt;q[i].m&gt;&gt;q[i].k&gt;&gt;q[i].s,q[i].id=i;</span><br><span class="line">    <span class="built_in">sort</span>(q<span class="number">+1</span>,q<span class="number">+1</span>+p);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;t[j].a&lt;=q[i].m&amp;&amp;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">100000</span>;k&gt;=t[j].c;k--)</span><br><span class="line">                dp[k]=<span class="built_in">Max</span>(dp[k],<span class="built_in">Min</span>(dp[k-t[j].c],t[j].b));</span><br><span class="line">        ans[q[i].id]=dp[q[i].k]&gt;(q[i].m+q[i].s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">        <span class="built_in">printf</span>(ans[i]?<span class="string">&quot;TAK\n&quot;</span>:<span class="string">&quot;NIE\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="abc_288f"><a
href="https://atcoder.jp/contests/abc288/tasks/abc288_f"
title="abc_288f">abc_288f</a></h3>
<p>设 <span class="math inline">\(dp_i\)</span> 表示前 <span
class="math inline">\(i\)</span> 位的答案，有朴素的转移 <span
class="math display">\[dp_i=\sum_{j=1}^{i-1} dp_j\times
\overline{X_{j+1}X_{j+2}\cdots X_i}\]</span> 化简： <span
class="math display">\[dp_i=10\times dp_{i-1}+X_i+X_i\times
\sum_{j=1}^{i-1}dp_j\]</span> 可以维护前缀和实现 <span
class="math inline">\(O(n)\)</span>。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,x;</span><br><span class="line">ll sum,dp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %1d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">    dp=sum=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;x);</span><br><span class="line">        dp=(dp*<span class="number">10</span>%mod+sum*x%mod+x)%mod;</span><br><span class="line">        sum=(sum+dp)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="小-a-和-uim-之大逃离"><a
href="https://www.luogu.com.cn/problem/P1373"
title="小 a 和 uim 之大逃离">小 a 和 uim 之大逃离</a></h3>
<p>我们事实上只关注二者的差，所以无需分别记录状态。<span
class="math inline">\(dp_{i,j,t,0/1}\)</span> 表示在 <span
class="math inline">\((i,j)\)</span>，二者之差为 <span
class="math inline">\(t\)</span>，当前应为小 a/uim
走。转移很朴素，看代码吧。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">810</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,a[N][N],dp[N][N][<span class="number">20</span>][<span class="number">2</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    k++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            dp[i][j][a[i][j]%k][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=k;t++)&#123;</span><br><span class="line">                dp[i][j][t][<span class="number">0</span>]=(dp[i][j][t][<span class="number">0</span>]+dp[i<span class="number">-1</span>][j][(t-a[i][j]+k)%k][<span class="number">1</span>])%mod;</span><br><span class="line">                dp[i][j][t][<span class="number">0</span>]=(dp[i][j][t][<span class="number">0</span>]+dp[i][j<span class="number">-1</span>][(t-a[i][j]+k)%k][<span class="number">1</span>])%mod;</span><br><span class="line">                dp[i][j][t][<span class="number">1</span>]=(dp[i][j][t][<span class="number">1</span>]+dp[i<span class="number">-1</span>][j][(t+a[i][j])%k][<span class="number">0</span>])%mod;</span><br><span class="line">                dp[i][j][t][<span class="number">1</span>]=(dp[i][j][t][<span class="number">1</span>]+dp[i][j<span class="number">-1</span>][(t+a[i][j])%k][<span class="number">0</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            ans=(ans+dp[i][j][<span class="number">0</span>][<span class="number">1</span>])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="sdoi2010-地精部落"><a
href="https://www.luogu.com.cn/problem/P2467"
title="[SDOI2010] 地精部落">[SDOI2010] 地精部落</a></h3>
<p><span class="math inline">\(dp_{j,0/1}\)</span> 表示前 <span
class="math inline">\(i\)</span> 个数中最后一个是第 <span
class="math inline">\(j\)</span> 大的数的升/降序方案数。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4210</span>;</span><br><span class="line"><span class="type">int</span> n,p,dp[N][<span class="number">2</span>],sum[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    sum[<span class="number">1</span>][<span class="number">0</span>]=sum[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            dp[j][<span class="number">0</span>]=sum[j<span class="number">-1</span>][<span class="number">1</span>]%p;</span><br><span class="line">            dp[j][<span class="number">1</span>]=(sum[i<span class="number">-1</span>][<span class="number">0</span>]-sum[j<span class="number">-1</span>][<span class="number">0</span>]+p)%p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            sum[j][<span class="number">0</span>]=(dp[j][<span class="number">0</span>]+sum[j<span class="number">-1</span>][<span class="number">0</span>])%p;</span><br><span class="line">            sum[j][<span class="number">1</span>]=(dp[j][<span class="number">1</span>]+sum[j<span class="number">-1</span>][<span class="number">1</span>])%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(sum[n][<span class="number">0</span>]+sum[n][<span class="number">1</span>])%p&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="scoi2009-游戏"><a href="https://www.luogu.com.cn/problem/P4161"
title="[SCOI2009] 游戏">[SCOI2009] 游戏</a></h3>
<p>神仙题，转化太难想了。观察题目给的实例，发现转化关系可分为 <span
class="math inline">\(3\)</span>
组，不难看出每组的周期应为该组内元素数量，总排数即为各组的元素数的 <span
class="math inline">\(\operatorname{lcm}\)</span> 再加 <span
class="math inline">\(1\)</span>。接下来想如何不重地枚举所有对应关系。考虑使用质因数分解。使用类似完全背包的写法，这样就保证了所有方案的枚举。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,prime[N],e[N],tot;</span><br><span class="line">ll dp[N],res;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!e[i])</span><br><span class="line">            prime[e[i]=++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=e[i]&amp;&amp;prime[j]*i&lt;=n;j++)</span><br><span class="line">            e[prime[j]*i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=prime[i];j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=prime[i];k&lt;=j;k*=prime[i])</span><br><span class="line">                dp[j]+=dp[j-k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        res+=dp[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="lnoi2019-真正的-oier-从不女装"><a
href="https://www.luogu.com.cn/problem/P5500"
title="[LnOI2019] 真正的 OIer 从不女装">[LnOI2019] 真正的 OIer
从不女装</a></h3>
<p>我们发现，女装只有零次和无数次。所以将 <span
class="math inline">\(k&gt;0\)</span> 的情况视为 <span
class="math inline">\(k=1\)</span>。线段树维护区间最长连续段、包含最左/右端最长连续段。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::max;</span><br><span class="line"><span class="keyword">using</span> std::min;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> maxn,maxl,maxr,tag,vall,valr,len;</span><br><span class="line">    <span class="built_in">Seg</span>(<span class="type">int</span> maxn=<span class="number">0</span>,<span class="type">int</span> maxl=<span class="number">0</span>,<span class="type">int</span> maxr=<span class="number">0</span>,<span class="type">int</span> tag=<span class="number">0</span>,<span class="type">int</span> vall=<span class="number">0</span>,<span class="type">int</span> valr=<span class="number">0</span>,<span class="type">int</span> len=<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">maxn</span>(maxn),<span class="built_in">maxl</span>(maxl),<span class="built_in">maxr</span>(maxr),<span class="built_in">tag</span>(tag),<span class="built_in">vall</span>(vall),<span class="built_in">valr</span>(valr),<span class="built_in">len</span>(len)&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> Seg <span class="keyword">operator</span>+(<span class="type">const</span> Seg &amp;a,<span class="type">const</span> Seg &amp;b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a.len) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(!b.len) <span class="keyword">return</span> a;</span><br><span class="line">        Seg res;</span><br><span class="line">        res.maxn=<span class="built_in">max</span>(a.maxn,b.maxn);</span><br><span class="line">        res.maxl=a.maxl,res.maxr=b.maxr;</span><br><span class="line">        res.vall=a.vall,res.valr=b.valr;</span><br><span class="line">        res.len=a.len+b.len;</span><br><span class="line">        <span class="keyword">if</span>(a.valr==b.vall)&#123;</span><br><span class="line">            res.maxn=<span class="built_in">max</span>(res.maxn,a.maxr+b.maxl);</span><br><span class="line">            <span class="keyword">if</span>(a.maxl==a.len) res.maxl+=b.maxl;</span><br><span class="line">            <span class="keyword">if</span>(b.maxr==b.len) res.maxr+=a.maxr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="built_in">read</span>(val);</span><br><span class="line">        tree[u]=<span class="built_in">Seg</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,val,val,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    tree[u]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[u].tag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> lenl=tree[ls].len,lenr=tree[rs].len,val=tree[u].tag;</span><br><span class="line">    tree[ls]=<span class="built_in">Seg</span>(lenl,lenl,lenl,val,val,val,lenl);</span><br><span class="line">    tree[rs]=<span class="built_in">Seg</span>(lenr,lenr,lenr,val,val,val,lenr);</span><br><span class="line">    tree[u].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> len=tree[u].len;</span><br><span class="line">        tree[u]=<span class="built_in">Seg</span>(len,len,len,k,k,k,len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(ls,l,mid,x,y,k);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">    tree[u]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Seg <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r) <span class="keyword">return</span> tree[u];</span><br><span class="line">    Seg res;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) res=res+<span class="built_in">query</span>(ls,l,mid,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) res=res+<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x,y,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(ch!=<span class="string">&#x27;R&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;Q&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">read</span>(x,y,k);</span><br><span class="line">        <span class="keyword">if</span>(ch^<span class="string">&#x27;Q&#x27;</span>) <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y).maxn);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Seg temp=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">            <span class="type">int</span> res=temp.maxn;</span><br><span class="line">            <span class="keyword">if</span>(temp.vall==temp.valr) res=<span class="built_in">max</span>(res,temp.maxl+temp.maxr);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">min</span>(res,temp.len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="noip-2004-提高组-合并果子-加强版"><a
href="https://www.luogu.com.cn/problem/P6033"
title="[NOIP 2004 提高组] 合并果子 加强版">[NOIP 2004 提高组] 合并果子
加强版</a></h3>
<p>传统做法中堆的 <span class="math inline">\(O(n\log n)\)</span>
复杂度太高了，我们使用两个队列，先桶排，然后按顺序插入队列 <span
class="math inline">\(q_1\)</span> 中，之后每合并一次就将结果插入队列
<span class="math inline">\(q_2\)</span> 中，容易发现，<span
class="math inline">\(q_1\)</span> 和 <span
class="math inline">\(q_2\)</span>
都具有单调性，所以每次只需从两个队列的队头取出 <span
class="math inline">\(2\)</span> 个最小的数即可。时间复杂度 <span
class="math inline">\(O(n)\)</span>。注意读入的常数。 使用这种思路，做
<a href="https://www.luogu.com.cn/problem/P2827"
title="[NOIP 2016 提高组] 蚯蚓">[NOIP 2016 提高组] 蚯蚓</a>。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getchar getchar_unlocked</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a,b[M];</span><br><span class="line">queue&lt;ll&gt; q1,q2;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="function">ll <span class="title">get_min</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q<span class="number">1.</span><span class="built_in">empty</span>())&#123;</span><br><span class="line">        ll x=q<span class="number">2.f</span>ront();</span><br><span class="line">        q<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q<span class="number">2.</span><span class="built_in">empty</span>())&#123;</span><br><span class="line">        ll x=q<span class="number">1.f</span>ront();</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q<span class="number">1.f</span>ront()&lt;q<span class="number">2.f</span>ront())&#123;</span><br><span class="line">        ll x=q<span class="number">1.f</span>ront();</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x=q<span class="number">2.f</span>ront();</span><br><span class="line">    q<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a),b[a]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1e5</span>;i++)</span><br><span class="line">        <span class="keyword">while</span>(b[i]--)</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ll x=<span class="built_in">get_min</span>(),y=<span class="built_in">get_min</span>();</span><br><span class="line">        q<span class="number">2.</span><span class="built_in">push</span>(x+y);</span><br><span class="line">        sum+=x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="多人背包"><a href="https://www.luogu.com.cn/problem/P1858"
title="多人背包">多人背包</a></h3>
<p>也是很久以前的题，之前好几次想写都觉得太抽象写不了，今天静下心来想一想其实并不难。
<span class="math inline">\(dp_{j,k}\)</span> 表示容量为 <span
class="math inline">\(j\)</span> 时的第 <span
class="math inline">\(k\)</span>
优解。我们直接双指针枚举选或不选当前物品，枚举出当前的前 <span
class="math inline">\(k\)</span>
优，将它们存入队列中然后直接转移。时间复杂度 <span
class="math inline">\(O(nvk)\)</span>，空间复杂度 <span
class="math inline">\(O(vk)\)</span>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> k,v,n,a[<span class="number">210</span>],b[<span class="number">210</span>],dp[<span class="number">5010</span>][<span class="number">60</span>],temp[<span class="number">60</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;v&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=a[i];j--)&#123;</span><br><span class="line">            <span class="type">int</span> p1=<span class="number">1</span>,p2=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(cnt&lt;=k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][p1]&gt;dp[j-a[i]][p2]+b[i])</span><br><span class="line">                    temp[++cnt]=dp[j][p1++];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    temp[++cnt]=dp[j-a[i]][p2++]+b[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=k;t++)</span><br><span class="line">                dp[j][t]=temp[t];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        ans+=dp[v][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>题目合集</tag>
      </tags>
  </entry>
  <entry>
    <title>暑假集训题目合集-1</title>
    <url>/2025/07/11/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86-1/</url>
    <content><![CDATA[<p>Day <span class="math inline">\(n\)</span> 指第 <span
class="math inline">\(n\)</span> 个讲课日，模拟赛过屎，不放了。</p>
<h1 id="day1">Day1</h1>
<h2 id="单调队列优化-dp">单调队列优化 DP</h2>
<p>一般形如 <span
class="math inline">\(dp_i=\max_{j\in[l_i,r_i]}(f(j))+g(j)\)</span>
的形式可以进行单调队列优化，其中 <span
class="math inline">\(f(i)\)</span> 是一个关于 <span
class="math inline">\(j\)</span> 的函数，<span
class="math inline">\([l_i,r_i]\)</span> 是滑动窗口。</p>
<h3 id="宝物筛选"><a
href="https://www.luogu.com.cn/problem/P1776">宝物筛选</a></h3>
多重背包优化。<span class="math inline">\(O(nW\log m)\)</span>
的二进制拆分优化就不讲了。<br />
考虑朴素的 <span class="math inline">\(O(nWm)\)</span> 转移： <span
class="math display">\[dp_{j}=\max_{k=0}^{m_i}(dp_{j-k\times
w_i}+k\times v_i)\]</span><br />
尝试改写成适合单调队列优化的形式，按余数分组：<br />
设当前 <span class="math inline">\(r=j\bmod w_i\)</span>，<span
class="math inline">\(t=\lfloor
j/w_i\rfloor\)</span>，状态转移方程改写为： <span
class="math display">\[dp_j=\max_{k=0}^{\min(m_i,t)}(dp_{r+(t-k)\cdot
w_i}+k\cdot v_i)\]</span> 令 <span
class="math inline">\(t&#39;=t-k\)</span>，则 <span
class="math inline">\(k=t-t&#39;\)</span>： <span
class="math display">\[\begin{aligned}
dp_j&amp;=\max(dp_{r+t&#39;\cdot w_i}+(t-t&#39;)\cdot v_i)\\
&amp;=\max(dp_{r+t&#39;\cdot w_i}+t&#39;\cdot v_i)+t\cdot v_i
\end{aligned}\]</span> <span
class="math inline">\(t&#39;\in[\max(0,t-m_i),t]\)</span>，构成一个滑动窗口。<br />
时间复杂度 <span class="math inline">\(O(nW)\)</span>。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">4e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    <span class="type">int</span> val,t;</span><br><span class="line">    <span class="built_in">Queue</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">int</span> val,<span class="type">int</span> t):<span class="built_in">val</span>(val),<span class="built_in">t</span>(t)&#123;&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="type">int</span> n,W,v,w,m,dp[N],l,r,tag,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,W);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(v,w,m);</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">0</span>)&#123;</span><br><span class="line">            tag+=v*m;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;w;d++)&#123;</span><br><span class="line">            l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;d+t*w&lt;=W;t++)&#123;</span><br><span class="line">                <span class="type">int</span> j=t*w+d,val=dp[j]-t*v;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[r].val&lt;=val) --r;</span><br><span class="line">                q[++r]=<span class="built_in">Queue</span>(val,t);</span><br><span class="line">                <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l].t&lt;t-m) ++l;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(q[l].val+t*v,dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=W;i++) ans=<span class="built_in">max</span>(ans,dp[i]+tag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="noi2005-瑰丽华尔兹"><a
href="https://www.luogu.com.cn/problem/P2254">[NOI2005]
瑰丽华尔兹</a></h3>
单调队列优化 DP。<br />
容易想到 <span class="math inline">\(O(nmT)\)</span> 的方程：设 <span
class="math inline">\(dp_{t,i,j}\)</span> 表示在 <span
class="math inline">\((i,j)\)</span> 位置经过 <span
class="math inline">\(t\)</span> 时间的答案，容易写出转移： <span
class="math display">\[dp_{t,i,j}=\max(dp_{t-1,i,j},dp_{t-1,i&#39;,j&#39;}+1)\]</span>
考虑优化成 <span
class="math inline">\(O(nmk)\)</span>，则我们首先将状态优化为 <span
class="math inline">\(dp_{k,i,j}\)</span> 表示第 <span
class="math inline">\(k\)</span> 个区间，在 <span
class="math inline">\((i,j)\)</span> 位置的答案。转移变为 <span
class="math display">\[dp_{k,i,j}=\max(dp_{k-1,i&#39;,j&#39;}+dis)\]</span>
具体地，假设当前在向 <span class="math inline">\(i\)</span>
的正方向滑行，我们可以写出： <span
class="math display">\[dp_{k,i,j}=\max_{pos=i-len_k}^i(dp_{k-1,pos,j}-pos)+i\]</span>
其余三个方向同理，这就可以单调队列优化了。<br />
可以滚动数组去掉 <span class="math inline">\(k\)</span> 这一维。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Abs</span><span class="params">(<span class="type">const</span> T &amp;x)</span></span>&#123;<span class="keyword">return</span> x&lt;<span class="number">0</span>?~x<span class="number">+1</span>:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?b:a;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">210</span>,fx[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,fy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    <span class="type">int</span> val,x,y;</span><br><span class="line">    <span class="built_in">Queue</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">int</span> val,<span class="type">int</span> x,<span class="type">int</span> y):<span class="built_in">val</span>(val),<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;ax,<span class="type">const</span> <span class="type">int</span> &amp;ay,<span class="type">const</span> <span class="type">int</span> &amp;bx,<span class="type">const</span> <span class="type">int</span> &amp;by)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Abs</span>(ax-bx)+<span class="built_in">Abs</span>(ay-by);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,sx,sy,k,dp[N][N],op,l,r,ans;</span><br><span class="line"><span class="type">char</span> s[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">1</span>&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&lt;=m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[x][y]==<span class="string">&#x27;x&#x27;</span>)&#123;</span><br><span class="line">            l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">            x+=fx[op],y+=fy[op];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r&amp;&amp;dp[x][y]&gt;q[r].val+<span class="built_in">dis</span>(x,y,q[r].x,q[r].y)) --r;</span><br><span class="line">        q[++r]=<span class="built_in">Queue</span>(dp[x][y],x,y);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r&amp;&amp;(<span class="built_in">Abs</span>(x-q[l].x)&gt;len||<span class="built_in">Abs</span>(y-q[l].y)&gt;len)) ++l;</span><br><span class="line">        dp[x][y]=<span class="built_in">Max</span>(dp[x][y],q[l].val+<span class="built_in">dis</span>(x,y,q[l].x,q[l].y));</span><br><span class="line">        ans=<span class="built_in">Max</span>(ans,dp[x][y]);</span><br><span class="line">        x+=fx[op],y+=fy[op];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,sx,sy,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>,&amp;s[i][j]);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[sx][sy]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,s,t;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(s,t,op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">dfs</span>(n,j,t-s<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">dfs</span>(<span class="number">1</span>,j,t-s<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">dfs</span>(j,m,t-s<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">dfs</span>(j,<span class="number">1</span>,t-s<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>闲话：《海上钢琴师》真的非常好看！</p>
<h3 id="scoi2010-股票交易"><a
href="https://www.luogu.com.cn/problem/P2569">[SCOI2010]
股票交易</a></h3>
<p>设 <span class="math inline">\(dp_{i,j}\)</span> 表示 <span
class="math inline">\(i\)</span> 天结束时手上有 <span
class="math inline">\(j\)</span> 个股票时的最大收益。转移： -
什么也不做： <span class="math display">\[dp_{i,j}=dp_{i-1,j}\]</span> -
买入： <span class="math display">\[dp_{i,j}=\max(dp_{i-W-1,j-k}-k\times
AP_i)\]</span> - 卖出： <span
class="math display">\[dp_{i,j}=\max(dp_{i-W-1,j+k}+k\times
BP_i)\]</span></p>
第一个式子没有研究价值，我们看后两个。将式子转化，用 <span
class="math inline">\(k&#39;\)</span> 分别代替 <span
class="math inline">\(j-k\)</span> 和 <span
class="math inline">\(j+k\)</span>： <span
class="math display">\[dp_{i,j}=\max(dp_{i-W-1,k&#39;}+k&#39;\times
AP_i)-j\times AP_i\quad j-k&#39;\le AS_i\]</span> <span
class="math display">\[dp_{i,j}=\max(dp_{i-W-1,k&#39;}+k&#39;\times
BP_i)-j\times BP_i\quad k&#39;-j\le BS_i\]</span> 显然可以单调队列。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> t,maxp,w,l,r,ap[N],dp[N][N],bp[N],as[N],bs[N],ans; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ll k;</span><br><span class="line">    <span class="built_in">Queue</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">int</span> val,<span class="type">int</span> k):<span class="built_in">val</span>(val),<span class="built_in">k</span>(k)&#123;&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(t,maxp,w);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">read</span>(ap[i],bp[i],as[i],bs[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=as[i];j++) dp[i][j]=-ap[i]*j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=maxp;j++)</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pre=i-w<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre&lt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=maxp;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[r].val&lt;=dp[pre][j]+j*ap[i]) --r;</span><br><span class="line">            q[++r]=<span class="built_in">Queue</span>(dp[pre][j]+j*ap[i],j);</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;j-q[l].k&gt;as[i]) ++l;</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j],q[l].val-j*ap[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=maxp;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[r].val&lt;=dp[pre][j]+j*bp[i]) --r;</span><br><span class="line">            q[++r]=<span class="built_in">Queue</span>(dp[pre][j]+j*bp[i],j);</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l].k-j&gt;bs[i]) ++l;</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j],q[l].val-j*bp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=maxp;i++) ans=<span class="built_in">max</span>(ans,dp[t][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="玉蟾宫"><a
href="https://www.luogu.com.cn/problem/P4147">玉蟾宫</a></h3>
插一个单调栈典题。<br />
我们考虑枚举行数，对于一行内，维护每一列向上延伸最多的 <code>F</code>
数量（类似直方图）。例如，对于样例<br />
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">R F F F F F </span><br><span class="line">F F F F F F </span><br><span class="line">R R R F F F </span><br><span class="line">F F F F F F </span><br><span class="line">F F F F F F</span><br></pre></td></tr></table></figure> 假设我们枚举到最后一行，那么应该向上延伸最多的
<code>F</code> 数量应当是： <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">      F F F</span><br><span class="line">      F F F</span><br><span class="line">      F F F</span><br><span class="line">F F F F F F</span><br><span class="line">F F F F F F</span><br><span class="line">2 2 2 5 5 5</span><br></pre></td></tr></table></figure> 此时枚举列，同时对向上延伸最多
<code>F</code> 数量维护单调栈。<br />
时间复杂度 <span class="math inline">\(O(nm)\)</span>。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">    <span class="type">int</span> h,len;</span><br><span class="line">    <span class="built_in">Stack</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Stack</span>(<span class="type">int</span> h,<span class="type">int</span> len):<span class="built_in">h</span>(h),<span class="built_in">len</span>(len)&#123;&#125;</span><br><span class="line">&#125;st[N];</span><br><span class="line"><span class="type">int</span> n,m,top,h[N][N],ans;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            h[i][j]=(c==<span class="string">&#x27;F&#x27;</span>)?h[i<span class="number">-1</span>][j]<span class="number">+1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(top&amp;&amp;st[top].h&gt;h[i][j])&#123;</span><br><span class="line">                temp+=st[top].len;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,st[top].h*temp);</span><br><span class="line">                --top;</span><br><span class="line">            &#125;</span><br><span class="line">            st[++top]=<span class="built_in">Stack</span>(h[i][j],temp<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top)&#123;</span><br><span class="line">            temp+=st[top].len;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,st[top].h*temp);</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans*<span class="number">3</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="并查集">并查集</h2>
<h3 id="apio2008-免费道路"><a
href="https://www.luogu.com.cn/problem/P3623">[APIO2008]
免费道路</a></h3>
题意：一个边权为 <span class="math inline">\(0\)</span> 或 <span
class="math inline">\(1\)</span> 的图，求边权和为 <span
class="math inline">\(n-k\)</span> 的生成树。 首先 Kruskal
求最大生成树，求得必须要加入的 <span class="math inline">\(0\)</span>
边。 再 Kruskal 一遍，先将 <span class="math inline">\(0\)</span> 边加至
<span class="math inline">\(k\)</span> 条，然后一直加 <span
class="math inline">\(1\)</span> 边直到求出生成树。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e4</span><span class="number">+10</span>,M=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,fa[N],tot,cnt,ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v,w;&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">l</span><span class="params">(<span class="type">const</span> edge &amp;x,<span class="type">const</span> edge &amp;y)</span></span>&#123;<span class="keyword">return</span> x.w&lt;y.w;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">g</span><span class="params">(<span class="type">const</span> edge &amp;x,<span class="type">const</span> edge &amp;y)</span></span>&#123;<span class="keyword">return</span> x.w&gt;y.w;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">read</span>(e[i].u,e[i].v,e[i].w);</span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+m,g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">find</span>(e[i].u),v=<span class="built_in">find</span>(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        fa[u]=v;</span><br><span class="line">        ++tot;</span><br><span class="line">        <span class="keyword">if</span>(e[i].w==<span class="number">0</span>) ++cnt,e[i].w=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tot==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;k)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no solution\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+m,l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">find</span>(e[i].u),v=<span class="built_in">find</span>(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(e[i].w==<span class="number">-1</span>)&#123;</span><br><span class="line">            fa[u]=v;</span><br><span class="line">            e[i].w=<span class="number">0</span>;</span><br><span class="line">            ans[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot&lt;k&amp;&amp;e[i].w==<span class="number">0</span>)&#123;</span><br><span class="line">            fa[u]=v;</span><br><span class="line">            ans[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot&gt;=k&amp;&amp;e[i].w==<span class="number">1</span>)&#123;</span><br><span class="line">            fa[u]=v;</span><br><span class="line">            ans[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot!=n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no solution\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=ans[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,e[j].u,e[j].v,e[j].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ahoi2013-连通图"><a
href="https://www.luogu.com.cn/problem/P5227">[AHOI2013] 连通图</a></h3>
线段树分治+可撤销并查集。 在时间轴上开线段树，每个节点维护
<code>std::vector</code>
表示当前区间需要加的边，使用可撤销并查集在回溯时撤销当前节点添加的边。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>,M=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,fa[N],siz[N],k,last[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="built_in">Edge</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> u,<span class="type">int</span> v):<span class="built_in">u</span>(u),<span class="built_in">v</span>(v)&#123;&#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line">vector&lt;Edge&gt; tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,Edge t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">        tree[u].<span class="built_in">push_back</span>(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(ls,l,mid,x,y,t);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line">stack&lt;Edge&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(siz[x]&gt;siz[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    fa[x]=y;</span><br><span class="line">    siz[y]+=siz[x];</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="built_in">Edge</span>(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_ans</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=st.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(Edge x:tree[u]) <span class="built_in">merge</span>(x.u,x.v);</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(siz[<span class="built_in">find</span>(<span class="number">1</span>)]==n) <span class="built_in">printf</span>(<span class="string">&quot;Connected\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Disconnected\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">get_ans</span>(ls,l,mid);</span><br><span class="line">        <span class="built_in">get_ans</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((<span class="type">int</span>)st.<span class="built_in">size</span>()&gt;temp)&#123;</span><br><span class="line">        Edge x=st.<span class="built_in">top</span>();</span><br><span class="line">        <span class="type">int</span> u=x.u,v=x.v;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        siz[v]-=siz[u];</span><br><span class="line">        fa[u]=u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(edge[i].u,edge[i].v);</span><br><span class="line">    <span class="built_in">read</span>(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,c,x;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(c);</span><br><span class="line">        <span class="keyword">while</span>(c--)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            <span class="keyword">if</span>(last[x]<span class="number">+1</span>&lt;=i<span class="number">-1</span>) <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,k,last[x]<span class="number">+1</span>,i<span class="number">-1</span>,edge[x]);</span><br><span class="line">            last[x]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,k,last[i]<span class="number">+1</span>,k,edge[i]);</span><br><span class="line">    <span class="built_in">get_ans</span>(<span class="number">1</span>,<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day2">Day2</h1>
<h2 id="trie">Trie</h2>
<h3 id="jsoi2009-电子字典"><a
href="https://www.luogu.com.cn/problem/P4407">[JSOI2009]
电子字典</a></h3>
<p>Trie 题怎么能用 Trie 做呢？<br />
由于串长极小，直接字符串哈希，实现时需要注意以下几个点： -
使用自然溢出哈希； - 记得去重，去重一定不要用 <code>std::set</code>，会
T 飞。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/pb_ds/hash_policy.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ull base[<span class="number">25</span>],h[<span class="number">25</span>];</span><br><span class="line">gp_hash_table&lt;ull,<span class="type">int</span>&gt; word;</span><br><span class="line"><span class="type">char</span> s[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    base[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">22</span>;i++) base[i]=base[i<span class="number">-1</span>]*<span class="number">131</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s));</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s<span class="number">+1</span>);</span><br><span class="line">        h[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len=<span class="built_in">strlen</span>(s<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">            h[i]=h[i<span class="number">-1</span>]*<span class="number">131</span>+s[i];</span><br><span class="line">        word[h[len]]=m<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s));</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">        h[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s<span class="number">+1</span>);</span><br><span class="line">        <span class="type">int</span> len=<span class="built_in">strlen</span>(s<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">            h[i]=h[i<span class="number">-1</span>]*<span class="number">131</span>+s[i];</span><br><span class="line">        <span class="keyword">if</span>(word.<span class="built_in">find</span>(h[len])!=word.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            ull hash1=h[i<span class="number">-1</span>]*base[len-i]+(h[len]-h[i]*base[len-i]);</span><br><span class="line">            <span class="keyword">auto</span> it=word.<span class="built_in">find</span>(hash1);</span><br><span class="line">            <span class="keyword">if</span>(it!=word.<span class="built_in">end</span>()&amp;&amp;it-&gt;second!=m)</span><br><span class="line">                it-&gt;second=m,++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> j=<span class="string">&#x27;a&#x27;</span>;j&lt;=<span class="string">&#x27;z&#x27;</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==s[i]) <span class="keyword">continue</span>;</span><br><span class="line">                ull hash1=h[len]-s[i]*base[len-i]+j*base[len-i];</span><br><span class="line">                <span class="keyword">auto</span> it=word.<span class="built_in">find</span>(hash1);</span><br><span class="line">                <span class="keyword">if</span>(it!=word.<span class="built_in">end</span>()&amp;&amp;it-&gt;second!=m)</span><br><span class="line">                    it-&gt;second=m,++res;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> j=<span class="string">&#x27;a&#x27;</span>;j&lt;=<span class="string">&#x27;z&#x27;</span>;j++)&#123;</span><br><span class="line">                ull hash1=h[i]*base[len-i<span class="number">+1</span>]+j*base[len-i]+(h[len]-h[i]*base[len-i]);</span><br><span class="line">                <span class="keyword">auto</span> it=word.<span class="built_in">find</span>(hash1);</span><br><span class="line">                <span class="keyword">if</span>(it!=word.<span class="built_in">end</span>()&amp;&amp;it-&gt;second!=m)</span><br><span class="line">                    it-&gt;second=m,++res;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="usaco12dec-first-g"><a
href="https://www.luogu.com.cn/problem/P3065">[USACO12DEC] First!
G</a></h3>
建 Trie，在 Trie 上查找时对字母连边，拓扑排序判环。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">3e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,nxt[N][<span class="number">26</span>],tot,e[<span class="number">26</span>][<span class="number">26</span>],indegree[<span class="number">26</span>],cnt,ans[N];</span><br><span class="line"><span class="type">bool</span> ed[N];</span><br><span class="line">string s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="type">int</span> k=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[p][k]) nxt[p][k]=++tot;</span><br><span class="line">        p=nxt[p][k];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[p]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="built_in">sizeof</span>(e));</span><br><span class="line">    <span class="built_in">memset</span>(indegree,<span class="number">0</span>,<span class="built_in">sizeof</span>(indegree));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ed[p]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> k=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(k!=i&amp;&amp;nxt[p][i]&amp;&amp;!e[k][i])&#123;</span><br><span class="line">                e[k][i]=<span class="number">1</span>;</span><br><span class="line">                ++indegree[i];</span><br><span class="line">            &#125;</span><br><span class="line">        p=nxt[p][k];</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(!indegree[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;<span class="number">26</span>;v++)</span><br><span class="line">            <span class="keyword">if</span>(e[u][v]&amp;&amp;!--indegree[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(indegree[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="built_in">insert</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(s[i]))</span><br><span class="line">            ans[++cnt]=i;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        cout&lt;&lt;s[ans[i]]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ioi-2008-type-printer"><a
href="https://www.luogu.com.cn/problem/P4683">[IOI 2008] Type
Printer</a></h3>
显然先建出 Trie，考虑怎样的遍历顺序更优。<br />
发现这不是<a
href="https://www.luogu.com.cn/problem/P3698">老熟人</a>吗？
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">25010</span>;</span><br><span class="line"><span class="type">int</span> n,nxt[N*<span class="number">20</span>][<span class="number">26</span>],tot;</span><br><span class="line"><span class="type">bool</span> ed[N*<span class="number">20</span>],flag[N*<span class="number">20</span>],f;</span><br><span class="line">string maxlen,ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="type">int</span> k=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[p][k]) nxt[p][k]=++tot;</span><br><span class="line">        p=nxt[p][k];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[p]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="type">int</span> k=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        p=nxt[p][k];</span><br><span class="line">        flag[p]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ed[u]) ans.<span class="built_in">push_back</span>(<span class="string">&#x27;P&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> maxk=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> v=nxt[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag[v]) maxk=i;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(~maxk)&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(maxk+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(nxt[u][maxk]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag[u]&amp;&amp;!~maxk)&#123;</span><br><span class="line">        cout&lt;&lt;ans.<span class="built_in">length</span>()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:ans)</span><br><span class="line">            cout&lt;&lt;c&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()&gt;maxlen.<span class="built_in">length</span>()) maxlen=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">query</span>(maxlen);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="笛卡尔树">笛卡尔树</h2>
<h3 id="tjoi2011-树的序"><a
href="https://www.luogu.com.cn/problem/P1377">[TJOI2011] 树的序</a></h3>
考虑 BST 每个节点记录权值 <span class="math inline">\(k\)</span>
和插入的时间 <span class="math inline">\(t\)</span>，则 <span
class="math inline">\(k\)</span> 满足 BST 的性质，<span
class="math inline">\(t\)</span> 满足小根堆的性质，这样构建的 BST 是一棵
Treap。<br />
题意转化为：重新分配 <span
class="math inline">\(t\)</span>，使得生成序列最小。<br />
既然 <span class="math inline">\(t\)</span>
维度是小根堆，那么满足父亲小于后代。贪心地想，较小的 <span
class="math inline">\(t\)</span> 分配顺序为：父亲 <span
class="math inline">\(&gt;\)</span> 左子树 <span
class="math inline">\(&gt;\)</span> 右子树，也就是 BST 的前序遍历。
笛卡尔树同样满足 Treap 的性质。它的 <span
class="math inline">\(k\)</span> 与 <span
class="math inline">\(t\)</span> 正好与本题的 BST 相反。则我们只需交换
<span class="math inline">\(k\)</span> 和 <span
class="math inline">\(t\)</span> 并 <span
class="math inline">\(O(n)\)</span> 构建笛卡尔树即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],st[N],top,son[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,u);</span><br><span class="line">    <span class="keyword">if</span>(son[u][<span class="number">0</span>]) <span class="built_in">dfs</span>(son[u][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(son[u][<span class="number">1</span>]) <span class="built_in">dfs</span>(son[u][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++) <span class="built_in">read</span>(x),a[x]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> last=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;a[st[top]]&gt;a[i]) last=st[top--];</span><br><span class="line">        <span class="keyword">if</span>(top) son[st[top]][<span class="number">1</span>]=i;</span><br><span class="line">        son[i][<span class="number">0</span>]=last;</span><br><span class="line">        st[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        vis[son[i][<span class="number">0</span>]]=vis[son[i][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="数据结构">数据结构</h2>
<h3 id="最大异或和"><a
href="https://www.luogu.com.cn/problem/P4735">最大异或和</a></h3>
可持久化 01 trie 模板题。<br />
操作与主席树类似，对于查询，设我们已经维护了所有的前缀异或和 <span
class="math inline">\(sum_i=\oplus_{j=1}^ia_j\)</span>，则只需最大化
<span class="math inline">\(sum_{p-1}\oplus sum_n\oplus
x\)</span>。后两项是给定的，则我们只需贪心求出答案即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::max;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">6e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,nxt[N*<span class="number">25</span>][<span class="number">2</span>],siz[N*<span class="number">25</span>],tot,root[N],sum;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> old,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    root[u]=++tot;</span><br><span class="line">    <span class="type">int</span> p=root[u],q=root[old];</span><br><span class="line">    siz[p]=siz[q]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">24</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        nxt[p][<span class="number">0</span>]=nxt[q][<span class="number">0</span>],nxt[p][<span class="number">1</span>]=nxt[q][<span class="number">1</span>];</span><br><span class="line">        nxt[p][c]=++tot;</span><br><span class="line">        p=nxt[p][c],q=nxt[q][c];</span><br><span class="line">        siz[p]=siz[q]<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=root[a],q=root[b],res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">24</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(siz[nxt[q][c^<span class="number">1</span>]]&gt;siz[nxt[p][c^<span class="number">1</span>]])&#123;</span><br><span class="line">            res|=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">            p=nxt[p][c^<span class="number">1</span>];</span><br><span class="line">            q=nxt[q][c^<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p=nxt[p][c];</span><br><span class="line">            q=nxt[q][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a);</span><br><span class="line">        <span class="built_in">insert</span>(i,i<span class="number">-1</span>,sum^=a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> x,l,r;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        op=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(op!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;op!=<span class="string">&#x27;Q&#x27;</span>) op=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            ++n;</span><br><span class="line">            <span class="built_in">insert</span>(n,n<span class="number">-1</span>,sum^=x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">read</span>(l,r,x);</span><br><span class="line">            <span class="type">int</span> ans;</span><br><span class="line">            <span class="keyword">if</span>(l==<span class="number">1</span>) ans=<span class="built_in">max</span>(<span class="built_in">query</span>(sum^x,<span class="number">0</span>,r<span class="number">-1</span>),sum^x);</span><br><span class="line">            <span class="keyword">else</span> ans=<span class="built_in">query</span>(sum^x,l<span class="number">-2</span>,r<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="十二省联考-2019-异或粽子"><a
href="https://www.luogu.com.cn/problem/P5283">[十二省联考 2019]
异或粽子</a></h3>
类似<a href="https://www.luogu.com.cn/problem/P2048">[NOI2010]
超级钢琴</a>的贪心，由于 <span class="math inline">\(a_i\oplus
a_j=a_j\oplus a_i\)</span>，只需使用堆查询最大的 <span
class="math inline">\(2k\)</span> 个，再令答案除以 <span
class="math inline">\(2\)</span>。可以用 Trie 查询全局第 <span
class="math inline">\(k\)</span> 大，方法类似线段树上二分。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,k,nxt[N&lt;&lt;<span class="number">5</span>][<span class="number">2</span>],siz[N&lt;&lt;<span class="number">5</span>],tot=<span class="number">1</span>;</span><br><span class="line">ll a[N],ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">    ++siz[p];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">32</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[p][c]) nxt[p][c]=++tot;</span><br><span class="line">        p=nxt[p][c];</span><br><span class="line">        ++siz[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x,<span class="type">int</span> rnk)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">32</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(siz[nxt[p][c]]&gt;=rnk) p=nxt[p][c];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rnk-=siz[nxt[p][c]];</span><br><span class="line">            p=nxt[p][c^<span class="number">1</span>];</span><br><span class="line">            res|=<span class="number">1ll</span>&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id,rnk;</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> id,<span class="type">int</span> rnk,ll val):<span class="built_in">id</span>(id),<span class="built_in">rnk</span>(rnk),<span class="built_in">val</span>(val)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> val&lt;x.val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        a[i]^=a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">node</span>(i,n<span class="number">+1</span>,<span class="built_in">query</span>(a[i],n<span class="number">+1</span>)));</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        node u=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=u.val;</span><br><span class="line">        <span class="keyword">if</span>(u.rnk) q.<span class="built_in">push</span>(<span class="built_in">node</span>(u.id,u.rnk<span class="number">-1</span>,<span class="built_in">query</span>(a[u.id],u.rnk<span class="number">-1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day3">Day3</h1>
<h2 id="字符串哈希">字符串哈希</h2>
<h3 id="poi-2006-pal-palindromes"><a
href="https://www.luogu.com.cn/problem/P3449">[POI 2006]
PAL-Palindromes</a></h3>
容易发现，两个回文串 <span class="math inline">\(A\)</span>，<span
class="math inline">\(B\)</span> 组合成新回文串当且仅当 <span
class="math inline">\(AB\)</span> 等于 <span
class="math inline">\(BA\)</span>。设 <span
class="math inline">\(A\)</span> 的哈希值为 <span
class="math inline">\(a\)</span>，<span class="math inline">\(B\)</span>
的哈希值为 <span class="math inline">\(b\)</span>，有 <span
class="math display">\[a\times base^{|B|}+b=b\times
base^{|A|}+a\]</span> 简单移项 <span
class="math display">\[\frac{a}{base^{|A|}-1}=\frac{b}{base^{|B|}-1}\]</span>
开哈希桶维护即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/pb_ds/hash_policy.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod1=<span class="number">998244353</span>,mod2=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    a%=p;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair_hash</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;x)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="type">size_t</span> seed=<span class="number">0</span>;</span><br><span class="line">        seed^=hash&lt;<span class="type">int</span>&gt;&#123;&#125;(x.first)<span class="number">+0x9e3779b9</span>+(seed&lt;&lt;<span class="number">6</span>)+(seed&gt;&gt;<span class="number">2</span>);</span><br><span class="line">        seed^=hash&lt;<span class="type">int</span>&gt;&#123;&#125;(x.second)<span class="number">+0x9e3779b9</span>+(seed&lt;&lt;<span class="number">6</span>)+(seed&gt;&gt;<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> seed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">gp_hash_table&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>,pair_hash&gt; cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,temp;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;temp&gt;&gt;s;</span><br><span class="line">        ll h1=<span class="number">0</span>,h2=<span class="number">0</span>,base1=<span class="number">1</span>,base2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            h1=(h1*<span class="number">131</span>+c)%mod1;</span><br><span class="line">            base1=base1*<span class="number">131</span>%mod1;</span><br><span class="line">            h2=(h2*<span class="number">131</span>+c)%mod2;</span><br><span class="line">            base2=base2*<span class="number">131</span>%mod2;</span><br><span class="line">        &#125;</span><br><span class="line">        ll x=h1*<span class="built_in">qpow</span>(base1<span class="number">-1</span>,mod1<span class="number">-2</span>,mod1)%mod1;</span><br><span class="line">        ll y=h2*<span class="built_in">qpow</span>(base2<span class="number">-1</span>,mod2<span class="number">-2</span>,mod2)%mod2;</span><br><span class="line">        ans+=cnt[<span class="built_in">make_pair</span>(x,y)];</span><br><span class="line">        ++cnt[<span class="built_in">make_pair</span>(x,y)];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans*<span class="number">2</span>+n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="poi-2012-okr-a-horrible-poem"><a
href="https://www.luogu.com.cn/problem/P3538">[POI 2012] OKR-A Horrible
Poem</a></h3>
<span class="math inline">\(A\)</span> 的一个子串 <span
class="math inline">\(B\)</span> 能成为 <span
class="math inline">\(A\)</span> 的一个完整周期，当且仅当其长度为 <span
class="math inline">\(A\)</span>
长度的因数。直接枚举因数。判断是否是完整周期的方法：设 <span
class="math inline">\(h_{l,r}\)</span> 表示 <span
class="math inline">\([l,r]\)</span> 的哈希值，则当一个长为 <span
class="math inline">\(len\)</span> 的子串满足 <span
class="math inline">\(h_{l,r-len}=h_{l+len,r}\)</span>
时，其为一个完整周期。先跑一遍线性筛降低枚举因数的时间复杂度。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,q,e[N],p[N],tot;</span><br><span class="line">ull h[N],base[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function">ull <span class="title">gethash</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*base[r-l<span class="number">+1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %s %d&quot;</span>,&amp;n,s<span class="number">+1</span>,&amp;q);</span><br><span class="line">    base[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        base[i]=base[i<span class="number">-1</span>]*<span class="number">131</span>;</span><br><span class="line">        h[i]=h[i<span class="number">-1</span>]*<span class="number">131</span>+s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!e[i]) p[e[i]=++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=e[i]&amp;&amp;p[j]&lt;=n/i;j++)</span><br><span class="line">            e[p[j]*i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a,b,len,ans;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        len=ans=b-a<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> prime=p[e[len]];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">gethash</span>(a+ans/prime,b)==<span class="built_in">gethash</span>(a,b-ans/prime))</span><br><span class="line">                ans/=prime;</span><br><span class="line">            len/=prime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ontak2015-tasowanie"><a
href="https://www.luogu.com.cn/problem/P8023">[ONTAK2015]
Tasowanie</a></h3>
双指针+二分+哈希。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],b[N],len,p1,p2;</span><br><span class="line">ull h1[N],h2[N],base[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">gethash1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> h1[r]-h1[l<span class="number">-1</span>]*base[r-l<span class="number">+1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">gethash2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> h2[r]-h2[l<span class="number">-1</span>]*base[r-l<span class="number">+1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">gethash1</span>(p1,p1+x<span class="number">-1</span>)==<span class="built_in">gethash2</span>(p2,p2+x<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(b[i]);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">+1</span>;i&lt;=m;i++) a[i]=<span class="number">1e3</span><span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">+1</span>;i&lt;=n;i++) b[i]=<span class="number">1e3</span><span class="number">+1</span>;</span><br><span class="line">    base[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    len=<span class="built_in">max</span>(n,m);</span><br><span class="line">    a[len<span class="number">+1</span>]=b[len<span class="number">+1</span>]=<span class="number">1e3</span><span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++) base[i]=base[i<span class="number">-1</span>]*<span class="number">13331</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        h1[i]=h1[i<span class="number">-1</span>]*<span class="number">13331</span>+a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        h2[i]=h2[i<span class="number">-1</span>]*<span class="number">13331</span>+b[i];</span><br><span class="line">    p1=<span class="number">1</span>,p2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[p1]&lt;b[p2]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[p1++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[p1]&gt;b[p2]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[p2++]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=<span class="built_in">min</span>(len-p1<span class="number">+1</span>,len-p2<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[p1+r]&lt;b[p2+r]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[p1++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[p2++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="kmp">KMP</h2>
<h3 id="hnoi2008-gt考试"><a
href="https://www.luogu.com.cn/problem/P3193">[HNOI2008] GT考试</a></h3>
设 <span class="math inline">\(f_{i,j}\)</span> 表示长串匹配前 <span
class="math inline">\(i\)</span> 个字符，短串匹配前 <span
class="math inline">\(j\)</span> 个字符的方案数。答案为： <span
class="math display">\[ans=\sum_{i=0}^{m-1} f_{n,i}\]</span> 设 <span
class="math inline">\(g_{i,j}\)</span> 表示匹配到第 <span
class="math inline">\(i\)</span> 位时加入一个数字后匹配到第 <span
class="math inline">\(j\)</span> 位的方案数，可以用 KMP 求出。 <span
class="math display">\[f_{i,j}=\sum_{k=0}^{m-1}f_{i-1,k}\times
g_{k,j}\]</span> 注意到这是矩阵乘法的形式，矩阵快速幂 <span
class="math inline">\(O(m^3\log n)\)</span>。<br />
在转化成矩阵的过程中，<span class="math inline">\(f_{i,j}\)</span>
被转化为一个一行 <span class="math inline">\(m-1\)</span> 列的矩阵。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="type">int</span> n,m,mod,nxt[<span class="number">25</span>],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        Matrix res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                    res.a[i][j]=(res.a[i][j]+a[i][k]*x.a[k][j]%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;base,f,g;</span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    Matrix res=base;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) base.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s<span class="number">+1</span>);</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[j<span class="number">+1</span>]!=s[i]) j=nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(s[j<span class="number">+1</span>]==s[i]) j++;</span><br><span class="line">        nxt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c=<span class="string">&#x27;0&#x27;</span>;c&lt;=<span class="string">&#x27;9&#x27;</span>;c++)&#123;</span><br><span class="line">            j=i;</span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;s[j<span class="number">+1</span>]!=c) j=nxt[j];</span><br><span class="line">            <span class="keyword">if</span>(s[j<span class="number">+1</span>]==c) j++;</span><br><span class="line">            g.a[i][j]=(g.a[i][j]<span class="number">+1</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    f.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    f=f*<span class="built_in">qpow</span>(g,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) ans=(ans+f.a[<span class="number">0</span>][i])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="manacher">Manacher</h2>
感觉自己没理解 Manacher 啊，改天<a
href="https://headless-piston.github.io/2025/07/05/Manacher/">重学一次</a>。
### <a href="https://www.luogu.com.cn/problem/P1659">[国家集训队]
拉拉队排练</a> 由于只需要找长度为奇数的回文串，无需在字符间插入
<code>#</code>，直接跑 Manacher，开差分数组 <span
class="math inline">\(sum\)</span>，表示当前长度的回文串数量。当位置
<span class="math inline">\(i\)</span> 的最长回文半径为 <span
class="math inline">\(p_i\)</span> 时，容易想到半径长度小于等于 <span
class="math inline">\(p_i\)</span> 的都是回文串，则我们只需在差分数组
<span class="math inline">\(sum_1\)</span> 处加 <span
class="math inline">\(1\)</span>，<span
class="math inline">\(sum_{p_i\times 2}\)</span> 处减 <span
class="math inline">\(1\)</span> 就行了。最后统计答案时要用快速幂。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>,mod=<span class="number">19930726</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    a%=mod;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,p[N];</span><br><span class="line">ll k,sum[N],ans;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s<span class="number">+1</span>);</span><br><span class="line">    s[<span class="number">0</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,r=<span class="number">0</span>,mid=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r) p[i]=<span class="built_in">min</span>(p[mid*<span class="number">2</span>-i],r-i<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">while</span>(s[i-p[i]]==s[i+p[i]]) ++p[i];</span><br><span class="line">        <span class="keyword">if</span>(p[i]+i&gt;r) r=p[i]+i<span class="number">-1</span>,mid=i;</span><br><span class="line">        ++sum[<span class="number">1</span>],--sum[p[i]*<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> tot=n;</span><br><span class="line">    ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tot%<span class="number">2</span>==<span class="number">0</span>) --tot;</span><br><span class="line">    <span class="keyword">while</span>(k&amp;&amp;tot&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ans=ans*<span class="built_in">qpow</span>(tot,<span class="built_in">min</span>(sum[tot],k))%mod;</span><br><span class="line">        k=<span class="built_in">max</span>(k-sum[tot],<span class="number">0ll</span>);</span><br><span class="line">        tot-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="国家集训队-最长双回文串"><a
href="https://www.luogu.com.cn/problem/P4555">[国家集训队]
最长双回文串</a></h3>
在跑 Manacher 同时维护以每个点开头和结尾的最长回文串长度。仅 Manacher
求解的答案不完全，需要再递推地扫一遍，最后枚举中点即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">char</span> t[N],s[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> len0,len,p[N&lt;&lt;<span class="number">1</span>],a[N&lt;&lt;<span class="number">1</span>],b[N&lt;&lt;<span class="number">1</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t<span class="number">+1</span>);</span><br><span class="line">    len0=<span class="built_in">strlen</span>(t<span class="number">+1</span>);</span><br><span class="line">    s[<span class="number">0</span>]=s[<span class="number">1</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len0;i++)&#123;</span><br><span class="line">        s[++len]=t[i];</span><br><span class="line">        s[++len]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,r=<span class="number">0</span>,mid=<span class="number">0</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">2</span>*mid-i;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r) p[i]=<span class="built_in">min</span>(r-i<span class="number">+1</span>,p[j]);</span><br><span class="line">        <span class="keyword">else</span> p[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i-p[i]]==s[i+p[i]]) ++p[i];</span><br><span class="line">        <span class="keyword">if</span>(i+p[i]<span class="number">-1</span>&gt;r)&#123;</span><br><span class="line">            r=i+p[i]<span class="number">-1</span>;</span><br><span class="line">            mid=i;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i+p[i]<span class="number">-1</span>]=<span class="built_in">max</span>(a[i+p[i]<span class="number">-1</span>],p[i]<span class="number">-1</span>);</span><br><span class="line">        b[i-p[i]<span class="number">+1</span>]=<span class="built_in">max</span>(b[i-p[i]<span class="number">+1</span>],p[i]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">1</span>;i-=<span class="number">2</span>) a[i]=<span class="built_in">max</span>(a[i],a[i<span class="number">+2</span>]<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i+=<span class="number">2</span>) b[i]=<span class="built_in">max</span>(b[i],b[i<span class="number">-2</span>]<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i+=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&amp;&amp;b[i]) ans=<span class="built_in">max</span>(ans,a[i]+b[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day4">Day4</h1>
<h2 id="搜索">搜索</h2>
搜索题真是无聊死了，就少放几道吧…… ### <a
href="https://www.luogu.com.cn/problem/P8817">[CSP-S 2022] 假期计划</a>
<span class="math inline">\(n\)</span> 遍 BFS
求全源最短路，之后考虑枚举。将 <span class="math inline">\(5\)</span>
个点记作 <span class="math inline">\(1,2,3,4,5\)</span>，则枚举 <span
class="math inline">\(3,4\)</span> 点，判断 <span
class="math inline">\(2,5\)</span>
是否与已选的点重复。可以预处理出每个能同时到达 <span
class="math inline">\(1\)</span>
点和另一个点的前三大点，因为它最多只有可能与 <span
class="math inline">\(3,4\)</span> 中的一个和 <span
class="math inline">\(2,5\)</span> 中的一个重合。总体时间复杂度 <span
class="math inline">\(O(nm+n^2)\)</span>。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2510</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,dis[N][N];</span><br><span class="line">ll ans,val[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> id):<span class="built_in">id</span>(id)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val[id]!=val[x.id]?val[id]&lt;val[x.id]:id&lt;x.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;node&gt; st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);++k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) <span class="built_in">read</span>(val[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i][i]=<span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:e[u])</span><br><span class="line">                <span class="keyword">if</span>(dis[i][u]<span class="number">+1</span>&lt;dis[i][v]&amp;&amp;dis[i][u]<span class="number">+1</span>&lt;=k)&#123;</span><br><span class="line">                    dis[i][v]=dis[i][u]<span class="number">+1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[i][j]&lt;=k&amp;&amp;dis[<span class="number">1</span>][j]&lt;=k)</span><br><span class="line">                st[i].<span class="built_in">insert</span>(<span class="built_in">node</span>(j));</span><br><span class="line">            <span class="keyword">if</span>(st[i].<span class="built_in">size</span>()&gt;<span class="number">3</span>) st[i].<span class="built_in">erase</span>(st[i].<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">2</span>;b&lt;=n;b++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">2</span>;c&lt;=n;c++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b==c||dis[b][c]&gt;k) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> temp1:st[b])&#123;</span><br><span class="line">                <span class="type">int</span> a=temp<span class="number">1.</span>id;</span><br><span class="line">                <span class="keyword">if</span>(a==b||a==c) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> temp2:st[c])&#123;</span><br><span class="line">                    <span class="type">int</span> d=temp<span class="number">2.</span>id;</span><br><span class="line">                    <span class="keyword">if</span>(d==b||d==c||a==d) <span class="keyword">continue</span>;</span><br><span class="line">                    ans=<span class="built_in">max</span>(ans,val[a]+val[b]+val[c]+val[d]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ahoi2012-铁盘整理"><a
href="https://www.luogu.com.cn/problem/P2534">[AHOI2012]
铁盘整理</a></h3>
IDA* 板题。先离散化，估价函数为相邻差不为 <span
class="math inline">\(1\)</span> 的个数。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],b[N],lim;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res+=(<span class="built_in">abs</span>(a[i<span class="number">+1</span>]-a[i])!=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> pre)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="built_in">h</span>();</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt+temp&gt;lim) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==pre) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+i);</span><br><span class="line">        f|=<span class="built_in">dfs</span>(cnt<span class="number">+1</span>,i);</span><br><span class="line">        <span class="built_in">reverse</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),b[i]=a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+n,a[i])-b;</span><br><span class="line">    a[n<span class="number">+1</span>]=n<span class="number">+1</span>;</span><br><span class="line">    lim=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lim);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++lim;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="prime-gift"><a
href="https://codeforces.com/problemset/problem/912/E">Prime
Gift</a></h3>
容易发现，<span class="math inline">\(p_i\)</span>
越小，方案数越多。<span class="math inline">\(n=16\)</span>
时不可接受，考虑 Meet in the middle。最坏情况下前 <span
class="math inline">\(8\)</span> 个质数 <span
class="math inline">\(2,3,5,7,11,13,17,19\)</span>，在 <span
class="math inline">\(10^{18}\)</span> 内能组成 <span
class="math inline">\(7039193\)</span>
种数字。实际实现时可以将数的分配得更加均匀以降低复杂度。之后二分答案+双指针求解即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> ll lim=<span class="number">1e18</span>,N=<span class="number">7039192</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,p[<span class="number">20</span>],k,tota,totb;</span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,ll num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(x<span class="number">+2</span>,num);</span><br><span class="line">    <span class="keyword">for</span>(ll i=p[x];;i*=p[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(lim/i&lt;num) <span class="keyword">break</span>;</span><br><span class="line">        a[++tota]=num*i;</span><br><span class="line">        <span class="built_in">dfs1</span>(x<span class="number">+2</span>,num*i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,ll num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(x<span class="number">+2</span>,num);</span><br><span class="line">    <span class="keyword">for</span>(ll i=p[x];;i*=p[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(lim/i&lt;num) <span class="keyword">break</span>;</span><br><span class="line">        b[++totb]=num*i;</span><br><span class="line">        <span class="built_in">dfs2</span>(x<span class="number">+2</span>,num*i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=totb;i&lt;=tota;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;x/a[i]&lt;b[j]) --j;</span><br><span class="line">        cnt+=j;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(p[i]);</span><br><span class="line">    <span class="built_in">sort</span>(p<span class="number">+1</span>,p<span class="number">+1</span>+n);</span><br><span class="line">    a[++tota]=b[++totb]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+tota);</span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+totb);</span><br><span class="line">    <span class="built_in">read</span>(k);</span><br><span class="line">    ll l=<span class="number">1</span>,r=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="usaco09nov-lights-g"><a
href="https://www.luogu.com.cn/problem/P2962">[USACO09NOV] Lights
G</a></h3>
Meet in the middle，开一个 <code>std::map</code>
记录状态对应的最小操作次数，按照补集相加。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">40</span>;</span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line">ll a[N];</span><br><span class="line">map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=<span class="number">1ll</span>&lt;&lt;i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        --u,--v;</span><br><span class="line">        a[u]|=<span class="number">1ll</span>&lt;&lt;v;</span><br><span class="line">        a[v]|=<span class="number">1ll</span>&lt;&lt;u;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=n<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n&gt;&gt;<span class="number">1</span>));i++)&#123;</span><br><span class="line">        ll temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(n&gt;&gt;<span class="number">1</span>);j++)</span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)</span><br><span class="line">                temp^=a[j];</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(temp)) mp[temp]=__builtin_popcount(i);</span><br><span class="line">        <span class="keyword">else</span> mp[temp]=<span class="built_in">min</span>(mp[temp],__builtin_popcount(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n-(n&gt;&gt;<span class="number">1</span>)));i++)&#123;</span><br><span class="line">        ll temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-(n&gt;&gt;<span class="number">1</span>);j++)</span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)</span><br><span class="line">                temp^=a[(n&gt;&gt;<span class="number">1</span>)+j];</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(((<span class="number">1ll</span>&lt;&lt;n)<span class="number">-1</span>)^temp))</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,__builtin_popcount(i)+mp[((<span class="number">1ll</span>&lt;&lt;n)<span class="number">-1</span>)^temp]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="机关"><a
href="https://www.luogu.com.cn/problem/P5507">机关</a></h3>
<del>坏题。</del><br />
考虑 A*。容易想到 <span class="math inline">\(4\)</span>
进制状压，则状态 <span class="math inline">\(x\)</span> 的估价 <span
class="math inline">\(h(x)\)</span> 应为当前已经旋转的次数与所有不为
<span class="math inline">\(1\)</span> 的旋钮旋到 <span
class="math inline">\(1\)</span> 所需总步数除以 <span
class="math inline">\(2\)</span>
的和。因为最好情况是旋一个按钮时另一个正好也到了 <span
class="math inline">\(1\)</span>。每个状态记录一个 <span
class="math inline">\(pre\)</span>
表示是从哪个状态转移过来的以输出方案。<br />

<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">24</span>)<span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> st,a[<span class="number">15</span>][<span class="number">4</span>],b[N],pre[N],step[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==st) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">write</span>(pre[x]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">h</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp=(x&gt;&gt;(i&lt;&lt;<span class="number">1</span>))&amp;<span class="number">3</span>;</span><br><span class="line">        res+=temp?<span class="number">4</span>-temp:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,h;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> x,<span class="type">int</span> h):<span class="built_in">x</span>(x),<span class="built_in">h</span>(h)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a)<span class="type">const</span>&#123;<span class="keyword">return</span> h&gt;a.h;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,x;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        st|=(x<span class="number">-1</span>)&lt;&lt;(i&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">            <span class="built_in">read</span>(a[i][j]),--a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(st,<span class="built_in">h</span>(st)));</span><br><span class="line">    vis[st]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().x;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> pos1=i&lt;&lt;<span class="number">1</span>,temp1=(x&gt;&gt;pos1)&amp;<span class="number">3</span>,j=a[i][temp1];</span><br><span class="line">            <span class="type">int</span> pos2=j&lt;&lt;<span class="number">1</span>,temp2=(x&gt;&gt;pos2)&amp;<span class="number">3</span>,res=x;</span><br><span class="line">            res&amp;=~(<span class="number">3</span>&lt;&lt;pos1);</span><br><span class="line">            res&amp;=~(<span class="number">3</span>&lt;&lt;pos2);</span><br><span class="line">            res|=((temp1<span class="number">+1</span>)&amp;<span class="number">3</span>)&lt;&lt;pos1;</span><br><span class="line">            res|=((temp2<span class="number">+1</span>)&amp;<span class="number">3</span>)&lt;&lt;pos2;</span><br><span class="line">            <span class="keyword">if</span>(!vis[res])&#123;</span><br><span class="line">                vis[res]=<span class="number">1</span>;</span><br><span class="line">                step[res]=step[x]<span class="number">+1</span>;</span><br><span class="line">                pre[res]=x,b[res]=i<span class="number">+1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">node</span>(res,step[res]+<span class="built_in">h</span>(res)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,step[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day5">Day5</h1>
<h2 id="最小生成树">最小生成树</h2>
<h3 id="noip-2013-提高组-货车运输"><a
href="https://www.luogu.com.cn/problem/P1967">[NOIP 2013 提高组]
货车运输</a></h3>
最优情况一定是走最大生成树上的边，所以先 Kruskal
求最大生成树，接下来求树上两点间路径权值最小值，可以边权下放点权上树剖+线段树或倍增。另外，图不保证连通，实际上要对森林做操作。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e4</span><span class="number">+10</span>,M=<span class="number">5e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,q,boss[N],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> boss[x]==x?x:boss[x]=<span class="built_in">find</span>(boss[x]);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> w&gt;x.w;&#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge1</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;Edge1&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) boss[i]=i;</span><br><span class="line">    <span class="built_in">sort</span>(edge<span class="number">+1</span>,edge<span class="number">+1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;cnt&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">find</span>(edge[i].u),v=<span class="built_in">find</span>(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        boss[u]=v;</span><br><span class="line">        ++cnt;</span><br><span class="line">        u=edge[i].u,v=edge[i].v;</span><br><span class="line">        <span class="type">int</span> w=edge[i].w;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(&#123;u,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[N],dfncnt,son[N],fa[N],siz[N],top[N],dep[N],w[N],P,tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    dep[u]=dep[f]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:e[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=t.v;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">        w[v]=t.w;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]])</span><br><span class="line">            son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">    top[u]=topf;</span><br><span class="line">    dfn[u]=++dfncnt;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) <span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:e[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=t.v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) (x&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!siz[i]) w[i]=<span class="number">2e9</span>,<span class="built_in">dfs1</span>(i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs2</span>(i,i);</span><br><span class="line">    P=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(P&lt;=n<span class="number">+1</span>) P&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(tree));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        tree[P+dfn[i]]=w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=P<span class="number">-1</span>;i;i--)</span><br><span class="line">        tree[i]=<span class="built_in">min</span>(tree[<span class="built_in">ls</span>(i)],tree[<span class="built_in">rs</span>(i)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    l+=P<span class="number">-1</span>,r+=P<span class="number">+1</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l^<span class="number">1</span>^r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~l&amp;<span class="number">1</span>) res=<span class="built_in">min</span>(tree[l^<span class="number">1</span>],res);</span><br><span class="line">        <span class="keyword">if</span>(r&amp;<span class="number">1</span>) res=<span class="built_in">min</span>(tree[r^<span class="number">1</span>],res);</span><br><span class="line">        l&gt;&gt;=<span class="number">1</span>,r&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(dfn[top[x]],dfn[x]));</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(dfn[x]<span class="number">+1</span>,dfn[y]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        edge[i]=&#123;u,v,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ask</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="bjwc2010-严格次小生成树"><a
href="https://www.luogu.com.cn/problem/P4180">[BJWC2010]
严格次小生成树</a></h3>
跟上一道题一个套路。考虑枚举替换边的过程，首先加一条边形成环，再从环上删去最大的一条小于加入边边权的边。线段树维护区间最大值和区间严格次大值即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>,M=<span class="number">3e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,boss[N],cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> maxn,se;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> maxn=<span class="number">-1</span>,<span class="type">int</span> se=<span class="number">-1</span>):<span class="built_in">maxn</span>(maxn),<span class="built_in">se</span>(se)&#123;&#125;</span><br><span class="line">    node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        node res;</span><br><span class="line">        res.maxn=<span class="built_in">max</span>(maxn,x.maxn);</span><br><span class="line">        res.se=<span class="built_in">max</span>(se,x.se);</span><br><span class="line">        <span class="keyword">if</span>(maxn!=x.maxn)</span><br><span class="line">            res.se=<span class="built_in">max</span>(res.se,<span class="built_in">min</span>(maxn,x.maxn));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> P;</span><br><span class="line">node tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    l+=P<span class="number">-1</span>,r+=P<span class="number">+1</span>;</span><br><span class="line">    node res;</span><br><span class="line">    <span class="keyword">while</span>(l^<span class="number">1</span>^r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~l&amp;<span class="number">1</span>) res=res+tree[l^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(r&amp;<span class="number">1</span>) res=res+tree[r^<span class="number">1</span>];</span><br><span class="line">        l&gt;&gt;=<span class="number">1</span>,r&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> w&lt;x.w;&#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge1</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;Edge1&gt; e[N];</span><br><span class="line">ll ans,minval;</span><br><span class="line"><span class="type">int</span> dfn[N],top[N],dfncnt,dep[N],fa[N],siz[N],son[N],w[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> boss[x]==x?x:boss[x]=<span class="built_in">find</span>(boss[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[f]<span class="number">+1</span>;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:e[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=t.v;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">        w[v]=t.w;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]])</span><br><span class="line">            son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">    top[u]=topf;</span><br><span class="line">    dfn[u]=++dfncnt;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) <span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:e[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=t.v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==son[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    node res;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        res=res+<span class="built_in">query</span>(dfn[top[x]],dfn[x]);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) res=res+<span class="built_in">query</span>(dfn[x]<span class="number">+1</span>,dfn[y]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        edge[i]=&#123;u,v,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edge<span class="number">+1</span>,edge<span class="number">+1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) boss[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;cnt&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">find</span>(edge[i].u),v=<span class="built_in">find</span>(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        boss[u]=v;</span><br><span class="line">        vis[i]=<span class="number">1</span>;</span><br><span class="line">        u=edge[i].u,v=edge[i].v;</span><br><span class="line">        <span class="type">int</span> w=edge[i].w;</span><br><span class="line">        minval+=w;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(&#123;u,w&#125;);</span><br><span class="line">        <span class="keyword">if</span>(++cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    P=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(P&lt;=n<span class="number">+1</span>) P&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        tree[P+dfn[i]]=w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=P<span class="number">-1</span>;i;i--)</span><br><span class="line">        tree[i]=tree[i&lt;&lt;<span class="number">1</span>]+tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    ans=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> x=edge[i].u,y=edge[i].v,w=edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;</span><br><span class="line">        node temp=<span class="built_in">ask</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(temp.maxn==w)</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,minval-temp.se+w);</span><br><span class="line">        <span class="keyword">else</span> ans=<span class="built_in">min</span>(ans,minval-temp.maxn+w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="peaks"><a
href="https://www.luogu.com.cn/problem/P4197">Peaks</a></h3>
Kruskal
重构树的在线做法还是太吃操作了，我们直接离线。容易想到将边权和询问的
<span class="math inline">\(x\)</span> 升序排序后动态加边，查询第 <span
class="math inline">\(k\)</span>
大直接线段树上二分，加边用并查集+线段树合并维护。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>,M=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,q,h[N],b[N],len,tot,root[N],fa[N],now,ans[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> w&lt;x.w;&#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,x,k,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Query &amp;a)<span class="type">const</span>&#123;<span class="keyword">return</span> x&lt;a.x;&#125;</span><br><span class="line">&#125;qu[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> ls,rs,sum;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tree[u].sum=tree[tree[u].ls].sum+tree[tree[u].rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u) u=++tot;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        ++tree[u].sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(tree[u].ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(tree[u].rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a||!b) <span class="keyword">return</span> a|b;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[a].sum+=tree[b].sum;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tree[a].ls=<span class="built_in">merge</span>(tree[a].ls,tree[b].ls,l,mid);</span><br><span class="line">    tree[a].rs=<span class="built_in">merge</span>(tree[a].rs,tree[b].rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">push_up</span>(a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=tree[tree[u].ls].sum)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[u].ls,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[u].rs,mid<span class="number">+1</span>,r,k-tree[tree[u].ls].sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(h[i]);</span><br><span class="line">        b[i]=h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+n);</span><br><span class="line">    len=<span class="built_in">unique</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+len,h[i])-b;</span><br><span class="line">        <span class="built_in">modify</span>(root[i],<span class="number">1</span>,len,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        e[i]=&#123;u,v,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,v,x,k;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(v,x,k);</span><br><span class="line">        qu[i]=&#123;v,x,k,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(qu<span class="number">+1</span>,qu<span class="number">+1</span>+q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=qu[i].x,k=qu[i].k,id=qu[i].id;</span><br><span class="line">        <span class="keyword">while</span>(e[now<span class="number">+1</span>].w&lt;=x&amp;&amp;now&lt;m)&#123;</span><br><span class="line">            ++now;</span><br><span class="line">            <span class="type">int</span> u=<span class="built_in">find</span>(e[now].u),v=<span class="built_in">find</span>(e[now].v);</span><br><span class="line">            <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">            fa[u]=v;</span><br><span class="line">            root[v]=<span class="built_in">merge</span>(root[v],root[u],<span class="number">1</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> v=<span class="built_in">find</span>(qu[i].v);</span><br><span class="line">        <span class="keyword">if</span>(tree[root[v]].sum&lt;k) ans[id]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans[id]=b[<span class="built_in">query</span>(root[v],<span class="number">1</span>,len,tree[root[v]].sum-k<span class="number">+1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="最短路">最短路</h2>
没做。 ## 拓扑排序 ### <a
href="https://www.luogu.com.cn/problem/P2272">[ZJOI2007]
最大半连通子图</a>
容易发现，半连通子图就是若干相连的强连通分量，则找最大半连通子图转化为缩点后在
DAG 上找最长链+计数。注意去重。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>,M=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,mod,head[N],tot_edge;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> to,nxt;&#125;e1[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e1[++tot_edge].to=v;</span><br><span class="line">    e1[tot_edge].nxt=head[u];</span><br><span class="line">    head[u]=tot_edge;</span><br><span class="line">&#125;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">bool</span> instack[N];</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],dfncnt,scccnt,scc[N],w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++dfncnt;</span><br><span class="line">    instack[u]=<span class="number">1</span>;</span><br><span class="line">    st.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e1[i].nxt)&#123;</span><br><span class="line">        <span class="type">int</span> v=e1[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">        ++scccnt;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> v=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            instack[v]=<span class="number">0</span>;</span><br><span class="line">            scc[v]=scccnt;</span><br><span class="line">            ++w[scccnt];</span><br><span class="line">            <span class="keyword">if</span>(u==v) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e2[N];</span><br><span class="line"><span class="type">int</span> indegree[N],dp[N],dis[N],ans1,ans2;</span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; p;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e1[i].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> v=e1[i].to;</span><br><span class="line">            <span class="keyword">if</span>(scc[u]==scc[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(p.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(scc[u],scc[v]))!=p.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            p.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(scc[u],scc[v]));</span><br><span class="line">            e2[scc[u]].<span class="built_in">push_back</span>(scc[v]);</span><br><span class="line">            ++indegree[scc[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=scccnt;i++)</span><br><span class="line">        <span class="keyword">if</span>(!indegree[i])&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            dis[i]=w[i];</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:e2[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&lt;dis[u]+w[v])&#123;</span><br><span class="line">                dis[v]=dis[u]+w[v];</span><br><span class="line">                dp[v]=dp[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dis[v]==dis[u]+w[v])</span><br><span class="line">                dp[v]=(dp[u]+dp[v])%mod;</span><br><span class="line">            <span class="keyword">if</span>(!--indegree[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=scccnt;i++) ans1=<span class="built_in">max</span>(ans1,dis[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=scccnt;i++)</span><br><span class="line">        <span class="keyword">if</span>(dis[i]==ans1) ans2=(ans2+dp[i])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>,ans1,ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day6">Day6</h1>
<h2 id="二分图">二分图</h2>
<h3 id="machine-schedule"><a
href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=246&amp;page=show_problem&amp;problem=3635">Machine
Schedule</a></h3>
连接每个 <span class="math inline">\(a_i\)</span> 和 <span
class="math inline">\(b_i\)</span>，问题变为了二分图上找最小点覆盖。直接跑二分图最大匹配即可。<br />
Kőnig 定理：二分图中，最小点覆盖中的顶点数量等于最大匹配中的边数量。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,ans,match[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            vis[v]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[v]||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">                match[v]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) e[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(n<span class="number">+10</span>));</span><br><span class="line">        <span class="built_in">read</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">read</span>(m,k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,a;i&lt;=k;i++)&#123;</span><br><span class="line">            <span class="built_in">read</span>(a,u,v);</span><br><span class="line">            e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">bool</span>)*(n<span class="number">+10</span>));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="usaco05jan-muddy-fields-g"><a
href="https://www.luogu.com.cn/problem/P6062">[USACO05JAN] Muddy Fields
G</a></h3>
贪心地考虑，极长地放木板一定优。将所有横着的和竖着的木板编号，相交的连边，之后二分图最大匹配。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> r,c,tota,totb,a[N][N],b[N][N],match[N*N],ans;</span><br><span class="line"><span class="type">char</span> mp[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N*N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N*N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            vis[v]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[v]||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">                match[v]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            cin&gt;&gt;mp[i][j];</span><br><span class="line">            <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    a[i][j]=a[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> a[i][j]=++tota;</span><br><span class="line">                <span class="keyword">if</span>(mp[i<span class="number">-1</span>][j]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    b[i][j]=b[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> b[i][j]=++totb;</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]&amp;&amp;b[i][j])</span><br><span class="line">                    e[a[i][j]].<span class="built_in">push_back</span>(b[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tota;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="guardian-of-decency"><a
href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=242&amp;page=show_problem&amp;problem=3235">Guardian
of Decency</a></h3>
最大独立集与最小点覆盖之和为顶点数目，这个推论适用于一般图。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> t,n,match[N],ans,cnta,cntb;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    string music,sport;</span><br><span class="line">&#125;a[N],b[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            vis[v]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[v]||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">                match[v]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) e[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(n<span class="number">+10</span>));</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i].h&gt;&gt;a[i].sex&gt;&gt;a[i].music&gt;&gt;a[i].sport;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i].h-a[j].h)&gt;<span class="number">40</span>||a[i].sex==a[j].sex||</span><br><span class="line">                    a[i].music!=a[j].music||a[i].sport==a[j].sport)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[i].sex==<span class="string">&#x27;M&#x27;</span>) e[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">                <span class="keyword">else</span> e[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">bool</span>)*(n<span class="number">+10</span>));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="欧拉路径">欧拉路径</h2>
<p>没做。 ## 连通分量 没做。</p>
<p>参考资料：<br />
https://oi-wiki.org/graph/graph-matching/bigraph-match/</p>
]]></content>
      <tags>
        <tag>题目合集</tag>
      </tags>
  </entry>
  <entry>
    <title>根号大杂烩</title>
    <url>/2025/07/21/%E6%A0%B9%E5%8F%B7%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
    <content><![CDATA[<h3 id="背景">背景</h3>
<p>我今天就是死在这，调 <span class="math inline">\(\log\)</span>
调到红温爆炸，我也不会碰根号一下的！<br />
……（学习根号之后）……<br />
真香……</p>
<h3 id="分块">分块</h3>
<p>把一个数组简单地划分为几块，若操作范围覆盖整块则整体操作，反之则暴力操作。由均值不等式可证，块长取
<span class="math inline">\(\sqrt{n}\)</span>
可得到最优理论复杂度。<br />
是一个度数 <span class="math inline">\(\sqrt{n}\)</span>，只有三层的树。
——lxl<br />
由于可以暴力操作且具有简单的结构，它有着比树形数据结构更为灵活的优势。同时，它还具有常数小的优势。</p>
<p>习题：</p>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P3372">【模板】线段树
1</a>，跑的比递归式线段树快。</p></li>
<li><p><a
href="https://www.luogu.com.cn/problem/P2801">教主的魔法</a>，分块+二分答案，单次查询复杂度
<span class="math inline">\(O(\sqrt{n}\log n)\)</span>。</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P5356">[Ynoi Easy Round
2017] 由乃打扑克</a>，分块+二分答案+二分查找。</p></li>
</ul>
<p>挑战：</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4117">[Ynoi2018]
五彩斑斓的世界</a><br />
突刺贯穿的第二分块。<br />
解法：分块+并查集。开一个值域大小的并查集，这样我们就可以 <span
class="math inline">\(O(1)\)</span> 修改所有块内相同的值。同时通过维护
<span class="math inline">\(siz\)</span>
数组来快速查询某数出现的次数，且可以随并查集的合并而合并。<br />
接下来进行复杂度分析。注意到，对于本题的修改操作，块内的最大值 <span
class="math inline">\(maxn\)</span> 单调不增。<span
class="math inline">\(maxn\)</span> 最大为 <span
class="math inline">\(10^5+1\)</span>，<span
class="math inline">\(m\)</span> 最大为 <span
class="math inline">\(5\times 10^5\)</span>，可以视为均摊 <span
class="math inline">\(O(1)\)</span>。<br />
对于整块的修改操作，我们分两种情况讨论：<br />
当 <span class="math inline">\(2x\ge maxn\)</span> 时，令所有大于 <span
class="math inline">\(x\)</span> 的数减去 <span
class="math inline">\(x\)</span>，此时暴力更新 <span
class="math inline">\(maxn\)</span>。<br />
当 <span class="math inline">\(2x&lt; maxn\)</span> 时，令所有小于等于
<span class="math inline">\(x\)</span> 的数加上 <span
class="math inline">\(x\)</span>，再将块上的 <span
class="math inline">\(tag\)</span> 加 <span
class="math inline">\(x\)</span>，表示真实值为整体减 <span
class="math inline">\(tag\)</span>。<br />
对于散块，暴力拆散原来的并查集，直接修改并更新 <span
class="math inline">\(maxn\)</span> 就好。<br />
整块更新是均摊 <span class="math inline">\(O(1)\)</span>，散块更新是均摊
<span class="math inline">\(O(\sqrt n)\)</span>。<br />
此题卡空间，无法做到 <span class="math inline">\(O(V\sqrt n)\)</span>
的并查集空间复杂度。考虑将询问离线，在每个块跑一遍询问，答案直接累加。这样我们只需
<span class="math inline">\(O(V)\)</span> 的空间复杂度。<br />
以上方法无法正确处理 <span class="math inline">\(a_i=0\)</span>
的情况。注意到，修改操作不会产生新的 <span
class="math inline">\(0\)</span>，所以直接在一开始用前缀和处理掉 <span
class="math inline">\(0\)</span> 的询问，之后就不用管了。</li>
</ul>
<h3 id="莫队">莫队</h3>
<p>很神的技巧。对于一些题目，如果所求的东西难以用常规数据结构维护且可以离线，那就可以尝试莫队。我们可以来看模板题
<a href="https://www.luogu.com.cn/problem/P1494">[国家集训队] 小 Z
的袜子</a>。<br />
考虑维护双指针 <span class="math inline">\(l,r\)</span> 表示当前考虑区间
<span class="math inline">\([l,r]\)</span>，我们可以容易地从 <span
class="math inline">\([l-1,r],[l+1,r],[l,r-1],[l,r+1]\)</span>
转移过来。那么在移动指针的同时 <span class="math inline">\(O(1)\)</span>
修改当前的每种颜色袜子数的平方和即可。设当前某颜色的袜子数为 <span
class="math inline">\(x_i\)</span>，答案就是<br />
<span class="math display">\[\frac{\sum x_i^2+\sum
x_i}{(r-l+1)(r-l)}\]</span>
现在考虑优化以减少指针移动次数。将询问离线，并将 <span
class="math inline">\(n\)</span>
分块，以询问左端点所在块编号为第一关键字，右端点为第二关键字升序排序。这样做的时间复杂度是
<span class="math inline">\(O(n\sqrt{m})\)</span> 的。<br />
时间复杂度证明：<br />
序列长度为 <span class="math inline">\(n\)</span>，询问次数为 <span
class="math inline">\(m\)</span>。<br />
首先证明最优块长。设块长为 <span
class="math inline">\(len\)</span>，则总块数为 <span
class="math inline">\(\dfrac{n}{len}\)</span>，左指针共移动 <span
class="math inline">\(O(m\cdot len)\)</span> 次，右指针共移动 <span
class="math inline">\(O(\dfrac{n^2}{len})\)</span> 次。总共移动 <span
class="math inline">\(m\cdot len+\dfrac{n^2}{len}\)</span>
次。由均值不等式，有 <span class="math display">\[m\cdot
len+\frac{n^2}{len}\ge 2n\sqrt{m}\]</span> 当且仅当 <span
class="math inline">\(m\cdot len=\dfrac{n^2}{len}\)</span>
时等号成立，此时 <span
class="math inline">\(len=\dfrac{n}{\sqrt{m}}\)</span>。<br />
代入，得 <span class="math display">\[m\cdot
len+\frac{n^2}{len}=2n\sqrt{m}\]</span> 故时间复杂度 <span
class="math inline">\(O(n\sqrt{m})\)</span>。<br />
以下是一些莫队技巧</p>
<h4 id="奇偶排序优化">奇偶排序优化</h4>
<p>在排序右端点时，若当前左端点块编号为奇数则升序排序，反之则降序排序。</p>
<h4 id="关于指针移动顺序">关于指针移动顺序</h4>
<p>由于莫队经常要维护桶，在指针移动时若先执行 delete
操作，容易访问桶的负下标造成 RE，所以建议先写 add 操作再写 delete
操作。</p>
<h4 id="莫队值域分块">莫队+值域分块</h4>
<p>值域分块 <span class="math inline">\(O(1)\)</span>
单点修改的特性很适合莫队。<br />
习题：</p>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P4396">[AHOI2013]
作业</a></p></li>
<li><p><a
href="https://www.luogu.com.cn/problem/P12598">参数要吉祥</a></p></li>
</ul>
<h4 id="莫队bitset">莫队+bitset</h4>
<p>和值域分块类似，但是更好写一些。<br />
习题：</p>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P4137">Rmq Problem /
mex</a></p></li>
<li><p><a
href="https://www.luogu.com.cn/problem/P3674">小清新人渣的本愿</a></p></li>
</ul>
<h4 id="带修莫队">带修莫队</h4>
<p>模板题 <a href="https://www.luogu.com.cn/problem/P1903">[国家集训队]
数颜色 / 维护队列</a>。<br />
现在仅 <span class="math inline">\(l,r\)</span>
不足以表达当前状态，需要加上时间维度，即 <span
class="math inline">\(l,r,t\)</span>。<br />
现在排序以左端点所在块为第一关键字，右端点所在块为第二关键字，时间为第三关键字。设
<span class="math inline">\(n,m,t\)</span> 同阶，块长设为 <span
class="math inline">\(n^{2/3}\)</span>，可得到理论最优时间复杂度 <span
class="math inline">\(O(n^{5/3})\)</span>。详细证明及 <span
class="math inline">\(n,m,t\)</span> 不同阶时的具体分析较为繁琐，可以看
<a href="https://oi-wiki.org/misc/modifiable-mo-algo/">OI Wiki</a>
中的证明。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>概率与期望</title>
    <url>/2025/07/04/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/</url>
    <content><![CDATA[<p>引入：一个普通骰子，求投出点数的期望。 <span
class="math display">\[E=\sum_i p_i w_i\]</span> 其中，<span
class="math inline">\(p_i\)</span> 表示事件 <span
class="math inline">\(i\)</span> 发生的概率，<span
class="math inline">\(w_i\)</span> 表示事件 <span
class="math inline">\(i\)</span> 发生的收益，<span
class="math inline">\(E\)</span> 为收益期望。 在这个题中，<span
class="math inline">\(E=\dfrac{1}{6}\times1+\dfrac{1}{6}\times2+\cdots+\dfrac{1}{6}\times6=3.5\)</span>。</p>
<h3 id="期望的线性性">期望的线性性</h3>
<p>现有 <span class="math inline">\(3\)</span> 个骰子，求投一次这 <span
class="math inline">\(3\)</span>
个骰子的点数之和的期望。对于本题，只要分别求出这 <span
class="math inline">\(3\)</span>
个骰子的期望并加起来就可以了。这就是期望的线性性。 <span
class="math display">\[E(x+y)=E(x)+E(y)\]</span> 若 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 相互独立，则 <span
class="math display">\[E(x)E(y)=E(xy)\]</span> 对于常数 <span
class="math inline">\(k\)</span> ，有 <span
class="math display">\[E(kx)=kE(x)\]</span></p>
<h3 id="解题方式">解题方式</h3>
<p>解决期望问题一般使用 DP 或高斯消元。</p>
<h3 id="例题-1">例题 1</h3>
<p>现有 <span class="math inline">\(1\)</span>
个按钮，每按一次就会等概率返回 Yes 或 No，期望按多少次会返回 Yes？
答案为 <span class="math inline">\(2\)</span>。 考虑第一次返回 Yes
的概率为 <span class="math inline">\(\dfrac{1}{2}\)</span>，第二次返回
Yes 的概率为 <span class="math inline">\(\dfrac{1}{4}\)</span>，第三次为
<span class="math inline">\(\dfrac{1}{8}\)</span>…… 则 <span
class="math inline">\(E=\dfrac{1}{2}\times 1+\dfrac{1}{4}\times
2+\dfrac{1}{8}\times 3+\cdots=2\)</span>。</p>
<h3 id="例题-2">例题 2</h3>
<p>有 <span class="math inline">\(n\)</span>
种不同的邮票，想收集所有种类的邮票，每次只能买一张，且买到任何一种邮票是等概率的，为
<span class="math inline">\(\dfrac{1}{n}\)</span>。每次购买花费 <span
class="math inline">\(1\)</span>
元钱。现手中没有邮票，求买到所有种类邮票所花费钱数的期望。 考虑 DP。设
<span class="math inline">\(f_x\)</span> 表示已集齐 <span
class="math inline">\(x\)</span> 张时的期望次数。对于第 <span
class="math inline">\(i\)</span> 次购买，有 <span
class="math inline">\(\dfrac{i}{n}\)</span> 的概率买重，<span
class="math inline">\(\dfrac{n-i}{n}\)</span> 的概率不重。 <span
class="math display">\[f_i=1+f_i\times \dfrac{i}{n}+f_{i+1}\times
\dfrac{n-i}{n}\]</span> 化简，得 <span
class="math display">\[f_{i+1}=\dfrac{n}{n-i}-f_i\]</span></p>
<h3 id="例题-3">例题 3</h3>
<p>有 <span class="math inline">\(n\)</span> 个奖品，<span
class="math inline">\(m\)</span>
个人排队选礼物。对于每个人，他打开的盒子可能有礼物，也可能已经被之前的人取走。如果有礼物，取走礼物并放回盒子。求所有人期望取走多少个礼物。
考虑 DP。设 <span class="math inline">\(f_i\)</span> 表示前 <span
class="math inline">\(i\)</span> 个人取走礼物个数的期望，则有 <span
class="math display">\[f_1=1,f_i=f_{i-1}+\dfrac{n-f_{i-1}}{n}\]</span>
或者考虑 <span class="math inline">\(1\)</span> 个礼物被拿走的概率，用
<span class="math inline">\(n\)</span>
乘上它即为答案。一个礼物被一个人拿走的概率为 <span
class="math inline">\(\dfrac{n-1}{n}\)</span>，进行 <span
class="math inline">\(m\)</span> 轮，为 <span
class="math inline">\((\dfrac{n-1}{n})^m\)</span>，则答案为 <span
class="math inline">\(n\times [1-{(\dfrac{n-1}{n})}^m]\)</span>。</p>
<h3 id="例题-4"><a href="https://www.luogu.com.cn/problem/P1654"
title="例题 4">例题 4</a></h3>
<p>假设第 <span class="math inline">\(i\)</span> 位之前有 <span
class="math inline">\(q\)</span> 个连续 <span
class="math inline">\(1\)</span>，则这个位置的贡献为 <span
class="math inline">\((q+1)^3-q^3=3q^2+3q+1\)</span>。 所以我们需要维护
<span class="math inline">\(q\)</span> 和 <span
class="math inline">\(q^2\)</span> 的期望。 <span
class="math display">\[E_i(q)=p_i(E_{i-1}(q)+1)\]</span> <span
class="math display">\[E_i(q^2)=p_i(E_{i-1}(q^2)+2E_{i-1}(q)+1)\]</span>
总式子 <span
class="math display">\[f_i=f_{i-1}+p_i(3E_{i-1}(q^2)+3E_{i-1}(q)+1)\]</span>
已经很详细了就不放代码了。</p>
<h3 id="例题-5"><a href="https://www.luogu.com.cn/problem/P1850"
title="例题 5">例题 5</a></h3>
<p>解决任意两个教室之间的体力消耗最小值，容易想到最短路算法，因本题需要多次查询不同两点间的最短路且
<span class="math inline">\(v\)</span> 较小，考虑使用 Floyd。 之后就是
DP，对每种情况进行分类讨论，设 <span
class="math inline">\(f_{i,j,0/1}\)</span> 表示对于前 <span
class="math inline">\(i\)</span> 门课，选择了 <span
class="math inline">\(j\)</span> 门，最后选择的那门课否/是更换。<span
class="math inline">\(dis_{u,v}\)</span> 表示 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 两点之间的最短路。 那么进行分类讨论
对于 <span
class="math inline">\(f_{i,j,0}\)</span>，若其之前的换了，则有 <span
class="math inline">\(f_{i-1,j,1}+k_{i-1}\times
dis_{d_{i-1},c_i}\)</span>（换成功的期望）<span
class="math inline">\(+(1-k_{i-1})\times
dis_{c_{i-1},c_i}\)</span>（换失败的期望），若之前的没换，则有 <span
class="math inline">\(f_{i-1,j,0}+dis_{c_{i-1},c_i}\)</span>（二者都不换）。
对于 <span class="math inline">\(f_{i,j,1}\)</span>，情况复杂些 -
之前的不换 - 当前换成功 <span class="math inline">\(k_i\times
dis_{c_{i-1},d_i}\)</span> - 当前换失败 <span
class="math inline">\((1-k_i)\times dis_{c_{i-1},c_i}\)</span> -
之前的换 - 之前与当前均成功 <span class="math inline">\(k_{i-1}\times
k_i\times dis_{d_{i-1},d_i}\)</span> - 之前与当前均失败 <span
class="math inline">\((1-k_{i-1})\times (1-k_i)\times
dis_{c_{i-1},c_i}\)</span> - 之前成功当前失败 <span
class="math inline">\(k_{i-1}\times (1-k_i)\times
dis_{d_{i-1},c_i}\)</span> - 之前失败当前成功 <span
class="math inline">\((1-k_{i-1})\times k_i\times
dis_{c_{i-1},d_i}\)</span> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2010</span>,M=<span class="number">90010</span>;</span><br><span class="line"><span class="type">int</span> n,m,v,e;</span><br><span class="line"><span class="type">int</span> c[N],d[N],edge[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"><span class="type">double</span> k[N],dp[<span class="number">2010</span>][<span class="number">2010</span>][<span class="number">2</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(edge,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(edge));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;v,&amp;e);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">			dp[i][j][<span class="number">0</span>]=dp[i][j][<span class="number">1</span>]=<span class="number">1145141919810</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,c+i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,d+i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,k+i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=e;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a,b,w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">		edge[a][b]=<span class="built_in">min</span>(edge[a][b],w);</span><br><span class="line">		edge[b][a]=<span class="built_in">min</span>(edge[b][a],w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=v;i++)</span><br><span class="line">		edge[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k1=<span class="number">1</span>;k1&lt;=v;k1++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=v;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)</span><br><span class="line">				edge[i][j]=<span class="built_in">min</span>(edge[i][j],edge[i][k1]+edge[k1][j]);</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			dp[i][j][<span class="number">0</span>]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+k[i<span class="number">-1</span>]*edge[d[i<span class="number">-1</span>]][c[i]]+</span><br><span class="line">								(<span class="number">1</span>-k[i<span class="number">-1</span>])*edge[c[i<span class="number">-1</span>]][c[i]],</span><br><span class="line">							dp[i<span class="number">-1</span>][j][<span class="number">0</span>]+edge[c[i<span class="number">-1</span>]][c[i]]);</span><br><span class="line">			<span class="keyword">if</span>(j)&#123;</span><br><span class="line">				dp[i][j][<span class="number">1</span>]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+k[i<span class="number">-1</span>]*k[i]*edge[d[i<span class="number">-1</span>]][d[i]]+</span><br><span class="line">									k[i<span class="number">-1</span>]*(<span class="number">1</span>-k[i])*edge[d[i<span class="number">-1</span>]][c[i]]+</span><br><span class="line">									(<span class="number">1</span>-k[i<span class="number">-1</span>])*k[i]*edge[c[i<span class="number">-1</span>]][d[i]]+</span><br><span class="line">									(<span class="number">1</span>-k[i<span class="number">-1</span>])*(<span class="number">1</span>-k[i])*edge[c[i<span class="number">-1</span>]][c[i]],</span><br><span class="line">								dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]+k[i]*edge[c[i<span class="number">-1</span>]][d[i]]+</span><br><span class="line">									(<span class="number">1</span>-k[i])*edge[c[i<span class="number">-1</span>]][c[i]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	ans=<span class="number">1145141919810</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,<span class="built_in">min</span>(dp[n][i][<span class="number">0</span>],dp[n][i][<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="例题-6"><a href="https://www.luogu.com.cn/problem/P1297"
title="例题 6">例题 6</a></h3>
<p>考虑第 <span class="math inline">\(i\)</span> 道题和第 <span
class="math inline">\(i+1\)</span> 道题。 若 <span
class="math inline">\(a_i=a_{i+1}\)</span>，则本题期望显然为 <span
class="math inline">\(\dfrac{1}{a_i}=\dfrac{1}{a_{i+1}}\)</span>。 若
<span class="math inline">\(a_i&gt;a_{i+1}\)</span>，则 <span
class="math inline">\(a_i\)</span> 的答案在 <span
class="math inline">\(a_{i+1}\)</span> 范围内的概率为 <span
class="math inline">\(\dfrac{a_{i+1}}{a_i}\)</span>，期望为 <span
class="math inline">\(\dfrac{a_{i+1}}{a_i}\times
\dfrac{1}{a_{i+1}}=\dfrac{1}{a_i}\)</span>。 若 <span
class="math inline">\(a_i&lt;a_{i+1}\)</span>，正确答案在 <span
class="math inline">\(a_{i}\)</span> 范围内的概率为 <span
class="math inline">\(\dfrac{a_i}{a_{i+1}}\)</span>，期望为 <span
class="math inline">\(\dfrac{a_i}{a_{i+1}}\times
\dfrac{1}{a_i}=\dfrac{1}{a_{i+1}}\)</span>。 综上，第 <span
class="math inline">\(i\)</span> 道题的期望为 <span
class="math inline">\(\dfrac{1}{\max(a_i,a_{i+1})}\)</span>。求出每题期望累加即可。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>]=a[n];<span class="comment">//第一项的上一个是第n项</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	ans+=<span class="number">1.0</span>/<span class="built_in">max</span>(a[i<span class="number">-1</span>],a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.3lf&quot;</span>,ans);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>珂朵莉树·颜色段均摊</title>
    <url>/2025/07/04/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91%C2%B7%E9%A2%9C%E8%89%B2%E6%AE%B5%E5%9D%87%E6%91%8A/</url>
    <content><![CDATA[<p>这玩意名字也是真多，珂朵莉树，ODT（Old Driver
Tree），颜色段均摊都是它。其实我觉得硬说这是一种数据结构（尤其是“树”）是不恰当的，这更多应该是一种技巧。
与线段树等传统数据结构的区别在于：它可以更方便地维护每个被覆盖区间的值。如模板题中的操作
4：求 <span class="math inline">\(\sum_{i=l}^ra_i^x\bmod y\)</span>。
我很喜欢这个东西，它比线段树好写且在随机数据下表现十分优异。</p>
<h3 id="实现">实现</h3>
<p>一般用 <code>std::set</code> 实现。似乎用链表可以省下一个 <span
class="math inline">\(\log\)</span>？不过能用到 ODT
的题应该不差这点时间。</p>
<h4 id="节点">节点</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> l,<span class="type">int</span> r=<span class="number">0</span>,<span class="type">int</span> val=<span class="number">0</span>):<span class="built_in">l</span>(l),<span class="built_in">r</span>(r),<span class="built_in">val</span>(val)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;x.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;node&gt; odt;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(l\)</span> 和 <span
class="math inline">\(r\)</span> 表示这一段的区间，<span
class="math inline">\(val\)</span> 表示这一段的权值，使用
<code>mutable</code> 修饰是为了使得结构体或函数在被 <code>const</code>
修饰后仍能修改 <span class="math inline">\(val\)</span>
的值，这样，我们就可以直接修改在 <code>set</code> 内部的元素的 <span
class="math inline">\(val\)</span>。</p>
<h4 id="split">split</h4>
<p>用于将一个区间为 <span class="math inline">\([l,r]\)</span>
的区间分裂为 <span class="math inline">\([l,pos)\)</span> 和 <span
class="math inline">\([pos,r]\)</span>，并返回指向后者的迭代器的函数。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">split</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;n) <span class="keyword">return</span> odt.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">auto</span> it=odt.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(pos));</span><br><span class="line">    <span class="keyword">if</span>(it!=odt.<span class="built_in">end</span>()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;<span class="comment">//pos已是左端点，无需分割</span></span><br><span class="line">    it--;<span class="comment">//从上一个分割</span></span><br><span class="line">    <span class="type">int</span> l=it-&gt;l,r=it-&gt;r,val=it-&gt;val;</span><br><span class="line">    odt.<span class="built_in">erase</span>(it);<span class="comment">//删除原区间</span></span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,pos<span class="number">-1</span>,val));<span class="comment">//左区间</span></span><br><span class="line">    <span class="keyword">return</span> odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(pos,r,val)).first;<span class="comment">//右区间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>std::set::insert()</code> 返回一个
<code>std::pair&lt;iterator,bool&gt;</code>，表示插入元素的迭代器及插入是否成功。
现代编译器应当都可以将 <code>auto</code> 识别为
<code>std::set&lt;node&gt;::iterator</code>。</p>
<h4 id="assign">assign</h4>
<p>用于区间赋值。同时也是时间复杂度的保证，以模板题为例，大约 <span
class="math inline">\(\dfrac{1}{4}\)</span> 的操作调用了
<code>assign</code>，而这个操作可以大幅减小 <code>set</code> 的大小。
<strong>特别注意：在截取 <span class="math inline">\([l,r]\)</span>
时一定要先调用 <code>split(r+1)</code> 再调用
<code>split(l)</code>，否则可能导致 RE。</strong> 具体原因可以看<a
href="https://oi-wiki.org/misc/odt/#assign-%E6%93%8D%E4%BD%9C"
title="这里">这里</a>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr=<span class="built_in">split</span>(r<span class="number">+1</span>),itl=<span class="built_in">split</span>(l);<span class="comment">//截取[l,r]</span></span><br><span class="line">    odt.<span class="built_in">erase</span>(itl,itr);<span class="comment">//删除[l,r]</span></span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,r,val));<span class="comment">//插入新值</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="模板题"><a
href="https://codeforces.com/problemset/problem/896/C"
title="模板题">模板题</a></h3>
<p>对于 1 操作，3 操作和 4 操作，直接分离出对应区间后暴力求解。2
操作直接用 <code>assign</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> ll val;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> l,<span class="type">int</span> r=<span class="number">0</span>,ll val=<span class="number">0</span>):<span class="built_in">l</span>(l),<span class="built_in">r</span>(r),<span class="built_in">val</span>(val)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;x.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    a%=mod;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">set&lt;node&gt; odt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">split</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it=odt.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(pos));</span><br><span class="line">    <span class="keyword">if</span>(it!=odt.<span class="built_in">end</span>()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    it--;</span><br><span class="line">    <span class="type">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class="line">    ll val=it-&gt;val;</span><br><span class="line">    odt.<span class="built_in">erase</span>(it);</span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,pos<span class="number">-1</span>,val));</span><br><span class="line">    <span class="keyword">return</span> odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(pos,r,val)).first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr=(<span class="built_in">split</span>(r<span class="number">+1</span>)),itl=<span class="built_in">split</span>(l);</span><br><span class="line">    odt.<span class="built_in">erase</span>(itl,itr);</span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,r,val));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr=<span class="built_in">split</span>(r<span class="number">+1</span>),itl=<span class="built_in">split</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;itl++)</span><br><span class="line">        itl-&gt;val+=val;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">kth</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr=<span class="built_in">split</span>(r<span class="number">+1</span>),itl=<span class="built_in">split</span>(l);</span><br><span class="line">    vector&lt;pair&lt;ll,<span class="type">int</span>&gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;itl++)</span><br><span class="line">        b.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(itl-&gt;val,itl-&gt;r-itl-&gt;l<span class="number">+1</span>));</span><br><span class="line">    <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:b)&#123;</span><br><span class="line">        k-=t.second;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> t.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> itr=<span class="built_in">split</span>(r<span class="number">+1</span>),itl=<span class="built_in">split</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;itl++)</span><br><span class="line">        res=(res+(<span class="built_in">qpow</span>(itl-&gt;val,x,mod)*(itl-&gt;r-itl-&gt;l<span class="number">+1</span>))%mod)%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,seed,vmax,a[N],op,x,y,l,r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=seed;</span><br><span class="line">    seed=(seed*<span class="number">7ll</span><span class="number">+13</span>)%<span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;seed&gt;&gt;vmax;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=(<span class="built_in">rnd</span>()%vmax)<span class="number">+1</span>;</span><br><span class="line">        odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(i,i,a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        op=(<span class="built_in">rnd</span>()%<span class="number">4</span>)<span class="number">+1</span>;</span><br><span class="line">        l=(<span class="built_in">rnd</span>()%n)<span class="number">+1</span>;</span><br><span class="line">        r=(<span class="built_in">rnd</span>()%n)<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">            <span class="built_in">swap</span>(l,r);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>)</span><br><span class="line">            x=(<span class="built_in">rnd</span>()%(r-l<span class="number">+1</span>))<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x=(<span class="built_in">rnd</span>()%vmax)<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">4</span>)</span><br><span class="line">            y=(<span class="built_in">rnd</span>()%vmax)<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">add</span>(l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">assign</span>(l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)</span><br><span class="line">            cout&lt;&lt;<span class="built_in">kth</span>(l,r,x)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="built_in">sum</span>(l,r,x,y)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <del>十年 OI 一场空，不开
long long 见祖宗。</del></p>
<h3 id="复杂度分析">复杂度分析</h3>
<p>我们可以从模板题中发现，这玩意除区间赋值外都需要暴力，所以是一种暴力数据结构。对于模板题，均摊时间复杂度
<span class="math inline">\(O(m\log
n)\)</span>。其时间复杂度保证完全依赖于
<code>assign</code>，所以仅适用于数据随机生成且带区间赋值操作的题。比如区间染色问题。</p>
<h3 id="参考资料">参考资料</h3>
<p><a
href="https://www.cnblogs.com/EdisonBa/p/13509379.html">https://oi-wiki.org/misc/odt/</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>笛卡尔树分治</title>
    <url>/2025/08/22/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p>模拟赛时碰到了，感觉这个东西很优美啊，学习一下。<br />
经典应用就是与区间最值算贡献相关的一类问题。<br />
我们以 <a
href="https://codeforces.com/problemset/problem/1156/E">Special Segments
of Permutation</a> 这道题为例讲解一下这种技巧。<br />
首先，我们可以将所有区间分为以 <span class="math inline">\(p_1\)</span>
为最大值的区间、以 <span class="math inline">\(p_2\)</span>
为最大值的区间……我们可以在整个序列中划出极长的一段 <span
class="math inline">\([l,r]\)</span>，这一段的最大值所处的位置为 <span
class="math inline">\(mid\)</span>，则可以递归到 <span
class="math inline">\([l,mid-1]\)</span> 和 <span
class="math inline">\([mid+1,r]\)</span>
两端解决子问题。我们发现，笛卡尔树的结构完美符合递归的要求。我们可以考虑当前分治区间
<span class="math inline">\([l,r]\)</span>，区间最大值位置是 <span
class="math inline">\(mid\)</span>，则只需在 <span
class="math inline">\([l,mid]\)</span> 和 <span
class="math inline">\([mid,r]\)</span> 各选取一个端点即可得到一个以
<span class="math inline">\(p_{mid}\)</span>
为最大值的区间。这个过程有点像 cdq 分治的思想，总结一下：</p>
<ul>
<li><p>找到区间最大值所在位置 <span
class="math inline">\(mid\)</span>；</p></li>
<li><p>处理跨越 <span class="math inline">\(mid\)</span>
的区间，此时处理的区间最大值一定是 <span
class="math inline">\(p_{mid}\)</span>；</p></li>
<li><p>递归处理子区间 <span class="math inline">\([l,mid-1]\)</span> 和
<span class="math inline">\([mid+1,r]\)</span>。</p></li>
</ul>
<p>考虑时间复杂度问题。由于区间不是对半均分，所以我们采用启发式的思想，保证统计答案时<strong>只枚举短区间</strong>，时间复杂度
<span class="math inline">\(O(n\log
n)\)</span>，否则时间复杂度可能退化至 <span
class="math inline">\(O(n^2)\)</span>。以本题为例，由于 <span
class="math inline">\(p_i\)</span>
各不相同，所以可以直接处理出每个值对应的位置，假设 <span
class="math inline">\([l,mid]\)</span> 这一段较短，那么在这个区间内枚举
<span class="math inline">\(i\)</span>，每次查询 <span
class="math inline">\(p_{mid}-p_i\)</span> 是否在区间 <span
class="math inline">\([mid,r]\)</span>
内即可。可以不显式建出笛卡尔树，保证递归结构正确即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,p[N],b[N],ans,P;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> pos,val;</span><br><span class="line">    <span class="keyword">friend</span> node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;x,<span class="type">const</span> node &amp;y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.val&lt;y.val?y:x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    l+=P<span class="number">-1</span>,r+=P<span class="number">+1</span>;</span><br><span class="line">    node res=&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(l^<span class="number">1</span>^r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~l&amp;<span class="number">1</span>) res=res+tree[l^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(r&amp;<span class="number">1</span>) res=res+tree[r^<span class="number">1</span>];</span><br><span class="line">        l&gt;&gt;=<span class="number">1</span>,r&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=<span class="built_in">query</span>(l,r);</span><br><span class="line">    <span class="built_in">solve</span>(l,mid<span class="number">-1</span>),<span class="built_in">solve</span>(mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="keyword">if</span>(mid-l&lt;r-mid)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=mid;i++)&#123;</span><br><span class="line">            <span class="type">int</span> pos=b[p[mid]-p[i]];</span><br><span class="line">            ans+=(pos&gt;=mid&amp;&amp;pos&lt;=r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&lt;=r;i++)&#123;</span><br><span class="line">            <span class="type">int</span> pos=b[p[mid]-p[i]];</span><br><span class="line">            ans+=(pos&gt;=l&amp;&amp;pos&lt;=mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    P=<span class="number">1</span>;<span class="keyword">while</span>(P&lt;=n<span class="number">+1</span>) P&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(p[i]);</span><br><span class="line">        b[p[i]]=i;</span><br><span class="line">        tree[P+i]=&#123;i,p[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=P<span class="number">-1</span>;i;i--) tree[i]=tree[i&lt;&lt;<span class="number">1</span>]+tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>习题：</p>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P4755">Beautiful
Pair</a></p></li>
<li><p><a href="https://www.luogu.com.cn/problem/CF1175F">The Number of
Subpermutations</a></p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P9607">[CERC2019] Be
Geeks!</a></p></li>
</ul>
<p>感谢 <a href="https://www.cnblogs.com/Kenma"><span class="citation"
data-cites="_Kenma_">@_Kenma_</span></a> 提供题目！</p>
]]></content>
      <tags>
        <tag>其他技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数入门</title>
    <url>/2025/07/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="矩阵">矩阵</h3>
<h4 id="运算法则">运算法则</h4>
<h5 id="加法">加法</h5>
<p>两个矩阵 <span class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 相加，要求它们的维度相同。结果矩阵
<span class="math inline">\(C=A+B\)</span> 的每个元素是 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 对应元素的和。<span
class="math inline">\(C_{i,j}=A_{i,j}+B_{i,j}\)</span> ##### 数乘 矩阵
<span class="math inline">\(A\)</span> 与标量 <span
class="math inline">\(k\)</span> 相乘，结果矩阵 <span
class="math inline">\(B=kA\)</span> 的每个元素是 <span
class="math inline">\(A\)</span> 的对应元素乘以 <span
class="math inline">\(k\)</span>。<span
class="math inline">\(B_{i,j}=k\cdot A_{i,j}\)</span> ##### 乘法 矩阵
<span class="math inline">\(A\)</span> 与矩阵 <span
class="math inline">\(B\)</span> 相乘，要求 <span
class="math inline">\(A\)</span> 的列数等于 <span
class="math inline">\(B\)</span> 的行数。结果矩阵 <span
class="math inline">\(C=AB\)</span> 的每个元素是 <span
class="math inline">\(A\)</span> 的行向量与 <span
class="math inline">\(B\)</span> 的列向量的点积。<span
class="math inline">\(C_{i,j}=\sum_{k=1}^nA_{i,k}\cdot B_{k,j}\)</span>
<strong>注意：矩阵乘法不满足交换律</strong> #### 矩阵快速幂
其实和普通快速幂几乎一样。 我们要使用单位矩阵 <span
class="math display">\[I=\begin{bmatrix}
1&amp;0&amp;\cdots&amp;0\\
0&amp;1&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;1
\end{bmatrix}\]</span>
作为初始矩阵。因为它乘任何矩阵还得跟它乘的那个矩阵，类似于 <span
class="math inline">\(1\)</span> 在普通快速幂中的作用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">	<span class="built_in">matrix</span>()&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">	&#125;</span><br><span class="line">	matrix <span class="keyword">operator</span>*(<span class="type">const</span> matrix &amp;b)<span class="type">const</span>&#123;</span><br><span class="line">		matrix res;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">					res.a[i][j]=(res.a[i][j]+a[i][k]*b.a[k][j]%mod)%mod;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;ans,base,a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		base.a[i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">qpow</span><span class="params">(matrix a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">	matrix res=base;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">			res=res*a;</span><br><span class="line">		a=a*a;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a.a[i][j]);</span><br><span class="line">	ans=<span class="built_in">qpow</span>(a,k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans.a[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
#### 矩阵加速线性递推 例如斐波那契数列，<span
class="math inline">\(F_1=F_2=1\)</span>，<span
class="math inline">\(F_i=F_{i-1}+F_{i-2}\)</span>，矩阵递推形式为 <span
class="math display">\[\begin{bmatrix}F_{n-1}&amp;F_{n-2}\end{bmatrix}
\begin{bmatrix}1&amp;1\\
1&amp;0\end{bmatrix}=
\begin{bmatrix}F_n&amp;F_{n-1}\end{bmatrix}\]</span> 则 <span
class="math inline">\(F_n\)</span> 就是 <span
class="math inline">\(\begin{bmatrix}1&amp;1\end{bmatrix}\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^{n-2}\)</span>
的第一行第一列的元素。用矩阵快速幂即可。</p>
<h3 id="高斯消元">高斯消元</h3>
<p>现有线性方程组 <span
class="math display">\[\begin{cases}a_{1,1}x_1+a_{1,2}x_2+\cdots+a_{1,n}x_n=b_1\\
a_{2,1}x_1+a_{2,2}x_2+\cdots+a_{2,n}x_n=b_2\\
\cdots\\
a_{n,1}x_1+a_{n,2}x_2+\cdots+a_{n,n}x_n=b_n
\end{cases}\]</span> 求解该方程组。 为了方便起见，我们用矩阵表示方程组：
<span
class="math display">\[\left[\begin{matrix}a_{1,1}&amp;a_{1,2}&amp;a_{1,3}&amp;\cdots&amp;a_{1,n}\\
a_{2,1}&amp;a_{2,2}&amp;a_{2,3}&amp;\cdots&amp;a_{2,n}\\
a_{3,1}&amp;a_{3,2}&amp;a_{3,3}&amp;\cdots&amp;a_{3,n}\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
a_{n,1}&amp;a_{n,2}&amp;a_{n,3}&amp;\cdots&amp;a_{n,n}
\end{matrix}\middle|
\begin{matrix}
b_{1}\\
b_{2}\\
b_{3}\\
\vdots\\
b_{n}
\end{matrix}\right]\]</span> 首先消去除 <span
class="math inline">\(1\)</span> 式以外所有式子中的 <span
class="math inline">\(x_1\)</span>，然后消去除 <span
class="math inline">\(1\)</span> 式和 <span
class="math inline">\(2\)</span> 式外所有式子中的 <span
class="math inline">\(x_2\)</span>……最后式子变为一个三角形的结构 <span
class="math display">\[\left[\begin{matrix}a_{1,1}&#39;&amp;a_{1,2}&#39;&amp;a_{1,3}&#39;&amp;\cdots&amp;a_{1,n}&#39;\\
0&amp;a_{2,2}&#39;&amp;a_{2,3}&#39;&amp;\cdots&amp;a_{2,n}&#39;\\
0&amp;0&amp;a_{3,3}&#39;&amp;\cdots&amp;a_{3,n}&#39;\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;0&amp;\cdots&amp;a_{n,n}&#39;
\end{matrix}\middle|
\begin{matrix}
b_{1}&#39;\\
b_{2}&#39;\\
b_{3}&#39;\\
\vdots\\
b_{n}&#39;
\end{matrix}\right]\]</span> 之后再一点点代回求解，时间复杂度 <span
class="math inline">\(O(n^3)\)</span>。 对于无解的判断：某一行前 <span
class="math inline">\(n\)</span> 个数均为 <span
class="math inline">\(0\)</span>，最后的结果却不为 <span
class="math inline">\(0\)</span>。 对于无数解的判断：某一行 <span
class="math inline">\(n+1\)</span> 个数均为 <span
class="math inline">\(0\)</span>。 <a
href="https://www.luogu.com.cn/problem/P3389" title="模板">模板</a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="type">int</span> r=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(matrix[r][i])&lt;<span class="built_in">fabs</span>(matrix[j][i]))</span><br><span class="line">			r=j;<span class="comment">//寻找主元 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(matrix[r][i])&lt;eps)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;No Solution&quot;</span>);<span class="comment">//若主元为0，方程组无解或无穷多解 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i!=r)</span><br><span class="line">		<span class="built_in">swap</span>(matrix[i],matrix[r]);</span><br><span class="line">	<span class="type">double</span> div=matrix[i][i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n<span class="number">+1</span>;j++)</span><br><span class="line">		matrix[i][j]/=div;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">		div=matrix[j][i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=n<span class="number">+1</span>;k++)</span><br><span class="line">			matrix[j][k]-=matrix[i][k]*div;</span><br><span class="line">	&#125;<span class="comment">//消元</span></span><br><span class="line">&#125;</span><br><span class="line">ans[n]=matrix[n][n<span class="number">+1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i;i--)&#123;</span><br><span class="line">	ans[i]=matrix[i][n<span class="number">+1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">		ans[i]-=matrix[i][j]*ans[j];</span><br><span class="line">&#125;<span class="comment">//回代</span></span><br></pre></td></tr></table></figure> <a href="https://www.luogu.com.cn/problem/P2455"
title="加强版">加强版</a> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="type">int</span> pivot=rank1<span class="number">+1</span>;<span class="comment">//rank1为矩阵的秩 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=rank1<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(matrix[pivot][i])&lt;<span class="built_in">fabs</span>(matrix[j][i]))</span><br><span class="line">			pivot=j;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(matrix[pivot][i])&lt;eps)</span><br><span class="line">		<span class="keyword">continue</span>;<span class="comment">//全为零</span></span><br><span class="line">	<span class="keyword">if</span>(pivot!=rank1<span class="number">+1</span>)</span><br><span class="line">		<span class="built_in">swap</span>(matrix[pivot],matrix[rank1<span class="number">+1</span>]);</span><br><span class="line">	<span class="type">double</span> div=matrix[rank1<span class="number">+1</span>][i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n<span class="number">+1</span>;j++)</span><br><span class="line">		matrix[rank1<span class="number">+1</span>][j]/=div;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==rank1<span class="number">+1</span>||<span class="built_in">fabs</span>(matrix[j][i])&lt;eps)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		div=matrix[j][i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=n<span class="number">+1</span>;k++)</span><br><span class="line">			matrix[j][k]-=matrix[rank1<span class="number">+1</span>][k]*div;</span><br><span class="line">	&#125;<span class="comment">//消元</span></span><br><span class="line">	rank1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=rank1<span class="number">+1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(matrix[i][n<span class="number">+1</span>])&gt;eps)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//无解</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">if</span>(rank1&lt;n)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//无数解</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)&#123;</span><br><span class="line">	ans[i]=matrix[i][n<span class="number">+1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">		ans[i]-=matrix[i][j]*ans[j];</span><br><span class="line">&#125;<span class="comment">//回代</span></span><br></pre></td></tr></table></figure> ### 高斯-约旦消元 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,line=<span class="number">1</span>,cur;i&lt;=n;i++)&#123;</span><br><span class="line">    cur=line;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=line<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i])&gt;<span class="built_in">fabs</span>(a[cur][i]))</span><br><span class="line">            cur=j;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[cur][i])&lt;eps) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">double</span> temp=a[cur][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n<span class="number">+1</span>;j++)</span><br><span class="line">        <span class="built_in">swap</span>(a[cur][j],a[line][j]),a[line][j]/=temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">if</span>(j!=line)&#123;</span><br><span class="line">            temp=a[j][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">+1</span>;k++)</span><br><span class="line">                a[j][k]-=a[line][k]*temp;</span><br><span class="line">        &#125;</span><br><span class="line">    ++line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### 线性基 引入：有 <span class="math inline">\(n\)</span>
个数，选出其中任意一些数，求其异或和，一共有多少种可能的异或值。 ####
性质 1. 原序列里面的任意一个数都可以表示为线性基的一个子集的异或和。 1.
线性基任意一个子集的异或和都不能等于 <span
class="math inline">\(0\)</span>。 1.
线性基里面的数的个数唯一，并且在保持性质 1 的前提下，数的个数是最少的。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LBase</span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> d[<span class="number">61</span>];</span><br><span class="line">	<span class="built_in">LBase</span>()&#123;</span><br><span class="line">		<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(x&amp;<span class="number">1ll</span>&lt;&lt;i)&#123;</span><br><span class="line">				<span class="keyword">if</span>(d[i])</span><br><span class="line">					x^=d[i];</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					d[i]=x;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query_max</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> x=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">			<span class="keyword">if</span>(d[i]&amp;&amp;(x^d[i])&gt;x)</span><br><span class="line">				x^=d[i];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> LBase &amp;a)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">			<span class="keyword">if</span>(a.d[i])</span><br><span class="line">				<span class="built_in">insert</span>(a.d[i]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2025/08/20/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p>最近被各种乱七八糟的根号整的有点魔怔。重新系统总结一下线段树。</p>
<h2 id="基础">基础</h2>
<p>线段树是一种维护<strong>区间信息</strong>的数据结构，绝大多数区间信息（如区间和，区间最值）都可以使用线段树高效维护。<br />
若区间的合并操作是 <span class="math inline">\(O(1)\)</span>
的，则线段树单点修改、区间查询操作是 <span class="math inline">\(O(\log
n)\)</span> 的。<br />
若是带懒标记的线段树，如果懒标记下放操作是 <span
class="math inline">\(O(1)\)</span> 的，则线段树区间修改操作是 <span
class="math inline">\(O(\log n)\)</span> 的。<br />
构建线段树最重要的操作是合并左右两个区间，也就是 push up 操作。<br />
线段树的空间复杂度问题： 设有 <span class="math inline">\(n\)</span>
个叶子节点，线段树的深度是 <span class="math inline">\(\lceil\log
n\rceil\)</span>，按照堆式存储（即 <span
class="math inline">\(2u\)</span> 是 <span
class="math inline">\(u\)</span> 的左儿子，<span
class="math inline">\(2u+1\)</span> 是 <span
class="math inline">\(u\)</span> 的右儿子）的方式，总节点个数 <span
class="math inline">\(2^{\lceil\log n\rceil+1}-1\)</span>，在 <span
class="math inline">\(n\)</span> 为 <span
class="math inline">\(2\)</span> 的整次幂加 <span
class="math inline">\(1\)</span> 时取到最大值 <span
class="math inline">\(4n-5\)</span>。所以平时线段树一定要开 <span
class="math inline">\(4\)</span> 倍空间。<br />
<span class="math inline">\(k\)</span> 叉线段树的复杂度为 <span
class="math inline">\(O(k\log_kn)\)</span>，其有 <span
class="math inline">\(O(\log_kn)\)</span> 层，每层要对 <span
class="math inline">\(k\)</span> 个节点进行操作。<br />
常数中等。涉及区间修改且满足交换律的操作可以使用标记永久化减小常数。如果使用
zkw 线段树避免递归操作可以显著减小常数。<br />
练手题：</p>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P3372">【模板】线段树
1</a>，最简单最基础的线段树。</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P3373">【模板】线段树
2</a>，多个懒标记且涉及运算顺序的问题。</p></li>
<li><p><a
href="https://www.luogu.com.cn/problem/P1471">方差</a>，很板的题。</p></li>
</ul>
<h3 id="经典套路">经典套路</h3>
<h4 id="跨区间问题">跨区间问题</h4>
<h5 id="小白逛公园"><a
href="https://www.luogu.com.cn/problem/P4513">小白逛公园</a></h5>
<p>单点修改、区间最大子段和。<br />
考虑如何合并两个区间。<br />
新区间的最大子段和可能是左区间的最大子段和、右区间的最大子段和、左区间强制包含右端点的最大子段和加上右区间强制包含左端点的最大子段和。<br />
区间强制包含左右端点的最大子段和可以通过区间和辅助维护。<br />
总结一下，一个节点内需要维护：区间和、区间最大子段和、区间强制包含左端点的最大子段和、区间强制包含右端点的最大子段和。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum,maxn,maxl,maxr;</span><br><span class="line">    <span class="keyword">friend</span> node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;x,<span class="type">const</span> node &amp;y)&#123;</span><br><span class="line">        node res;</span><br><span class="line">        res.sum=x.sum+y.sum;</span><br><span class="line">        res.maxn=<span class="built_in">max</span>(&#123;x.maxn,y.maxn,x.maxr+y.maxl&#125;);</span><br><span class="line">        res.maxl=<span class="built_in">max</span>(x.maxl,x.sum+y.maxl);</span><br><span class="line">        res.maxr=<span class="built_in">max</span>(y.maxr,y.sum+x.maxr);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> trick：像这一类区间合并较为复杂的线段树，可以考虑将
<code>+</code> 重载，这样合并两个区间就更为方便了。<br />
<strong>一定注意，这里的合并没有交换律。</strong><br />
习题：<br />
<a href="https://www.luogu.com.cn/problem/P2572">[SCOI2010]
序列操作</a>。</p>
<h4 id="维护其他有结合律的信息">维护其他有结合律的信息</h4>
<h5 id="国家集训队-等差子序列"><a
href="https://www.luogu.com.cn/problem/P2757">[国家集训队]
等差子序列</a></h5>
<p>线段树维护哈希。</p>
<h5 id="thusc-2017-大魔法师"><a
href="https://www.luogu.com.cn/problem/P7453">[THUSC 2017]
大魔法师</a></h5>
<p>线段树维护矩阵。常数较大。</p>
<h4 id="势能分析">势能分析</h4>
<p>一类题目看似操作复杂度很高，但是可以通过势能分析证明其复杂度是可接受的。</p>
<h5 id="上帝造题的七分钟-2-花神游历各国"><a
href="https://www.luogu.com.cn/problem/P4145">上帝造题的七分钟 2 /
花神游历各国</a></h5>
<p>区间开方是非常难以维护的操作，但是注意到一个数 <span
class="math inline">\(x\)</span> 最多进行 <span
class="math inline">\(O(\log \log x)\)</span> 次操作就可以变为 <span
class="math inline">\(1\)</span>，之后的操作不会使数变得更小。所以我们可以在每个节点维护一个
<span class="math inline">\(tag\)</span>，若当前区间内所有数均为 <span
class="math inline">\(1\)</span>，那么直接返回。<br />
所以总体时间复杂度为 <span class="math inline">\(O(n\log \log
V)\)</span>。</p>
<h4 id="线段树优化建图">线段树优化建图</h4>
<p>有时候需要在一个点和一个区间之间连边。这时可以利用线段树的区间性质，降低空间复杂度。</p>
<h2 id="权值线段树">权值线段树</h2>
<p>通俗的理解就是在桶数组上开线段树。可以高效查询第 <span
class="math inline">\(k\)</span> 小等信息。</p>
<h2 id="动态开点线段树">动态开点线段树</h2>
<p>不再采用堆式存储，只在需要时，也就是第一次访问时创建节点。每个节点维护两个指针
<span class="math inline">\(ls\)</span> 和 <span
class="math inline">\(rs\)</span>，表示当前节点的左右儿子。此时线段树最多只会创建
<span class="math inline">\(2n-1\)</span>
个节点。不会像普通的堆式存储线段树一样存在空间浪费。<br />
常数较大。<br />
若需要区间修改，最好使用标记永久化以防止空间复杂度过大。</p>
<h2 id="可持久化线段树">可持久化线段树</h2>
<h3 id="可持久化数组">可持久化数组</h3>
<p>开一个 <span class="math inline">\(root\)</span>
数组，表示不同的版本。线段树的叶子节点即为我们可持久化的数组。上层的节点仅为了维持线段树的结构而存在。由于单点修改最多创建
<span class="math inline">\(O(\log n)\)</span>
个节点，所以使用动态开点可以使得空间复杂度变得可接受。<br />
可以使用可持久化数组实现可持久化并查集。注意不可使用路径压缩，否则会因为修改操作过多、创建过多新版本导致空间爆炸。<br />
常数较大。</p>
<h3 id="主席树">主席树</h3>
<p>即可持久化权值线段树。可以解决的经典问题是静态区间第 <span
class="math inline">\(k\)</span>
小问题。利用前缀和/差分思想进行主席树上二分。<br />
常数较大。</p>
<h2 id="线段树合并">线段树合并</h2>
<p>可以处理类似主席树能处理的问题。还能处理一类树上问题。<br />
常数较大。</p>
<h3 id="树套树">树套树</h3>
<p>用于维护多维信息。常数巨大。</p>
<h3 id="李超线段树">李超线段树</h3>
<h4 id="原理">原理</h4>
<p>我们以<a
href="https://www.luogu.com.cn/problem/P4097">模板题</a>为例讲解李超线段树工作原理。<br />
首先我们有一个基于值域的线段树。<br />
称一个线段在区间 <span class="math inline">\([l,r]\)</span>
中最优当且仅当该线段完全覆盖 <span class="math inline">\([l,r]\)</span>
且在 <span class="math inline">\(mid\)</span>
处的值为所有线段最大。<br />
线段树上每个节点保存对应区间的最优线段。<strong>注意：区间的线段不能保证对于区间内所有点都取到最优。</strong><br />
考虑在一个区间插入一个线段 <span
class="math inline">\(f\)</span>，若原区间有最优线段，设其为 <span
class="math inline">\(f&#39;\)</span>：</p>
<ul>
<li><p>若区间内原本没有线段，则直接令 <span
class="math inline">\(f\)</span> 成为最优线段；</p></li>
<li><p>若 <span class="math inline">\(f\)</span> 完全位于 <span
class="math inline">\(f&#39;\)</span> 上方（即“<span
class="math inline">\(f\)</span> 严格优于 <span
class="math inline">\(f&#39;\)</span>”），直接替换掉；</p></li>
<li><p>反之，<span class="math inline">\(f\)</span>
不可能再成为最优线段，停止递归；</p></li>
<li><p>若 <span class="math inline">\(f\)</span> 部分优于 <span
class="math inline">\(f&#39;\)</span>，则二者交点必然在区间内。按区间
<span class="math inline">\(mid\)</span> 分开，则此时必然是：</p>
<ul>
<li><p>一个子区间内存在“严格优于”的关系；</p></li>
<li><p>另一个子区间内是二者交点。递归更新。</p></li>
</ul></li>
</ul>
<p>对于第 3
种情况，不是区间最优线段的线段也有可能成为这个区间的答案。</p>
<p>单次查询操作时间复杂度 <span class="math inline">\(O(\log
n)\)</span>，全局修改时间复杂度 <span class="math inline">\(O(\log
n)\)</span>，区间修改时间复杂度 <span
class="math inline">\(O(\log^2n)\)</span>。李超线段树的常数较小。</p>
<h4 id="code">code</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Abs</span><span class="params">(<span class="type">const</span> T &amp;x)</span></span>&#123;<span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">    <span class="type">double</span> k,b;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x*k+b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segmenttree</span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    line L;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,line p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">        <span class="type">double</span> ly1=tree[u].L.<span class="built_in">Y</span>(l),ry1=tree[u].L.<span class="built_in">Y</span>(r);</span><br><span class="line">        <span class="type">double</span> ly2=p.<span class="built_in">Y</span>(l),ry2=p.<span class="built_in">Y</span>(r);</span><br><span class="line">        <span class="keyword">if</span>(!tree[u].flag) tree[u].L=p,tree[u].flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ly2-ly1&gt;eps&amp;&amp;ry2-ry1&gt;eps) tree[u].L=p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ly2-ly1&gt;eps||ry2-ry1&gt;eps)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">double</span> midy1=tree[u].L.<span class="built_in">Y</span>(mid);</span><br><span class="line">            <span class="type">double</span> midy2=p.<span class="built_in">Y</span>(mid);</span><br><span class="line">            <span class="keyword">if</span>(midy2-midy1&gt;eps) <span class="built_in">swap</span>(tree[u].L,p);</span><br><span class="line">            <span class="keyword">if</span>(p.<span class="built_in">Y</span>(l)&gt;tree[u].L.<span class="built_in">Y</span>(l)) <span class="built_in">modify</span>(ls,l,mid,x,y,p);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(ls,l,mid,x,y,p);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Res</span>&#123;<span class="type">double</span> y;<span class="type">int</span> id;&#125;;</span><br><span class="line"><span class="function">Res <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    Res res=&#123;tree[u].L.<span class="built_in">Y</span>(x),tree[u].L.id&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)&#123;</span><br><span class="line">        Res resl=<span class="built_in">query</span>(ls,l,mid,x);</span><br><span class="line">        <span class="keyword">if</span>(resl.y&gt;res.y||(<span class="built_in">Abs</span>(resl.y-res.y)&lt;eps&amp;&amp;resl.id&lt;res.id))</span><br><span class="line">            res=resl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Res resr=<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">        <span class="keyword">if</span>(resr.y&gt;res.y||(<span class="built_in">Abs</span>(resr.y-res.y)&lt;eps&amp;&amp;resr.id&lt;res.id))</span><br><span class="line">            res=resr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="segment-tree-beats">Segment Tree Beats</h3>
<p>没用。学了考场上也调不出来。</p>
<hr />
<p>参考资料：</p>
<p>https://oi-wiki.org/ds/seg/</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学</title>
    <url>/2025/07/19/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<h3 id="模板">模板</h3>
<p>预处理阶乘+阶乘逆元计算组合数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll fact[N],inv_fact[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        fact[i]=fact[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv_fact[n]=<span class="built_in">qpow</span>(fact[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i++)</span><br><span class="line">        inv_fact[i]=inv_fact[i<span class="number">+1</span>]*(i<span class="number">+1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;<span class="keyword">return</span> fact[n]*inv_fact[m]%mod*inv_fact[n-m]%mod;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="插板法">插板法</h3>
<p>现有 <span class="math inline">\(n\)</span> 个完全相同的球，将其分至
<span class="math inline">\(k\)</span> 个盒子中，每个盒子至少 <span
class="math inline">\(1\)</span> 个球，共有多少种分法？<br />
问题等价于用 <span class="math inline">\(k-1\)</span> 个板子插入到 <span
class="math inline">\(n-1\)</span> 个空隙中，将其分为 <span
class="math inline">\(k\)</span> 组的方案数。答案就是 <span
class="math display">\[\binom{n-1}{k-1}\]</span>
若每个盒子允许为空，就会出现多个板子插入同一空隙的情况。我们假设所有盒子中已有
<span class="math inline">\(1\)</span> 个球，那么总共有 <span
class="math inline">\(n+k\)</span> 个球，答案就是 <span
class="math display">\[\binom{n+k-1}{k-1}=\binom{n+k-1}{n}\]</span></p>
<h3 id="二项式定理">二项式定理</h3>
<p><span
class="math display">\[(a+b)^n=\sum_{i=0}^n\binom{n}{i}a^ib^{n-i}\]</span></p>
<h3 id="范德蒙德卷积">范德蒙德卷积</h3>
<p><span
class="math display">\[\sum_{i=0}^k\binom{n}{i}\binom{m}{k-i}=\binom{n+m}{k}\]</span>
组合意义：在 <span class="math inline">\(n+m\)</span> 中选 <span
class="math inline">\(k\)</span> 个，相当于先在 <span
class="math inline">\(n\)</span> 中选 <span
class="math inline">\(i\)</span> 个，再在 <span
class="math inline">\(m\)</span> 中选 <span
class="math inline">\(k-i\)</span> 个。</p>
<h3 id="多重集的排列数">多重集的排列数</h3>
<p>设 <span class="math inline">\(S=\{n_1\cdot a_1,n_2\cdot
a_2,\cdots,n_k\cdot a_k\}\)</span> 表示由 <span
class="math inline">\(n_1\)</span> 个 <span
class="math inline">\(a_1\)</span>，<span
class="math inline">\(n_2\)</span> 个 <span
class="math inline">\(a_2\)</span>，…，<span
class="math inline">\(n_k\)</span> 个 <span
class="math inline">\(a_k\)</span> 组成的多重集，则 <span
class="math inline">\(S\)</span> 的全排列个数为 <span
class="math display">\[\frac{n!}{\prod_{i=1}^k
n_i!}=\frac{n!}{n_1!n_2!\cdots n_k!}\]</span></p>
<h3 id="错排列">错排列</h3>
<p>记 <span class="math inline">\(D_n\)</span> 表示 <span
class="math inline">\(n\)</span> 个元素的错排列数，则有 <span
class="math display">\[D_n=(n-1)\cdot(D_{n-1}+D_{n-2})\]</span> 其中
<span class="math inline">\(D_0=1,D_1=0,D_2=1\)</span>。<br />
对于第 <span class="math inline">\(n\)</span> 个元素，其可以与前 <span
class="math inline">\(n-1\)</span>
个元素中任意一个交换位置。设与它交换的元素所在位置为 <span
class="math inline">\(k\)</span>，交换后分为两种情况：<br />
- 第 <span class="math inline">\(k\)</span> 个元素被交换到第 <span
class="math inline">\(n\)</span> 个位置，则剩下的 <span
class="math inline">\(n-2\)</span> 个元素构成错排列。 - 第 <span
class="math inline">\(k\)</span> 个元素没有交换到第 <span
class="math inline">\(n\)</span> 个位置，则剩下的 <span
class="math inline">\(n-1\)</span> 个元素构成错排列。</p>
<h3 id="圆排列">圆排列</h3>
<p>设 <span class="math inline">\(n\)</span> 个元素的圆排列数为 <span
class="math inline">\(Q_n^n\)</span>。考虑其中一种情况，从不同的位置断开就变为不同的排列，所以有
<span class="math display">\[Q_n^n=\frac{A_n^n}{n}=(n-1)!\]</span>
部分圆排列的公式： <span
class="math display">\[Q_n^r=\frac{A_n^r}{r}=\frac{n!}{r\cdot
(n-r)!}\]</span></p>
<h3 id="常用公式">常用公式</h3>
<h4 id="section">(1)</h4>
<p><span class="math display">\[\binom{n}{m}=\binom{n}{n-m}\]</span>
显然。</p>
<h4 id="section-1">(2)</h4>
<p><span
class="math display">\[\binom{n}{m}=\frac{n}{m}\binom{n-1}{m-1}\]</span>
代数推导显然。</p>
<h4 id="section-2">(3)</h4>
<p><span
class="math display">\[\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}\]</span>
组合意义：杨辉三角递推过程。</p>
<h4 id="section-3">(4)</h4>
<p><span class="math display">\[\sum_{i=0}^n\binom{n}{i}=2^n\]</span>
代数推导： <span
class="math display">\[\sum_{i=0}^n\binom{n}{i}=(1+1)^n\]</span></p>
<h4 id="section-4">(5)</h4>
<p><span
class="math display">\[\sum_{i=0}^n(-1)^i\binom{n}{i}=[n=0]\]</span>
代数推导： <span
class="math display">\[\sum_{i=0}^n(-1)^i\binom{n}{i}=(1-1)^n\]</span></p>
<h4 id="section-5">(6)</h4>
<p><span
class="math display">\[\sum_{i=0}^n\binom{n}{i}^2=\binom{2n}{n}\]</span>
<del>快拿这个式子去诈骗，一骗一个准。</del><br />
代数推导： <span
class="math display">\[\sum_{i=0}^n\binom{n}{i}^2=\sum_{i=0}^n\binom{n}{i}\binom{n}{n-i}=\binom{2n}{n}\]</span></p>
<h4 id="section-6">(7)</h4>
<p><span
class="math display">\[\sum_{i=0}^ni\binom{n}{i}=n2^{n-1}\]</span>
代数推导：<br />
首先处理 <span class="math inline">\(i\dbinom{n}{i}\)</span>： <span
class="math display">\[i\binom{n}{i}=i\cdot \frac{n!}{i!(n-i)!}=n\cdot
\frac{(n-1)!}{(i-1)!(n-i)!}=n\binom{n-1}{i-1}\]</span> 设 <span
class="math inline">\(j=i-1\)</span>，代入： <span
class="math display">\[\sum_{i=0}^ni\binom{n}{i}=n\sum_{j=0}^{n-1}\binom{n-1}{j}=n2^{n-1}\]</span></p>
<h4 id="section-7">(8)</h4>
<p><span
class="math display">\[\sum_{i=0}^n\binom{i}{m}=\binom{n+1}{m+1}\]</span>
组合意义：<br />
本质上是求杨辉三角某一列的和。我们可以发现，开头的 <span
class="math inline">\(\dbinom{m}{m}\)</span> 等于 <span
class="math inline">\(\dbinom{m+1}{m+1}\)</span>，也就是杨辉三角 <span
class="math inline">\(\dbinom{m+1}{m}\)</span>
的右侧，二者求和可以再次传递到右侧，如此不断直到 <span
class="math inline">\(\dbinom{n+1}{m+1}\)</span>。</p>
<p><img
src="https://github.com/headless-piston/blog_images/blob/main/combination.png?raw=true" /></p>
<h4 id="section-8">(9)</h4>
<p><span
class="math display">\[\binom{n}{r}\binom{r}{k}=\binom{n}{k}\binom{n-k}{r-k}\]</span>
代数推导和组合意义都易证。</p>
<h3 id="容斥原理">容斥原理</h3>
<p><span
class="math display">\[\left|\bigcup_{i=1}^{n}S_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i&lt;a_{i+1}
}\left|\bigcap_{i=1}^mS_{a_i}\right|\]</span></p>
<h4 id="min-max-容斥">min-max 容斥</h4>
<p>高大上的东西，我觉得我用不上。现有长度为 <span
class="math inline">\(n\)</span> 的序列 <span
class="math inline">\(\{x_i\}\)</span>，设 <span
class="math inline">\(S=\{1,2,3,\cdots,n\}\)</span>，则有 <span
class="math display">\[\max_{i\in S}{x_i}=\sum_{T\subseteq
S}{(-1)^{|T|-1}\min_{j\in T}{x_j}}\]</span> <span
class="math display">\[\min_{i\in S}{x_i}=\sum_{T\subseteq
S}{(-1)^{|T|-1}\max_{j\in T}{x_j}}\]</span></p>
<h3 id="二项式反演">二项式反演</h3>
<p>若 <span
class="math display">\[g_i=\sum_{j=i}^n\binom{j}{i}f_j\]</span> 则 <span
class="math display">\[f_i=\sum_{j=i}^n\binom{j}{i}(-1)^{j-i}g_j\]</span>
一般 <span class="math inline">\(f_i\)</span> 表示“恰好 <span
class="math inline">\(i\)</span> 个”，<span
class="math inline">\(g_i\)</span> 表示“钦定 <span
class="math inline">\(i\)</span> 个”。<br />
代数推导： <span class="math display">\[\begin{aligned}
\sum_{j=i}^n\binom{j}{i}(-1)^{j-i}g_j&amp;=\sum_{j=i}^n\binom{j}{i}(-1)^{j-i}\sum_{k=j}^n\binom{k}{j}f_k\\
&amp;=\sum_{j=i}^n\sum_{k=j}^n\binom{k}{j}\binom{j}{i}(-1)^{j-i}f_k\\
&amp;=\sum_{k=i}^n\sum_{j=i}^k\binom{k}{i}\binom{k-i}{j-i}(-1)^{j-i}f_k\\
&amp;=\sum_{k=i}^n\binom{k}{i}f_k\sum_{l=0}^{k-i}\binom{k-i}{l}(-1)^l\\
&amp;=\sum_{k=i}^n\binom{k}{i}f_k[k=i]\\
&amp;=f_i
\end{aligned}\]</span> 注意 <span class="math inline">\(g_i\)</span>
的组合意义。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流</title>
    <url>/2025/07/04/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<h3 id="定义">定义</h3>
<p>网络是有向图的一种，不同于其他有向图，一个网络有两个特殊的点<strong>源点（一般记作
<span
class="math inline">\(s\)</span>）</strong>和<strong>汇点（一般记作
<span
class="math inline">\(t\)</span>）</strong>，顾名思义，源点只有出边而汇点只有入边。同时，每条边有边权
<span
class="math inline">\(c\)</span>，表示<strong>容量</strong>，同时还映射一个值
<span
class="math inline">\(flow\)</span>，叫做<strong>流量</strong>。一种容易的理解方式是将边想象成不同大小的管道。值得注意的是，流量可以为负，这一般表示反向流动以及在一些算法中对先前流量分配的“撤销”。
残量网络：将容量已满的边删去，剩下的边构成的图就是残量网络。
增广路：从源点到汇点的一条路径，其中每条边都有剩余容量。 ### 最大流问题
对于一个网络，找到最大的流量。 ### 最小割问题
我们将网络上的一些边进行分割，使之分为两部分，一部分包含 <span
class="math inline">\(s\)</span>，另一部分包含 <span
class="math inline">\(t\)</span>，所有切割的边的容量和叫做网络的最小割。
例：现有网络</p>
<figure>
<img
src="https://github.com/headless-piston/blog_images/blob/main/network-flows_1.png?raw=true"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>其最小割为</p>
<figure>
<img
src="https://github.com/headless-piston/blog_images/blob/main/network-flows_2.png?raw=true"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>即 <span class="math inline">\(3=2+1\)</span>。 ### 最大流最小割定理
对于一个网络，最大流总等于最小割。这个定理看似显然，实则并不好证。<a
href="https://oi-wiki.org/graph/flow/max-flow/#%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E5%AE%9A%E7%90%86"
title="证明">证明</a>。</p>
<hr />
<p>接下来以<a href="https://www.luogu.com.cn/problem/P3376"
title="最大流模板题">最大流模板题</a>为例讲解一些算法。 ### Edmonds-Karp
算法 流程： - 从 <span class="math inline">\(s\)</span> 出发进行 BFS
尝试走到 <span class="math inline">\(t\)</span>，即寻找增广路。 -
找到增广路后计算增广路上剩余容量的最小值 <span
class="math inline">\(f\)</span>，给增广路上每条边加上 <span
class="math inline">\(f\)</span> 容量，并将它们的反向边退掉 <span
class="math inline">\(f\)</span> 容量。 -
在新图上重复以上操作直到增广路不存在。</p>
<p>时间复杂度 <span class="math inline">\(O(nm^2)\)</span>。
关于反向边，有个小技巧，就是直接将正反两边的编号设为 <span
class="math inline">\(2n\)</span> 和 <span
class="math inline">\(2n+1\)</span>，这样可以通过异或 <span
class="math inline">\(1\)</span> 的操作快速完成正反边的转换。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e18</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">210</span>,M=<span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> head[N],tot=<span class="number">1</span>;<span class="comment">//因为要异或1所以初始化为1</span></span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line"><span class="type">int</span> pre[N];<span class="comment">//路径的前驱节点</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> flow[N];<span class="comment">//各边剩余容量最小值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> c;<span class="comment">//剩余容量</span></span><br><span class="line">&#125;e[M*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> flag[N][N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> c)</span></span>&#123;</span><br><span class="line">	e[++tot].to=v;</span><br><span class="line">	e[tot].c=c;</span><br><span class="line">	e[tot].nxt=head[u];</span><br><span class="line">	head[u]=tot;<span class="comment">//正向边</span></span><br><span class="line">	e[++tot].to=u;</span><br><span class="line">	e[tot].c=<span class="number">0</span>;</span><br><span class="line">	e[tot].nxt=head[v];</span><br><span class="line">	head[v]=tot;<span class="comment">//反向边</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	pre[s]=s;</span><br><span class="line">	flow[s]=inf;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(e[i].c==<span class="number">0</span>||pre[v])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			flow[v]=<span class="built_in">min</span>(flow[u],e[i].c);</span><br><span class="line">			pre[v]=i;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">			<span class="keyword">if</span>(v==t)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		<span class="keyword">if</span>(!flag[u][v])&#123;<span class="comment">//去重边</span></span><br><span class="line">			<span class="built_in">add_edge</span>(u,v,w);</span><br><span class="line">			flag[u][v]=tot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			e[flag[u][v]^<span class="number">1</span>].c+=w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u=t;u!=s;u=e[pre[u]^<span class="number">1</span>].to)&#123;</span><br><span class="line">			e[pre[u]].c-=flow[t];</span><br><span class="line">			e[pre[u]^<span class="number">1</span>].c+=flow[t];</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=flow[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### Dinic 算法 个人认为这个更难理解一些。 流程： -
在残量网络中进行 BFS 构建分层图。 - 使用 DFS，每次找到 <span
class="math inline">\(t\)</span> 后直接回溯更新边权。</p>
<p>使用分层图的原因是因为分层图是 DAG，进行 DFS
时不会走回头路或环路，保证了算法的正确性和高效性。 时间复杂度 <span
class="math inline">\(O(n^2m)\)</span>，优于 Edmonds-Karp 算法。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e18</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">210</span>,M=<span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,t,tot=<span class="number">1</span>,head[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> c;</span><br><span class="line">&#125;e[M*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> c)</span></span>&#123;</span><br><span class="line">	e[++tot].to=v;</span><br><span class="line">	e[tot].c=c;</span><br><span class="line">	e[tot].nxt=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	e[++tot].to=u;</span><br><span class="line">	e[tot].c=<span class="number">0</span>;</span><br><span class="line">	e[tot].nxt=head[v];</span><br><span class="line">	head[v]=tot;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> level[N];<span class="comment">//层级</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(level,<span class="number">-1</span>,<span class="built_in">sizeof</span>(level));</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	level[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(e[i].c==<span class="number">0</span>||level[v]!=<span class="number">-1</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			level[v]=level[u]<span class="number">+1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> level[t]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">long</span> <span class="type">long</span> flow)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==t)</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(e[i].c==<span class="number">0</span>||level[v]!=level[u]<span class="number">+1</span>)<span class="comment">//按层dfs</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> temp=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(flow-res,e[i].c));</span><br><span class="line">		e[i].c-=temp;</span><br><span class="line">		e[i^<span class="number">1</span>].c+=temp;</span><br><span class="line">		res+=temp;</span><br><span class="line">		<span class="keyword">if</span>(res==flow)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(res==<span class="number">0</span>)</span><br><span class="line">		level[u]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		<span class="built_in">add_edge</span>(u,v,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">		ans+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 优化：当前弧优化。减少 DFS
对边的重复检查。若某边剩余容量已为 <span
class="math inline">\(0\)</span>，则不再处理这条边。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">int</span> cur[N];<span class="comment">//当前弧优化</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">long</span> <span class="type">long</span> flow)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==t)</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=e[i].nxt)&#123;</span><br><span class="line">		cur[u]=i;<span class="comment">//当前弧优化</span></span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(e[i].c==<span class="number">0</span>||level[v]!=level[u]<span class="number">+1</span>)<span class="comment">//按层dfs</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> temp=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(flow-res,e[i].c));</span><br><span class="line">		e[i].c-=temp;</span><br><span class="line">		e[i^<span class="number">1</span>].c+=temp;</span><br><span class="line">		res+=temp;</span><br><span class="line">		<span class="keyword">if</span>(res==flow)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(res==<span class="number">0</span>)</span><br><span class="line">		level[u]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));<span class="comment">//重置当前弧</span></span><br><span class="line">	ans+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure> ###
最小费用最大流
费用流定义：对于一个网络的每条边，我们再加一个边权称为一个单位流量的费用，记作
<span class="math inline">\(w(u,v)\)</span>，则这条边的费用为 <span
class="math inline">\(f(u,v)\times
w(u,v)\)</span>。与上文中提到的反向边回退流量相同，费用也可以这样操作。
与普通最大流问题不同，最小费用最大流的求解过程不用 BFS
而用最短路算法寻找增广路，这样就保证了最小费用。 这里给出 Edmonds-Karp +
SPFA 的做法。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span><span class="number">+10</span>,M=<span class="number">5e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt,c,w;</span><br><span class="line">&#125;e[M*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,head[N],n,m,s,t;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> c,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	e[++tot].to=v;</span><br><span class="line">	e[tot].nxt=head[u];</span><br><span class="line">	e[tot].c=c;</span><br><span class="line">	e[tot].w=w;</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	e[++tot].to=u;</span><br><span class="line">	e[tot].nxt=head[v];</span><br><span class="line">	e[tot].c=<span class="number">0</span>;</span><br><span class="line">	e[tot].w=-w;</span><br><span class="line">	head[v]=tot;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> min_flow[N],dis[N],pre[N],flow,cost;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(min_flow,<span class="number">0</span>,<span class="built_in">sizeof</span>(min_flow));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	vis[s]=<span class="number">1</span>;</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	min_flow[s]=<span class="number">2e9</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,c=e[i].c,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(c&amp;&amp;dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">				dis[v]=dis[u]+w;</span><br><span class="line">				pre[v]=i;</span><br><span class="line">				min_flow[v]=<span class="built_in">min</span>(min_flow[u],c);</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					vis[v]=<span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min_flow[t]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,c,w;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;c&gt;&gt;w;</span><br><span class="line">		<span class="built_in">add_edge</span>(u,v,c,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">		<span class="type">int</span> minf=min_flow[t];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=t;i!=s;i=e[pre[i]^<span class="number">1</span>].to)&#123;</span><br><span class="line">			e[pre[i]].c-=minf;</span><br><span class="line">			e[pre[i]^<span class="number">1</span>].c+=minf;</span><br><span class="line">		&#125;</span><br><span class="line">		flow+=minf;</span><br><span class="line">		cost+=minf*dis[t];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;flow&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;cost;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 网络流建模 <a
href="https://www.luogu.com.cn/problem/P3356" title="例题">例题</a></p>
<p>考虑拆点。将点 <span class="math inline">\((x,y)\)</span> 拆为 <span
class="math inline">\((x,y)_1\)</span> 和 <span
class="math inline">\((x,y)_2\)</span>。 对于 <span
class="math inline">\(0\)</span>（平坦无障碍），建 <span
class="math inline">\((x,y)_1\to(x,y)_2\)</span>，容量 <span
class="math inline">\(inf\)</span>，费用 <span
class="math inline">\(0\)</span>，表示可以无限通过但无收益。同时，建
<span class="math inline">\((x,y)_2\to(x+1,y)_1\)</span> 和 <span
class="math inline">\((x,y)_2\to(x,y+1)_1\)</span>，容量与费用同上，表示向南和向东走。
对于 <span class="math inline">\(1\)</span>（障碍），不建立节点。 对于
<span class="math inline">\(2\)</span>（石块），先建 <span
class="math inline">\(0\)</span>（平坦无障碍）的 <span
class="math inline">\(3\)</span> 条边，然后再建一条 <span
class="math inline">\((x,y)_1\to(x,y)_2\)</span>，容量 <span
class="math inline">\(1\)</span>，费用 <span
class="math inline">\(1\)</span>，表示只能走 <span
class="math inline">\(1\)</span> 次且贡献为 <span
class="math inline">\(1\)</span>。 然后跑最大费用最大流就可以了。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2e9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">35</span>*<span class="number">35</span>*<span class="number">2</span><span class="number">+10</span>,M=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> p,q,nodecnt,node[N][N],tot=<span class="number">1</span>,head[N],n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt,c,w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> c,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	e[++tot].to=v;</span><br><span class="line">	e[tot].nxt=head[u];</span><br><span class="line">	e[tot].c=c;</span><br><span class="line">	e[tot].w=w;</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> c,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="built_in">add_edge1</span>(u,v,c,w);</span><br><span class="line">	<span class="built_in">add_edge1</span>(v,u,<span class="number">0</span>,-w);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pre[N],dis[N],s,t,flow[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(flow,<span class="number">0</span>,<span class="built_in">sizeof</span>(flow));</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	vis[s]=<span class="number">1</span>;</span><br><span class="line">	flow[s]=inf;</span><br><span class="line">	que.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		vis[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,c=e[i].c,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(c&amp;&amp;dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">				dis[v]=dis[u]+w;</span><br><span class="line">				pre[v]=i;</span><br><span class="line">				flow[v]=<span class="built_in">min</span>(flow[u],c);</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					vis[v]=<span class="number">1</span>;</span><br><span class="line">					que.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow[t]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;p&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=p;j++)</span><br><span class="line">			node[i][j]=++nodecnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,c;i&lt;=q;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=p;j++)&#123;</span><br><span class="line">			cin&gt;&gt;c;</span><br><span class="line">			<span class="keyword">if</span>(c==<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">add_edge</span>(node[i][j],node[i][j]+nodecnt,inf,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(c==<span class="number">2</span>)</span><br><span class="line">				<span class="built_in">add_edge</span>(node[i][j],node[i][j]+nodecnt,<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span>(i&lt;q)</span><br><span class="line">				<span class="built_in">add_edge</span>(node[i][j]+nodecnt,node[i<span class="number">+1</span>][j],inf,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(j&lt;p)</span><br><span class="line">				<span class="built_in">add_edge</span>(node[i][j]+nodecnt,node[i][j<span class="number">+1</span>],inf,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s=<span class="number">0</span>,t=nodecnt*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">	<span class="built_in">add_edge</span>(s,node[<span class="number">1</span>][<span class="number">1</span>],n,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">add_edge</span>(node[q][p]+nodecnt,t,n,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">		<span class="type">int</span> minf=flow[t];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=t,cnt=<span class="number">0</span>;i!=s;i=e[pre[i]^<span class="number">1</span>].to,cnt++)&#123;</span><br><span class="line">			e[pre[i]].c-=minf;</span><br><span class="line">			e[pre[i]^<span class="number">1</span>].c+=minf;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=p;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=head[node[i][j]];k;k=e[k].nxt)&#123;</span><br><span class="line">				<span class="type">int</span> v=e[k].to;</span><br><span class="line">				<span class="keyword">if</span>(v==node[i][j]+nodecnt)</span><br><span class="line">					cnt[i][j]+=e[k^<span class="number">1</span>].c;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="number">1</span>,y=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(x!=q||y!=p)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cnt[x<span class="number">+1</span>][y])&#123;</span><br><span class="line">				cout&lt;&lt;i&lt;&lt;<span class="string">&quot; 0\n&quot;</span>;</span><br><span class="line">				cnt[x<span class="number">+1</span>][y]--;</span><br><span class="line">				x++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				cout&lt;&lt;i&lt;&lt;<span class="string">&quot; 1\n&quot;</span>;</span><br><span class="line">				cnt[x][y<span class="number">+1</span>]--;</span><br><span class="line">				y++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 其他 参考资料：</p>
<p><a href="https://oi-wiki.org/graph/flow/max-flow/" title="OI Wiki">OI
Wiki</a></p>
<p><a href="https://www.luogu.com.cn/article/ei4nw9cm"
title="题解 P3376 【【模板】网络最大流】">题解 P3376
【【模板】网络最大流】</a></p>
<p><a href="https://www.luogu.com.cn/article/k6hmo167"
title="【题解】P3356 火星探险问题">【题解】P3356 火星探险问题</a></p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>自我介绍</title>
    <url>/2025/07/04/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>HE 高二 OIer。没实力还爱狗叫。贺题解高手。文化课菜逼。
<strong>我真不是二次元！</strong></p>
<hr />
<p>Welcome to my blog!<br />
欢迎大家阅读文章，如文章有错误之处请联系我进行修正。</p>
]]></content>
  </entry>
  <entry>
    <title>近期安排</title>
    <url>/2025/07/21/%E8%BF%91%E6%9C%9F%E5%AE%89%E6%8E%92/</url>
    <content><![CDATA[<p>暑假集训的题看着写吧……其实可做的已经写的差不多了。<br />
决定折腾折腾博客，删一些之前的劣质文章。</p>
]]></content>
  </entry>
  <entry>
    <title>郑州集训游记</title>
    <url>/2025/08/20/%E9%83%91%E5%B7%9E%E9%9B%86%E8%AE%AD%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>省流：赤石+打牌+打块。<br />
我的游记比较简略，更详细的信息可以看看 <a
href="https://www.cnblogs.com/yonghu10010/p/19028831">yonghu10010
的游记</a>和 <a
href="https://www.cnblogs.com/Tighnari/p/19025852">Tighnari
的游记</a>，当然还有不那么详细（？）的 <a
href="https://www.cnblogs.com/Tmbcan/articles/19031005">Tmbcan
的游记</a>。</p>
<hr />
<h1 id="day0">Day0</h1>
<p>放假归来，直接火车站重逢了。热热热。<br />
火车上在 bow 右后方，吓人。一路 MC+听歌。热热热。<br />
到地方了。叫做钱学森实验学校，没听说过，看起来比 S2 破。实际上比 S2 破
tm 太多了。<br />
到了以后去宿舍，和 dhx，whk 和 bry 一个宿舍。<br />
宿舍厕所没门浴室有门，倒反天罡。<br />
去机房，真凉快！电脑懒得评了，自己看：</p>
<ul>
<li><p>Intel(R) Core(TM) i5-8500 CPU @ 3.00GHz 3.00 GHz；</p></li>
<li><p>4.00 GB 内存；</p></li>
<li><p>还原卡全盘保护。</p></li>
</ul>
<p>晚上吃饭，饭真难吃。热热热。<br />
回宿舍猛猛打牌。<br />
晚上聊到 12 点。<br />
<a
href="https://www.cnblogs.com/Tmbcan/articles/19029159">来了以后我的心情。</a></p>
<h1 id="day1">Day1</h1>
<p><del>开着 0℃ 的空调差点把自己冻死。</del><br />
NOIP 模拟赛爆了。80 pts rk49，我是不是要退役了？？？<br />
下午是板子大赛，讲了一车板子。这真的是提高组不是普及组？<br />
听讲课，第一次觉得有人讲的不如 Dr_Gilbert。<br />
狠狠打牌+打块。</p>
<h1 id="day2">Day2</h1>
<p>上午下超级大暴雨<del>这就是郑州大旱</del>，直接被困机房无法吃午饭，最后打伞直接狂冲。这破学校好像一点排水系统都没有，所有路全被
tm 淹了，最后回到宿舍脱下袜子拧出一地水。<br />
之后几天只能穿拖鞋去机房了。<br />
大战狗屎线段树题 1.5h+，写完后尝试过 Hack 一直 TLE #9 直接红温破防，和
dhx 爆调 1h+ 后发现数据有问题询问区间有 <span
class="math inline">\(l&gt;r\)</span> 直接原地爆炸。<br />
狠狠打牌+打块。</p>
<h1 id="day3">Day3</h1>
<p>NOIP 模拟赛 2。T1 写出来后本地老爷机大样例 2s 直接红温狂暴卡常后 1.5s
燃尽了。T2 看着简单越想越不可做直接打暴力走人。出分后发现 T1T2
都过了？T1 拜谢核桃 OJ 少爷机，T2 是调和级数所以 <span
class="math inline">\(O(nq\log n)\)</span> 直接变成 <span
class="math inline">\(O(q\log^2n)\)</span> 过了。原本 220 pts
rk13，赛后暗度陈仓的绑包重测直接创飞一车人，最终 200 pts rk7，T3T4
的暴力和乱搞全挂了。<br />
下午是线段树，晚上是离线算法。讲的还可以。<br />
狠狠打牌+打块。</p>
<h1 id="day4">Day4</h1>
<p>来了之后电脑直接开摆。本着“重启解决 <span
class="math inline">\(90\%\)</span> 的问题，重装系统解决 <span
class="math inline">\(99\%\)</span> 的问题”的原则重启 <span
class="math inline">\(\inf\)</span>
次，然后重启后电脑依旧开摆。然后直接重装系统，这次直接成功了，喜提无还原卡电脑一台。但是
QQ 登不上了，直接爆炸。<br />
听讲课，这个课件的字太 tm
小了，在第一排都不容易看清，在后面根本看不清。讲课我越听越困。<br />
晚上大战李超线段树板子
1h+，最后发现模数写错了。虚空调试技术稳步增长哈。<br />
狠狠打牌+打块。</p>
<h1 id="day5">Day5</h1>
<p>上午讲课，期间与 <em>Kenma</em> 和 hzq 讨论问题：树上可加叶子求
lca。赞扬了倍增的强大后我提了一个魔怔做法：树剖+定期重构。后来 hzq
强化了一手，得到了树上路径修+路径求和+添加叶子的在线单次 <span
class="math inline">\(O(\log^2n+\sqrt n)\)</span> 做法。<a
href="https://www.luogu.com.cn/problem/U595295">题目链接。</a><a
href="https://www.luogu.com.cn/paste/ccjfzihh">std 链接。</a><br />
讲课的讲一半组合计数去讲多项式了感觉全场只有 lyh 大爷在听你真无敌了 NOIP
又不 tm
考多项式我也不想知道你多项式跑的有多快我真红了浪费了一上午光阴听一车死难的题还有一堆原还有狗屎多项式我组合计数就是这种勾巴？？？(第一次被逼的写长难句)<br />
下午一来咋临时加了个模拟赛？T1 题意就是勾巴，改来改去的直接不看了，T2
看着像数位 DP 不想做，T3
一眼树上莫队，直接写+调了一整场样例都没过直接进化究极红温态。T4
没看。最后只交了 T3 暴力 75 pts。<br />
狠狠打块+打牌。</p>
<h1 id="day6">Day6</h1>
<p>NOIP 模拟赛 4，这次每道题直接给了 8 个样例，爽，不对咋都是小样例？T1
一看像是简单题，结果疯狂换写法，从 <code>set</code> 到
<code>__gnu_pbds::tree</code> 再到
<code>vector</code>，最后写了个丑陋的双指针状物勉强过了所有的样例。不管了。T2
是啥啊？<span class="math inline">\(O(n^3)\)</span>
能过所有样例你真是无敌了给这么多样例就是为了告诉我暴力没写挂是吧？T3
好像得想神秘性质我不会啊直接 <span class="math inline">\(O(nms)\)</span>
背包走人。T4 不会，直接爆搜居然所有样例都过了。最后出成绩 245 pts
rk8，T1 过了，T4 过了？数据水？赛后重测 215 pts rk11，T4
被叉飞了。<br />
狠狠打块+打牌。</p>
<h1 id="day7">Day7</h1>
<p>放假日。上午去河南博物馆玩，排队的人排了一条街。逛了一上午累死了。中午在外面吃烩面，感觉和我在石家庄吃的味道一样啊？来这里这么几天只有一个感觉：我还在石家庄。这个街景随便拍一张都和石家庄一模一样啊。打
UNO，真好玩。下午在宿舍和机房疯狂开颓，晚上给出的题造数据，跪谢 <a
href="https://www.cnblogs.com/Kenma"><span class="citation"
data-cites="_Kenma_">@_Kenma_</span></a> 的帮助。<br />
狠狠打块+打牌。</p>
<h1 id="day8">Day8</h1>
<p>NOIP 模拟赛 5。<br />
你咋一道都不会？你咋一道都不会？你咋一道都不会？最后 130
pts，但是忘了提交直接保单。<br />
出的题被 LCT 草飞了。lyh 大爷使用 zkw
线段树硬草最优解，畏惧了，这咋成手法大战了。<br />
狠狠打块+打牌。</p>
<h1 id="day9">Day9</h1>
<p>讲数论，之前都学过，摆了。<br />
狠狠打牌+打块。</p>
<h1 id="day10">Day10</h1>
<p>NOIP 模拟赛 6 先开 T1，这个形式看着就很双指针啊，为啥 dhx 和 hzq
在我旁边都在疯狂弄 trie
啊？写一半发现似乎要维护最大值不管了直接线段树启动。写完调一调过样例了，但是怎么总感觉假呢？开
T2，发现原括号序列最终会被删成一串 <code>(</code> 或者是一串
<code>)</code> 接一串 <code>(</code>，容易发现 <code>(</code>
情况无法得到合法序列，而 <code>)</code> 接 <code>(</code> 若
<code>(</code> 部分为空则只需找配对删除后 <code>(</code> 数为原
<code>)</code> 数的因数即可，反之也无解。md T2 样例就是勾巴 4
个样例删完全是 tm 右括号你咋不去吃屎你是变态吗那么喜欢看别人挂分？？？T3
开了以后发现有点不可做。<em>Kenma</em>：这是小奥。那坏了，这对高中生来说过于困难了。T4
不可做题，摆了。<br />
最终 200 pts，T4 暴力挂了。<br />
额啊学会了根号分治求独立集了，确实很巧妙。<br />
狠狠打块+打牌。</p>
<h1 id="day11">Day11</h1>
<p>dottle 的方法论确实强势啊。简单且有用。<br />
狠狠打块+打牌。</p>
<h1 id="day12">Day12</h1>
<p>DP 真是我爹。<br />
晚饭是 L 请的，吃饭的地方环境很好。<br />
狠狠打块+打牌。</p>
<h1 id="day13">Day13</h1>
<p>上午 dottle 讲了一些很深刻的 OI 现状和学习方法。<br />
下午直接走了，大巴车开的真晃，差评。<br />
等火车的时候打 UNO。<br />
火车上摆了一路。<br />
终于到家了！<del>不对啊耳机咋丢了。</del><br />
还是打牌+打块。<br />
看见接下来几天的日程表心已经凉一半了。</p>
<hr />
<p>End.</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度整数类 v1.5</title>
    <url>/2025/06/23/%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%95%B4%E6%95%B0%E7%B1%BB%20v1.5/</url>
    <content><![CDATA[<h3 id="背景">背景</h3>
<p>我们痛恨高精度。</p>
<h3 id="介绍">介绍</h3>
<p>不想写高精度怎么办？提前写好模板，要用时直接复制粘贴就好啦！以下是一个高精度类，实现了除除法、取模和位运算外的所有整形运算。（先咕着这些，以后会添加的）。</p>
<details>
<summary>
bigint
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bigint</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BIGINT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIGINT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE 10000ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> PI2=<span class="number">6.283185307179586231995927</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">complex</span>&#123;</span><br><span class="line">    <span class="type">double</span> real,imag;</span><br><span class="line">    <span class="built_in">complex</span>(<span class="type">double</span> real=<span class="number">0</span>,<span class="type">double</span> imag=<span class="number">0</span>):<span class="built_in">real</span>(real),<span class="built_in">imag</span>(imag)&#123;&#125;</span><br><span class="line">    complex <span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">complex</span>(real+x.real,imag+x.imag);&#125;</span><br><span class="line">    complex <span class="keyword">operator</span>-(<span class="type">const</span> complex &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">complex</span>(real-x.real,imag-x.imag);&#125;</span><br><span class="line">    complex <span class="keyword">operator</span>*(<span class="type">const</span> complex &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">complex</span>(real*x.real-imag*x.imag,real*x.imag+x.real*imag);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">complex omega[(<span class="number">1</span>&lt;&lt;<span class="number">21</span>)<span class="number">+10</span>];</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> Size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bigint</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_omega</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(i&gt;&gt;<span class="number">1</span>);j++)&#123;</span><br><span class="line">                <span class="type">double</span> arg=PI2*j/i;</span><br><span class="line">                omega[(i&gt;&gt;<span class="number">1</span>)+j]=<span class="built_in">complex</span>(<span class="built_in">cos</span>(arg),<span class="built_in">sin</span>(arg));</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FFT</span><span class="params">(std::vector&lt;complex&gt; &amp;a,<span class="type">int</span> n,<span class="type">bool</span> inv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j) std::<span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=n&gt;&gt;<span class="number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(len&gt;&gt;<span class="number">1</span>);j++)&#123;</span><br><span class="line">                    complex w=inv?<span class="built_in">complex</span>(omega[(len&gt;&gt;<span class="number">1</span>)+j].real,-omega[(len&gt;&gt;<span class="number">1</span>)+j].imag):omega[(len&gt;&gt;<span class="number">1</span>)+j];</span><br><span class="line">                    complex x=a[i+j],y=a[i+j+(len&gt;&gt;<span class="number">1</span>)]*w;</span><br><span class="line">                    a[i+j]=x+y,a[i+j+(len&gt;&gt;<span class="number">1</span>)]=x-y;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span>(inv) <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i].real/=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num[Size];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(len<span class="number">+2</span>));</span><br><span class="line">        len=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bigint</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">        len=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">bigint</span><span class="params">(<span class="type">const</span> T &amp;x)</span></span>&#123;*<span class="keyword">this</span>=x;&#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;out,<span class="type">const</span> bigint &amp;x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.num[<span class="number">0</span>]) out&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        out&lt;&lt;x.num[x.len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x.len<span class="number">-1</span>;i;i--)</span><br><span class="line">            out&lt;&lt;std::<span class="built_in">setw</span>(<span class="number">4</span>)&lt;&lt;std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>)&lt;&lt;x.num[i];</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;in,bigint &amp;x)&#123;</span><br><span class="line">        std::string s;</span><br><span class="line">        in&gt;&gt;s;x=s;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>=(<span class="type">const</span> T &amp;a)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        T x=a;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) num[<span class="number">0</span>]=<span class="number">1</span>,x=~x<span class="number">+1</span>;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            num[++len]=x%BASE;</span><br><span class="line">            x/=BASE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>=(<span class="type">const</span> std::string &amp;a);</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> bigint &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>]!=a.num[<span class="number">0</span>]) <span class="keyword">return</span> num[<span class="number">0</span>]&gt;a.num[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> num[<span class="number">0</span>]?len&gt;a.len:len&lt;a.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len;i;i--)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=a.num[i])</span><br><span class="line">                <span class="keyword">return</span> num[<span class="number">0</span>]?num[i]&gt;a.num[i]:num[i]&lt;a.num[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> bigint &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>]!=a.num[<span class="number">0</span>]) <span class="keyword">return</span> num[<span class="number">0</span>]&lt;a.num[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> num[<span class="number">0</span>]?len&lt;a.len:len&gt;a.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len;i;i--)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=a.num[i])</span><br><span class="line">                <span class="keyword">return</span> num[<span class="number">0</span>]?num[i]&lt;a.num[i]:num[i]&gt;a.num[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> bigint &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>]!=a.num[<span class="number">0</span>]) <span class="keyword">return</span> num[<span class="number">0</span>]&gt;a.num[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> num[<span class="number">0</span>]?len&gt;a.len:len&lt;a.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len;i;i--)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=a.num[i])</span><br><span class="line">                <span class="keyword">return</span> num[<span class="number">0</span>]?num[i]&gt;a.num[i]:num[i]&lt;a.num[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> bigint &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>]!=a.num[<span class="number">0</span>]) <span class="keyword">return</span> num[<span class="number">0</span>]&lt;a.num[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> num[<span class="number">0</span>]?len&lt;a.len:len&gt;a.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len;i;i--)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=a.num[i])</span><br><span class="line">                <span class="keyword">return</span> num[<span class="number">0</span>]?num[i]&lt;a.num[i]:num[i]&gt;a.num[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> bigint &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=a.num[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> bigint &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=a.num[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> bigint &amp;a)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>]==a.num[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> temp=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> old_len=len;</span><br><span class="line">            len=std::<span class="built_in">max</span>(len,a.len);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> sum=temp;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=old_len) sum+=num[i];</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=a.len) sum+=a.num[i];</span><br><span class="line">                num[i]=(<span class="type">int</span>)(sum%BASE);</span><br><span class="line">                temp=sum/BASE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp)</span><br><span class="line">                num[++len]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">bool</span> this_large=<span class="keyword">this</span>-&gt;<span class="built_in">abs</span>()&gt;=a.<span class="built_in">abs</span>();</span><br><span class="line">            <span class="type">const</span> bigint &amp;larger=this_large?*<span class="keyword">this</span>:a;</span><br><span class="line">            <span class="type">const</span> bigint &amp;smaller=this_large?a:*<span class="keyword">this</span>;</span><br><span class="line">            <span class="type">int</span> new_len=larger.len;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> temp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=new_len;i++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> diff=(<span class="type">long</span> <span class="type">long</span>)larger.num[i]-temp;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=smaller.len) diff-=smaller.num[i];</span><br><span class="line">                <span class="keyword">if</span>(diff&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    diff+=BASE;</span><br><span class="line">                    temp=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> temp=<span class="number">0</span>;</span><br><span class="line">                num[i]=diff;</span><br><span class="line">            &#125;</span><br><span class="line">            len=new_len;</span><br><span class="line">            <span class="keyword">while</span>(len&gt;<span class="number">1</span>&amp;&amp;num[len]==<span class="number">0</span>) len--;</span><br><span class="line">            num[<span class="number">0</span>]=this_large?num[<span class="number">0</span>]:a.num[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">1</span>&amp;&amp;num[<span class="number">1</span>]==<span class="number">0</span>) num[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> bigint &amp;a)&#123;</span><br><span class="line">        bigint temp=a;</span><br><span class="line">        temp.num[<span class="number">0</span>]^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> bigint &amp;a)&#123;</span><br><span class="line">        <span class="keyword">if</span>((len==<span class="number">1</span>&amp;&amp;num[<span class="number">1</span>]==<span class="number">0</span>)||(a.len==<span class="number">1</span>&amp;&amp;a.num[<span class="number">1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="built_in">init</span>();</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> old_len=len;</span><br><span class="line">        <span class="type">int</span> old_num[Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(old_num,num,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(len<span class="number">+10</span>));</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        num[<span class="number">0</span>]=old_num[<span class="number">0</span>]^a.num[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> len_sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len_sum&lt;old_len+a.len)</span><br><span class="line">            len_sum&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="function">std::vector&lt;complex&gt; <span class="title">fa</span><span class="params">(len_sum<span class="number">+10</span>)</span>,<span class="title">fb</span><span class="params">(len_sum<span class="number">+10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;old_len;i++)</span><br><span class="line">            fa[i]=<span class="built_in">complex</span>((<span class="type">double</span>)old_num[i<span class="number">+1</span>],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)</span><br><span class="line">            fb[i]=<span class="built_in">complex</span>((<span class="type">double</span>)a.num[i<span class="number">+1</span>],<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">init_omega</span>(len_sum);</span><br><span class="line">        <span class="built_in">FFT</span>(fa,len_sum,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">FFT</span>(fb,len_sum,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len_sum;i++)</span><br><span class="line">            fa[i]=fa[i]*fb[i];</span><br><span class="line">        <span class="built_in">FFT</span>(fa,len_sum,<span class="literal">true</span>);</span><br><span class="line">        len=old_len+a.len;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> val=(<span class="type">long</span> <span class="type">long</span>)<span class="built_in">round</span>(fa[i].real)+temp;</span><br><span class="line">            num[i<span class="number">+1</span>]=(<span class="type">int</span>)(val%BASE);</span><br><span class="line">            temp=val/BASE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp) num[++len]=temp;</span><br><span class="line">        <span class="keyword">while</span>(len&gt;<span class="number">1</span>&amp;&amp;num[len]==<span class="number">0</span>) len--;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>++()&#123;</span><br><span class="line">        *<span class="keyword">this</span>+=<span class="built_in">bigint</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>--()&#123;</span><br><span class="line">        *<span class="keyword">this</span>-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    bigint <span class="keyword">operator</span>++(T)&#123;</span><br><span class="line">        bigint res=*<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    bigint <span class="keyword">operator</span>--(T)&#123;</span><br><span class="line">        bigint res=*<span class="keyword">this</span>;</span><br><span class="line">        --*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> bigint <span class="keyword">operator</span>+(<span class="type">const</span> bigint &amp;a,<span class="type">const</span> bigint &amp;b)&#123;<span class="keyword">return</span> <span class="built_in">bigint</span>(a)+=b;&#125;</span><br><span class="line">    <span class="keyword">friend</span> bigint <span class="keyword">operator</span>-(<span class="type">const</span> bigint &amp;a,<span class="type">const</span> bigint &amp;b)&#123;<span class="keyword">return</span> <span class="built_in">bigint</span>(a)-=b;&#125;</span><br><span class="line">    <span class="keyword">friend</span> bigint <span class="keyword">operator</span>*(<span class="type">const</span> bigint &amp;a,<span class="type">const</span> bigint &amp;b)&#123;<span class="keyword">return</span> <span class="built_in">bigint</span>(a)*=b;&#125;</span><br><span class="line">    <span class="function">bigint <span class="title">abs</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        bigint res=*<span class="keyword">this</span>;</span><br><span class="line">        res.num[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> Size&gt;</span><br><span class="line">bigint&lt;Size&gt; &amp;bigint&lt;Size&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> std::string &amp;a)&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> slen=a.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span>(slen&gt;<span class="number">0</span>&amp;&amp;a[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>) num[<span class="number">0</span>]=f=<span class="number">1</span>;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=slen<span class="number">-1</span>;i&gt;=f;i--)&#123;</span><br><span class="line">        temp+=(a[i]^<span class="number">48</span>)*w;</span><br><span class="line">        w=(w&lt;&lt;<span class="number">1</span>)+(w&lt;&lt;<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(w==BASE||i==f)&#123;</span><br><span class="line">            num[++len]=(<span class="type">int</span>)temp;</span><br><span class="line">            temp=<span class="number">0</span>;</span><br><span class="line">            w=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp||len==<span class="number">0</span>) num[++len]=temp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> BASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</details>
<h3 id="使用说明">使用说明</h3>
<h4 id="前言">前言</h4>
<p>这份高精度模板使用压位实现常数优化，实现过程中为了保证乘法运算的精度，最终选择了压
<span class="math inline">\(4\)</span> 位，可以保证 <span
class="math inline">\(10^{1000000}\)</span> 以内的精度。</p>
<h4 id="声明">声明</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bigint&lt;/*length_of_number*/&gt; a;</span><br><span class="line"><span class="comment">//因为压位，所以可以只开四分之一大小，但一般建议开大些</span></span><br></pre></td></tr></table></figure>
<p>无需任何命名空间。</p>
<h4 id="io-方式">I/O 方式</h4>
<p>为方便使用，接入了 <code>iostream</code> 的 I/O。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bigint&lt;<span class="number">114514</span>&gt; a;</span><br><span class="line">std::cin&gt;&gt;a;</span><br><span class="line">std::cout&lt;&lt;a;</span><br></pre></td></tr></table></figure></p>
<h4 id="数值运算符">数值运算符</h4>
<p>加法与减法使用 <span class="math inline">\(O(n)\)</span>
算法，乘法使用 <span class="math inline">\(O(n\log n)\)</span>
算法（FFT），也写了一份 NTT 实现，实测表现优于
FFT，但暂无法处理较大的数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bigint&lt;<span class="number">114514</span>&gt; a,b;</span><br><span class="line">a+b;</span><br><span class="line">a-b;</span><br><span class="line">a*b;</span><br><span class="line">a+=b;</span><br><span class="line">a-=b;</span><br><span class="line">a*=b;</span><br><span class="line">a++;</span><br><span class="line">a--;</span><br><span class="line">++a;</span><br><span class="line">--a;</span><br></pre></td></tr></table></figure></p>
<h4 id="赋值运算符">赋值运算符</h4>
<p>支持所有<strong>整形</strong>，同时对 <code>std::string</code>
进行特化，支持将一个<strong>格式符合正常数字</strong>的
<code>std::string</code> 转为高精度整形。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bigint&lt;<span class="number">114514</span>&gt; a,b;</span><br><span class="line">std::string c;</span><br><span class="line">c=<span class="string">&quot;-1919810&quot;</span>;</span><br><span class="line">a=<span class="number">-1919810</span>,b=c;</span><br><span class="line"><span class="comment">//a和b所存的值均为-1919810</span></span><br></pre></td></tr></table></figure></p>
<h4 id="关系符">关系符</h4>
<p>除三路比较运算符（C++20）外的所有常用大小关系符。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bigint&lt;<span class="number">114514</span>&gt; a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line">a&lt;b;<span class="comment">//此表达式为true</span></span><br><span class="line">a!=b;<span class="comment">//此表达式为true</span></span><br><span class="line">a==b;<span class="comment">//此表达式为false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="其他">其他</h4>
<p>成员函数 <code>abs()</code>，以 <code>bigint</code>
类型返回该数的绝对值。</p>
<h3 id="关于-fftntt-与压位对于高精度乘法的性能优化比对数据">关于 FFT/NTT
与压位对于高精度乘法的性能优化比对数据</h3>
<p><a href="https://github.com/headless-piston/bigint/tree/test_data"
title="data">data</a>（洛谷 P1919 #1 数据） code <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">bigint&lt;<span class="number">2145141</span>&gt; a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;1.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    cout&lt;&lt;a*b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 数据取
<span class="math inline">\(5\)</span> 次运行平均值。<br />
评测环境：S2 四机房（Intel(R) Core(TM) i5-10400 CPU @ 2.90GHz 2.90
GHz）。MinGW-W64 GCC 11.4.0 64-bit Debug。 编译选项： <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-std=c++14 -O2 -Wl,--stack=268435456</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">FFT</th>
<th style="text-align: center;">NTT</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">不压位</td>
<td style="text-align: center;">0.5712</td>
<td style="text-align: center;">0.5112</td>
</tr>
<tr>
<td style="text-align: center;">压 <span
class="math inline">\(2\)</span> 位</td>
<td style="text-align: center;">0.2718</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">压 <span
class="math inline">\(4\)</span> 位</td>
<td style="text-align: center;">0.1546</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<p>单位：<span class="math inline">\(\operatorname{s}\)</span>。<br />
数据来自 RedPandaIDE
程序运行窗口自带的用时显示，真实评测时用时应会比表中数据略小。<br />
单模数（<span class="math inline">\(p=998244353\)</span>） NTT 压 <span
class="math inline">\(2\)</span> 位/<span
class="math inline">\(4\)</span> 位在数据范围内无法得到正确答案。</p>
<h3 id="upd">Upd</h3>
<p>v1.1：增加了 NTT 命名空间，但因为一些原因暂不使用。<br />
v1.2：改了改码风。<br />
v1.3：使用 C++ 标准库中的 <code>std::complex</code>
代替手写的复数类。修复了初始化错误的问题。<br />
v1.4：<code>std::complex</code> 跑的太慢啦，换回手写的复数类。<br />
v1.5：改用预处理单位根计算，提高了精度。现在可以压 <span
class="math inline">\(4\)</span> 位啦，效率大提升！</p>
]]></content>
  </entry>
</search>
