<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AC 自动机</title>
    <url>/2025/06/23/AC%20%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>最近集训时将难一些的字符串题时发现自己似乎已经忘了，或者就根本没学懂过
AC 自动机，于是重学一遍。 ——2025.6.11 ### 功能 AC 自动机可以实现比 KMP
和 Trie
更多的字符串匹配方面的功能。比如求模式串是否在文本串中出现过，出现了多少次等。不同于
KMP，AC 自动机支持<strong>多模式串的匹配</strong>。可以认为，AC
自动机就是在 Trie 上进行
KMP，同样要求最长公共前后缀，只不过前缀可以从<strong>任意模式串</strong>中截取而非
KMP 的单一模式串。类似于 KMP 的 <span class="math inline">\(nxt\)</span>
数组，AC 自动机中称这个指针为 <span
class="math inline">\(fail\)</span>。 我们举个例子：若干模式串组成 Trie
<img
src="https://raw.githubusercontent.com/headless-piston/blog_images/refs/heads/main/AC.png"
alt="image" /> 为了防止过多 <span class="math inline">\(fail\)</span>
弄得图片过乱，我们只取一个例子：<span class="math inline">\(9\)</span>
节点处，我们发现有 <span class="math inline">\(0\)</span> 节点到 <span
class="math inline">\(2\)</span> 节点和 <span
class="math inline">\(7\)</span> 节点到 <span
class="math inline">\(9\)</span> 节点的最长公共前后缀
<code>he</code>。所以，类似 KMP，<span class="math inline">\(9\)</span>
处的 <span class="math inline">\(fail\)</span> 应指向 <span
class="math inline">\(2\)</span>。 ### 建树 那么，<span
class="math inline">\(fail\)</span> 究竟应该如何构建呢？我们使用 BFS
来遍历 Trie，在失配时不断跳 <span
class="math inline">\(fail\)</span>。</p>
<details>
<summary>
build AC automaton
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(nxt[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nxt[u][i])&#123;</span><br><span class="line">                <span class="type">int</span> to=fail[u];</span><br><span class="line">                <span class="keyword">while</span>(to&amp;&amp;!nxt[to][i])</span><br><span class="line">                    to=fail[to];</span><br><span class="line">                fail[nxt[u][i]]=nxt[to][i];</span><br><span class="line">                q.<span class="built_in">push</span>(nxt[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>然而，这样一直跳 <span class="math inline">\(fail\)</span>
效率太低了。我们可以在一开始就预处理出不存在的边的 <span
class="math inline">\(fail\)</span>，将查找 <span
class="math inline">\(fail\)</span> 优化至 <span
class="math inline">\(O(1)\)</span>。此时的 Trie 由树变为了图。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(nxt[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nxt[u][i])&#123;</span><br><span class="line">                fail[nxt[u][i]]=nxt[fail[u]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(nxt[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> nxt[u][i]=nxt[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 多模式串匹配 我们以<a
href="https://www.luogu.com.cn/problem/P3808"
title="本题">本题</a>的匹配为例，只需每次跳 <span
class="math inline">\(fail\)</span> 并计数，打标记防止记重就好了。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        u=nxt[u][c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=u;j&amp;&amp;ed[j]!=<span class="number">-1</span>;j=fail[j])</span><br><span class="line">            res+=ed[j],ed[j]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 效率优化 我们发现，匹配时一直在跳 <span
class="math inline">\(fail\)</span>，这个操作事实上是可以优化的。
显然，一个 AC 自动机上的 <span class="math inline">\(fail\)</span>
边应当会构成一棵内向树。因此可以进行拓扑排序优化。
按照拓扑序处理节点，累加出现次数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">26</span>],tot,fail[N],n,ed[N],ans[N],indegree[N],mp[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(string s,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[u][c]) nxt[u][c]=++tot;</span><br><span class="line">        u=nxt[u][c];</span><br><span class="line">    &#125;</span><br><span class="line">    ++ed[u];</span><br><span class="line">    mp[id]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(nxt[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nxt[u][i])&#123;</span><br><span class="line">                fail[nxt[u][i]]=nxt[fail[u]][i];</span><br><span class="line">                ++indegree[nxt[fail[u]][i]];</span><br><span class="line">                q.<span class="built_in">push</span>(nxt[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> nxt[u][i]=nxt[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++) <span class="keyword">if</span>(!indegree[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> v=fail[u];</span><br><span class="line">        ans[v]+=ans[u];</span><br><span class="line">        <span class="keyword">if</span>(!--indegree[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">query</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        u=nxt[u][c];</span><br><span class="line">        ans[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">string s,t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;s,<span class="built_in">insert</span>(s,i);</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">query</span>(t);</span><br><span class="line">    <span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;ans[mp[i]]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="习题">习题</h3>
<h4 id="poi-2000-病毒"><a href="https://www.luogu.com.cn/problem/P2444"
title="[POI 2000] 病毒">[POI 2000] 病毒</a></h4>
<p>建立 AC
自动机时判断，若某串的最长前缀是病毒，则它本身一定不合法。之后 dfs
判环就行，注意使用标记数组保证 dfs
的复杂度正确。<del>代码有点丑陋，为了卡常写了循环展开。</del></p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">3e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">2</span>],tot,n,fail[N];</span><br><span class="line"><span class="type">bool</span> ed[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[p][c^<span class="number">48</span>]) nxt[p][c^<span class="number">48</span>]=++tot;</span><br><span class="line">        p=nxt[p][c^<span class="number">48</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[p]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">if</span>(nxt[<span class="number">0</span>][<span class="number">0</span>]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(nxt[<span class="number">0</span>][<span class="number">1</span>]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(nxt[u][<span class="number">0</span>])&#123;</span><br><span class="line">            fail[nxt[u][<span class="number">0</span>]]=nxt[fail[u]][<span class="number">0</span>];</span><br><span class="line">            q.<span class="built_in">push</span>(nxt[u][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> nxt[u][<span class="number">0</span>]=nxt[fail[u]][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(ed[fail[nxt[u][<span class="number">0</span>]]]) ed[nxt[u][<span class="number">0</span>]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nxt[u][<span class="number">1</span>])&#123;</span><br><span class="line">            fail[nxt[u][<span class="number">1</span>]]=nxt[fail[u]][<span class="number">1</span>];</span><br><span class="line">            q.<span class="built_in">push</span>(nxt[u][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> nxt[u][<span class="number">1</span>]=nxt[fail[u]][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(ed[fail[nxt[u][<span class="number">1</span>]]]) ed[nxt[u][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[N],used[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[nxt[u][<span class="number">0</span>]]||vis[nxt[u][<span class="number">1</span>]])&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TAK\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p=nxt[u][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(!used[p]&amp;&amp;!ed[p]) used[p]=<span class="number">1</span>,<span class="built_in">dfs</span>(p);</span><br><span class="line">    p=nxt[u][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(!used[p]&amp;&amp;!ed[p]) used[p]=<span class="number">1</span>,<span class="built_in">dfs</span>(p);</span><br><span class="line">    vis[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;NIE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h4 id="noi2011-阿狸的打字机"><a
href="https://www.luogu.com.cn/problem/P2414"
title="[NOI2011] 阿狸的打字机">[NOI2011] 阿狸的打字机</a></h4>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,tot,nxt[N][<span class="number">26</span>],fail[N],fa[N],endpos[N],nxt1[N][<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(nxt[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nxt[u][i])&#123;</span><br><span class="line">                fail[nxt[u][i]]=nxt[fail[u]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(nxt[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> nxt[u][i]=nxt[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,id;</span><br><span class="line">    <span class="built_in">query</span>(<span class="type">int</span> x=<span class="number">0</span>,<span class="type">int</span> id=<span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">id</span>(id)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;query&gt; q[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dfnl[N],dfnr[N],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfsfail</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dfnl[u]=++dfncnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u]) <span class="built_in">dfsfail</span>(v);</span><br><span class="line">    dfnr[u]=dfncnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=dfncnt;x+=<span class="built_in">lowbit</span>(x)) tree[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x^=<span class="built_in">lowbit</span>(x)) res+=tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfstrie</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">modify</span>(dfnl[u],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> temp:q[u])&#123;</span><br><span class="line">        <span class="type">int</span> id=temp.id,x=temp.x;</span><br><span class="line">        ans[id]=<span class="built_in">ask</span>(dfnr[x])-<span class="built_in">ask</span>(dfnl[x]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> v=nxt1[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfstrie</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">modify</span>(dfnl[u],<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!nxt[p][c-<span class="string">&#x27;a&#x27;</span>]) nxt[p][c-<span class="string">&#x27;a&#x27;</span>]=++tot;</span><br><span class="line">            fa[nxt[p][c-<span class="string">&#x27;a&#x27;</span>]]=p;</span><br><span class="line">            p=nxt[p][c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;P&#x27;</span>) endpos[++n]=p;</span><br><span class="line">        <span class="keyword">else</span> p=fa[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(nxt1,nxt,<span class="built_in">sizeof</span>(nxt));</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        q[endpos[y]].<span class="built_in">push_back</span>(<span class="built_in">query</span>(endpos[x],i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">        e[fail[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">dfsfail</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfstrie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>图片来源：</p>
<p>https://oi-wiki.org/string/ac-automaton/</p>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher</title>
    <url>/2025/07/05/Manacher/</url>
    <content><![CDATA[<p>今天讲的字符串哈希题觉得都很水啊，咋一听到 Manacher
题就懵逼了呢？重学一遍…… ### 简介 给定一个长度为 <span
class="math inline">\(n\)</span> 的字符串 <span
class="math inline">\(S\)</span>，找到所有回文子串。<br />
最坏情况下有 <span class="math inline">\(O(n^2)\)</span>
个回文串，为了做到线性，我们使用回文半径来表示回文。这样，我们要求的就转化为：对于每个位置
<span class="math inline">\(i\)</span>，求出最长回文半径。<br />
使用字符串哈希可以容易地在 <span class="math inline">\(O(n\log
n)\)</span> 时间内解决，但 Manacher 更为简洁和高效。<br />
### 实现过程 约定：<span class="math inline">\([l,r]\)</span> 表示下标在
<span class="math inline">\(l,r\)</span> 之间的子串。<br />
我们只考虑长度为奇数的回文串，可以通过在字符串每个字符间加入无关字符如
<code>#</code>
等来把长度为偶数的串转化为长度为奇数的串。接下来，我们维护 <span
class="math inline">\(p_i\)</span> 表示以 <span
class="math inline">\(i\)</span> 为重心的回文半径，<span
class="math inline">\(r\)</span>
为当前找到的覆盖位置最靠右的回文串能覆盖到的最大下标，<span
class="math inline">\(mid\)</span> 表示它的回文中心的下标。<br />
计算过程考虑分类讨论： - <span class="math inline">\(i&gt;r\)</span>
时，直接暴力一步步向后跳。 - <span class="math inline">\(i\le r\)</span>
时，设 <span class="math inline">\(j\)</span> 为 <span
class="math inline">\(i\)</span> 关于 <span
class="math inline">\(mid\)</span> 的对称点，即 <span
class="math inline">\(mid\times 2-i\)</span>。<br />
由于 <span class="math inline">\([j-p_j,j+p_j]\)</span> 与 <span
class="math inline">\([i-p_i,i+p_i]\)</span> 相等且都是回文串，所以
<span class="math inline">\(p_i\)</span> 可以直接取 <span
class="math inline">\(p_j\)</span> 的值。但这个推论成立当且仅当 <span
class="math inline">\(i+p_j\le r\)</span>，否则 <span
class="math inline">\(p_i\)</span> 只能取到 <span
class="math inline">\(r-i+1\)</span>，然后再暴力扩展。<br />
综上，<span class="math inline">\(p_i=\min(p_j,r-i+1)\)</span>。</p>
<p><span class="math inline">\(r\)</span> 只能向右移动，故最多移动 <span
class="math inline">\(O(n)\)</span> 次。其余情况的计算显然是 <span
class="math inline">\(O(1)\)</span> 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,r=<span class="number">0</span>,mid=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">2</span>*mid-i;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=r) p[i]=<span class="built_in">min</span>(r-i<span class="number">+1</span>,p[j]);</span><br><span class="line">    <span class="keyword">else</span> p[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i-p[i]]==s[i+p[i]]) ++p[i];</span><br><span class="line">    <span class="keyword">if</span>(i+p[i]<span class="number">-1</span>&gt;r)&#123;</span><br><span class="line">        r=i+p[i]<span class="number">-1</span>;</span><br><span class="line">        mid=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分引自 https://oi-wiki.org/string/manacher/</p>
<p>非常感谢<a
href="https://www.luogu.com.cn/article/2fmdma9m">这篇博客</a>，讲的很透彻，帮我彻底弄懂了
Manacher。 https://www.luogu.com.cn/article/2fmdma9m</p>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>DP 题目合集</title>
    <url>/2025/07/04/DP%20%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="osu">OSU!</h3>
<p>之前做过。 ### <a href="https://www.luogu.com.cn/problem/P9119"
title="[春季测试 2023] 圣诞树">[春季测试 2023] 圣诞树</a>
好题。因为三角形两边和大于第三边，所以路径不交叉一定比路径交叉优。那么考虑区间
DP。首先断环为链，设 <span class="math inline">\(dp_{l,r,0/1}\)</span>
表示当前已经走完了区间 <span
class="math inline">\([l,r]\)</span>，当前在区间最左/右侧。同时记录
<span class="math inline">\(pre_{l,r,0/1}\)</span> 表示对应状态的 <span
class="math inline">\(dp\)</span>
是从上一步的左/右侧转移过来的。输出直接递归或用栈就可以了。注意：由于坐标可以为负，所以一定注意边界条件。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;node[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">double</span> dp[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>][<span class="number">2</span>],ans;</span><br><span class="line"><span class="type">int</span> pre[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dis</span><span class="params">(<span class="type">const</span> Node &amp;a,<span class="type">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x=a.x-b.x,y=a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node[l].id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        <span class="built_in">print</span>(l,r<span class="number">-1</span>,pre[l][r][p]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node[r].id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(l<span class="number">+1</span>,r,pre[l][r][p]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node[l].id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    node[s].y=<span class="number">-0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;node[i].x&gt;&gt;node[i].y;</span><br><span class="line">        node[i].id=i;</span><br><span class="line">        node[i+n]=node[i];</span><br><span class="line">        <span class="keyword">if</span>(node[i].y&gt;node[s].y) s=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=(n&lt;&lt;<span class="number">1</span>);j++)</span><br><span class="line">            dp[i][j][<span class="number">0</span>]=dp[i][j][<span class="number">1</span>]=<span class="number">0x7fffffff</span>;</span><br><span class="line">    dp[s][s][<span class="number">0</span>]=dp[s][s][<span class="number">1</span>]=dp[s+n][s+n][<span class="number">0</span>]=dp[s+n][s+n][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=l+len<span class="number">-1</span>;r&lt;=(n&lt;&lt;<span class="number">1</span>);l++,r++)&#123;</span><br><span class="line">            <span class="comment">//0 left ,1 right</span></span><br><span class="line">            <span class="type">double</span> a=dp[l<span class="number">+1</span>][r][<span class="number">0</span>]+<span class="built_in">dis</span>(node[l],node[l<span class="number">+1</span>]),b=dp[l<span class="number">+1</span>][r][<span class="number">1</span>]+<span class="built_in">dis</span>(node[l],node[r]);</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b) dp[l][r][<span class="number">0</span>]=b,pre[l][r][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[l][r][<span class="number">0</span>]=a,pre[l][r][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            a=dp[l][r<span class="number">-1</span>][<span class="number">1</span>]+<span class="built_in">dis</span>(node[r<span class="number">-1</span>],node[r]),b=dp[l][r<span class="number">-1</span>][<span class="number">0</span>]+<span class="built_in">dis</span>(node[l],node[r]);</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b) dp[l][r][<span class="number">1</span>]=b,pre[l][r][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[l][r][<span class="number">1</span>]=a,pre[l][r][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ans=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">min</span>(&#123;ans,dp[i][i+n<span class="number">-1</span>][<span class="number">0</span>],dp[i][i+n<span class="number">-1</span>][<span class="number">1</span>]&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][i+n<span class="number">-1</span>][<span class="number">0</span>]==ans)&#123;</span><br><span class="line">            <span class="built_in">print</span>(i,i+n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][i+n<span class="number">-1</span>][<span class="number">1</span>]==ans)&#123;</span><br><span class="line">            <span class="built_in">print</span>(i,i+n<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="jsoi2018-潜入行动"><a
href="https://www.luogu.com.cn/problem/P4516"
title="[JSOI2018] 潜入行动">[JSOI2018] 潜入行动</a></h3>
<p>树上背包。朴素的状态不足以表达信息时就考虑加状态。<span
class="math inline">\(dp_{u,i,0/1,0/1}\)</span> 表示以 <span
class="math inline">\(u\)</span> 为根的子树中，放了 <span
class="math inline">\(i\)</span> 个监视器，点 <span
class="math inline">\(u\)</span> 放/不放，点 <span
class="math inline">\(u\)</span>
是/否被覆盖。转移时涉及滚动数组，所以我们记 <span
class="math inline">\(temp_{i,0/1,0/1}\)</span> 表示当前的 <span
class="math inline">\(dp_{u,i,0/1,0/1}\)</span>。 转移有点麻烦： <span
class="math display">\[dp_{u,i+j,0,0}=\sum temp_{i,0,0}\times
dp_{v,j,0,1}\]</span> <span class="math display">\[dp_{u,i+j,1,0}=\sum
temp_{i,1,0}\times dp_{v,j,0,0/1}\]</span> <span
class="math display">\[dp_{u,i+j,0,1}=\sum temp_{i,0,0}\times
dp_{v,j,1,1}+temp_{i,0,1}\times dp_{v,j,0/1,1}\]</span> <span
class="math display">\[dp_{u,i+j,1,1}=\sum temp_{i,1,0}\times
dp_{v,j,1,0/1}+temp_{i,1,1}\times dp_{v,j,0/1,0/1}\]</span></p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>,N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">modint</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">modint</span>(<span class="type">int</span> val=<span class="number">0</span>):<span class="built_in">val</span>(val)&#123;&#125;</span><br><span class="line">    modint <span class="keyword">operator</span>+(<span class="type">const</span> modint &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">modint</span>((val+x.val)%mod);&#125;</span><br><span class="line">    modint &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> modint &amp;x)&#123;val+=x.val;val%=mod;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    modint <span class="keyword">operator</span>*(<span class="type">const</span> modint &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">modint</span>((ll)val*x.val%mod);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> n,k,siz[N];</span><br><span class="line">modint dp[N][<span class="number">110</span>][<span class="number">2</span>][<span class="number">2</span>],temp[<span class="number">110</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    dp[u][<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=dp[u][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            temp[i][<span class="number">0</span>][<span class="number">0</span>]=dp[u][i][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            temp[i][<span class="number">0</span>][<span class="number">1</span>]=dp[u][i][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">            temp[i][<span class="number">1</span>][<span class="number">0</span>]=dp[u][i][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            temp[i][<span class="number">1</span>][<span class="number">1</span>]=dp[u][i][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[u][i][<span class="number">0</span>][<span class="number">0</span>]=dp[u][i][<span class="number">0</span>][<span class="number">1</span>]=dp[u][i][<span class="number">1</span>][<span class="number">0</span>]=dp[u][i][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">min</span>(siz[u],k);i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(siz[v],k-i);j++)&#123;</span><br><span class="line">                dp[u][i+j][<span class="number">0</span>][<span class="number">0</span>]+=temp[i][<span class="number">0</span>][<span class="number">0</span>]*dp[v][j][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">                dp[u][i+j][<span class="number">1</span>][<span class="number">0</span>]+=temp[i][<span class="number">1</span>][<span class="number">0</span>]*(dp[v][j][<span class="number">0</span>][<span class="number">0</span>]+dp[v][j][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[u][i+j][<span class="number">0</span>][<span class="number">1</span>]+=temp[i][<span class="number">0</span>][<span class="number">0</span>]*dp[v][j][<span class="number">1</span>][<span class="number">1</span>]+</span><br><span class="line">                temp[i][<span class="number">0</span>][<span class="number">1</span>]*(dp[v][j][<span class="number">0</span>][<span class="number">1</span>]+dp[v][j][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[u][i+j][<span class="number">1</span>][<span class="number">1</span>]+=temp[i][<span class="number">1</span>][<span class="number">0</span>]*(dp[v][j][<span class="number">1</span>][<span class="number">0</span>]+dp[v][j][<span class="number">1</span>][<span class="number">1</span>])+</span><br><span class="line">                temp[i][<span class="number">1</span>][<span class="number">1</span>]*(dp[v][j][<span class="number">0</span>][<span class="number">0</span>]+dp[v][j][<span class="number">0</span>][<span class="number">1</span>]+dp[v][j][<span class="number">1</span>][<span class="number">0</span>]+dp[v][j][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(dp[<span class="number">1</span>][k][<span class="number">0</span>][<span class="number">1</span>]+dp[<span class="number">1</span>][k][<span class="number">1</span>][<span class="number">1</span>]).val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="at_dp_e-knapsack-2"><a
href="https://atcoder.jp/contests/dp/tasks/dp_e"
title="AT_dp_e Knapsack 2">AT_dp_e Knapsack 2</a></h3>
<p>背包变形。将 <span class="math inline">\(v\)</span> 和 <span
class="math inline">\(w\)</span> 互换一下就行。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,W,w,v,sum;</span><br><span class="line">ll dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,W);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(w,v);</span><br><span class="line">        sum+=v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=v;j--)</span><br><span class="line">            dp[j]=<span class="built_in">Min</span>(dp[j],dp[j-v]+w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=sum;i;i--)</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&lt;=W)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="at_dp_j-sushi"><a
href="https://www.luogu.com.cn/problem/AT_dp_j"
title="AT_dp_j Sushi">AT_dp_j Sushi</a></h3>
<p><span class="math inline">\(dp_{i,j,k}\)</span> 表示有 <span
class="math inline">\(i\)</span> 个装 <span
class="math inline">\(1\)</span> 个寿司，<span
class="math inline">\(j\)</span> 个装 <span
class="math inline">\(2\)</span> 个寿司和 <span
class="math inline">\(k\)</span> 个装 <span
class="math inline">\(3\)</span> 个寿司的盘子的期望次数。<span
class="math inline">\(dp_{i,j,k}\)</span> 为以下四项之和： - <span
class="math inline">\(\dfrac{n-(i+j+k)}{n}\times
(dp_{i,j,k}+1)\)</span>（空盘子）</p>
<ul>
<li><p><span class="math inline">\(\dfrac{i}{n}\times
(dp_{i-1,j,k}+1)\)</span>（放 <span class="math inline">\(1\)</span>
个）</p></li>
<li><p><span class="math inline">\(\dfrac{j}{n}\times
(dp_{i+1,j-1,k}+1)\)</span>（放 <span class="math inline">\(2\)</span>
个）</p></li>
<li><p><span class="math inline">\(\dfrac{k}{n}\times
(dp_{i,j+1,k-1}+1)\)</span>（放 <span class="math inline">\(3\)</span>
个）</p></li>
</ul>
<p>整理，得 <span
class="math display">\[dp_{i,j,k}=\frac{n}{i+j+k}+\frac{i\times
dp_{i-1,j,k}}{i+j+k}+\frac{j\times dp_{i+1,j-1,k}}{i+j+k}+\frac{k\times
dp_{i,j+1,k-1}}{i+j+k}\]</span> 显然，应当按 <span
class="math inline">\(k-j-i\)</span> 顺序枚举以消除后效性。边界：<span
class="math inline">\(dp_{0,0,0}=0\)</span>。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n,cnt[<span class="number">4</span>];</span><br><span class="line"><span class="type">double</span> dp[N][N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a;i&lt;=n;i++) <span class="built_in">read</span>(a),++cnt[a];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j&amp;&amp;j==k&amp;&amp;k==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">double</span> inv=i+j+k;</span><br><span class="line">                dp[i][j][k]=n/inv;</span><br><span class="line">                <span class="keyword">if</span>(i) dp[i][j][k]+=dp[i<span class="number">-1</span>][j][k]*i/inv;</span><br><span class="line">                <span class="keyword">if</span>(j) dp[i][j][k]+=dp[i<span class="number">+1</span>][j<span class="number">-1</span>][k]*j/inv;</span><br><span class="line">                <span class="keyword">if</span>(k) dp[i][j][k]+=dp[i][j<span class="number">+1</span>][k<span class="number">-1</span>]*k/inv;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf&quot;</span>,dp[cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]][cnt[<span class="number">3</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <tags>
        <tag>题目合集</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT 快速傅里叶变换</title>
    <url>/2025/07/04/FFT%20%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="前置知识">前置知识</h3>
<p>默认你已经学过复数。没有的话右转高中数学 A 版必修二。 #### 多项式
形如 <span class="math display">\[F(x)=\sum_{i=0}^n a_i x^i\]</span>
的式子。其中 <span class="math inline">\(n\)</span> 为非负整数，<span
class="math inline">\(a_i\)</span> 属于<a
href="https://baike.baidu.com/item/%E6%95%B0%E5%9F%9F/1259870"
title="数域">数域</a> <span
class="math inline">\(P\)</span>。我们只需知道所有 <span
class="math inline">\(a_i\)</span>，就可以确定一个多项式。这就是多项式的系数表示法。
为了方便运算，我们引入多项式的点值表示法。 对于一个 <span
class="math inline">\(n\)</span> 次多项式 <span
class="math inline">\(F(x)\)</span>，我们可以用 <span
class="math inline">\(n+1\)</span> 个互不相同的点 <span
class="math inline">\(\{(x_0,F(x_0)),(x_1,F(x_1)),\cdots,(x_{n+1},F(x_{n+1}))\}\)</span>
来确定这个多项式。我们下文称这个集合为 <span
class="math inline">\(S_{F(x)}\)</span>。
系数表示法转为点值表示法的过程叫做 DFT，反之叫 IDFT。 #### 四则运算
只说乘法。 现有多项式 <span class="math inline">\(F(x)=\sum_{i=0}^n a_i
x^i\)</span> 和 <span class="math inline">\(G(x)=\sum_{j=0}^m b_j
x^j\)</span>。则有 <span class="math display">\[F(x)\times
G(x)=\sum_{i=0}^n\sum_{j=0}^ma_ib_jx^{i+j}\]</span> #### 卷积
事实上，卷积运算和多项式乘法在数学上是等价的。<span
class="math inline">\(H(x)=F(x) * G(x)\)</span> 表示 <span
class="math inline">\(H(x)\)</span> 为 <span
class="math inline">\(F(x)\)</span> 和 <span
class="math inline">\(G(x)\)</span> 的卷积。
刚才的多项式乘法求得的式子并不是标准的多项式形式。我们设 <span
class="math inline">\(H(x)=F(x) *
G(x)=\sum_{k=0}^{n+m}c_kx^k\)</span>。则每项的系数 <span
class="math inline">\(c_k=\sum_{i+j=k}a_ib_j\)</span>，变为更容易计算的形式
<span
class="math display">\[c_k=\sum_{i=\max(0,k-m)}^{\min(n,k)}a_ib_{k-i}\]</span>
若使用点值表示法，设 <span
class="math display">\[S_{F(x)}=\{(x_i,y_i)\}\]</span> <span
class="math display">\[S_{G(x)}=\{(x_i,y&#39;_i)\}\]</span> 则有 <span
class="math display">\[S_{H(x)}=\{(x_i,y_iy&#39;_i)\}\]</span> ####
单位根 根据<a
href="https://baike.baidu.com/item/%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/18104?fromModule=lemma_inlink"
title="代数基本定理">代数基本定理</a>，<span
class="math inline">\(x^n=1\)</span> 有 <span
class="math inline">\(n\)</span> 个根，这 <span
class="math inline">\(n\)</span> 个根都称为单位根。记作 <span
class="math inline">\(\{\omega_n^k\mid
k=0,1,\cdots,n-1\}\)</span>，其中，<span
class="math inline">\(\omega_n^0=1\)</span>。在复平面上，它们刚好将单位圆
<span class="math inline">\(n\)</span> 等分。一般说的单位根 <span
class="math inline">\(\omega_n\)</span>，指从 <span
class="math inline">\((1,0)\)</span> 开始逆时针方向上的第一个根。
一些下面会用到的小式子： - 对于偶数次单位根，有 <span
class="math inline">\(\omega_n^i=-\omega_n^{i+\frac{n}{2}}\)</span>（其实就是在复平面上关于原点中心对称）。
- <span class="math inline">\(\omega_{2n}^{2k}=\omega_n^k\)</span> -
<span class="math inline">\((\omega_n^k)^2=\omega_n^{2k}\)</span> ### <a
href="https://www.luogu.com.cn/problem/P3803" title="FFT">FFT</a>
显然，朴素算法求解 <span class="math inline">\(F(x) * G(x)\)</span>
的时间复杂度为 <span class="math inline">\(O(nm)\)</span>，而 FFT
可以让我们在 <span class="math inline">\(O(n\log n)\)</span>
的时间复杂度内计算两个 <span class="math inline">\(n\)</span>
次多项式的乘法。基本思想是分治。 我们只需对 <span
class="math inline">\(F(x)\)</span> 和 <span
class="math inline">\(G(x)\)</span> 进行 DFT，计算 <span
class="math inline">\(S_{H(x)}=S_{F(x)}*S_{G(x)}\)</span>，最后再对
<span class="math inline">\(S_{H(x)}\)</span> IDFT 即得 <span
class="math inline">\(H(x)\)</span>。 接下来说 DFT 的过程。 对于 <span
class="math inline">\(F(x)\)</span>，将其划分为奇次与偶次两部分。 <span
class="math display">\[F(x)=\sum_{i=0}^{\frac{n}{2}}a_{2i}x^{2i}+\sum_{i=0}^{\frac{n}{2}}a_{2i+1}x^{2i+1}\]</span>
将右半部分提出一个 <span class="math inline">\(x\)</span> <span
class="math display">\[F(x)=\sum_{i=0}^{\frac{n}{2}}a_{2i}x^{2i}+x\sum_{i=0}^{\frac{n}{2}}a_{2i+1}x^{2i}\]</span>
将前后两部分用新的多项式表示 <span
class="math display">\[F_1(x)=\sum_{i=0}^{\frac{n}{2}}a_{2i}x^{i}\]</span>
<span
class="math display">\[F_2(x)=\sum_{i=0}^{\frac{n}{2}}a_{2i+1}x^{i}\]</span>
<span class="math display">\[F(x)=F_1(x^2)+xF_2(x^2)\]</span>
这时我们代入 <span class="math inline">\(\omega_n^k\)</span>，可得 <span
class="math display">\[\begin{aligned}
F(\omega_n^k)&amp;=F_1((\omega_n^k)^2)+\omega_n^kF_2((\omega_n^k)^2)\\
&amp;=F_1(\omega_n^{2k})+\omega_n^kF_2(\omega_n^{2k})\\
&amp;=F_1(\omega_\frac{n}{2}^k)+\omega_n^kF_2(\omega_\frac{n}{2}^k)
\end{aligned}\]</span> 同理，代入 <span
class="math inline">\(\omega_n^{k+\frac{n}{2}}=-\omega_n^k\)</span>，得
<span
class="math display">\[F(\omega_n^{k+\frac{n}{2}})=F_1(\omega_\frac{n}{2}^k)-\omega_n^kF_2(\omega_\frac{n}{2}^k)\]</span>
所以，我们可以根据 <span
class="math inline">\(F_1(\omega_\frac{n}{2}^k)\)</span> 和 <span
class="math inline">\(F_2(\omega_\frac{n}{2}^k)\)</span> 求出 <span
class="math inline">\(F(\omega_n^k)\)</span> 和 <span
class="math inline">\(F(\omega_n^{k+\frac{n}{2}})\)</span>。这种做法只能处理长度为
<span class="math inline">\(2\)</span>
的正整次幂的多项式，所以我们要把高次系数补为 <span
class="math inline">\(0\)</span>。 接下来是 IDFT。它的操作与 DFT
极像，就是将 <span class="math inline">\(\omega_n^k\)</span> 变为 <span
class="math inline">\(\omega_n^{-k}\)</span>，并在最后乘 <span
class="math inline">\(\dfrac{1}{n}\)</span>。
现实计算中，递归处理效率较低，我们使用位逆序置换优化和蝶形运算优化，直接将值排列为特定的顺序，避免了递归和额外的临时数组。
#### 位逆序置换优化 我们要想避免递归，就要将需要一起计算的部分放在一起。
我们以 <span class="math inline">\(7\)</span> 次多项式为例，有 <span
class="math inline">\(8\)</span> 个 <span
class="math inline">\(a_i\)</span>，具体划分方式如图 <img
src="https://github.com/headless-piston/blog_images/blob/main/FFT.png?raw=true"
alt="image" />
规律很难注意到，我直接说了，就是将每个下标的二进制反转，以反转后的数为新下标。例如，<span
class="math inline">\(3\)</span> 的二进制是 <span
class="math inline">\(011\)</span>，反转后为 <span
class="math inline">\(110\)</span>，即 <span
class="math inline">\(6\)</span>，从图上来看，<span
class="math inline">\(a_3\)</span> 确实到了原 <span
class="math inline">\(a_6\)</span> 的位置。 #### 蝶形运算优化
位逆序置换后，我们可以直接计算 <span
class="math inline">\(F_1(x)\)</span> 和 <span
class="math inline">\(F_2(x)\)</span>
而无需临时数组，因为计算要用到的数与计算完成后的数应当被存在相同的下标内，直接覆盖原数就行了。具体地，计算
<span class="math inline">\(F(\omega_n^k)\)</span> 和 <span
class="math inline">\(F(\omega_n^{k+\frac{n}{2}})\)</span> 时 <span
class="math inline">\(F_1(\omega_\frac{n}{2}^k)\)</span> 的值在下标
<span class="math inline">\(k\)</span>，<span
class="math inline">\(F_2(\omega_\frac{n}{2}^k)\)</span> 的值在下标
<span class="math inline">\(k+\frac{n}{2}\)</span>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">22</span>;<span class="comment">//要开略大一些因为len可能会大于n+m</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="number">4</span>*<span class="built_in">atan</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> n,m,a[N],b[N],len=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">comp</span>&#123;</span><br><span class="line">	<span class="type">double</span> real,imag;</span><br><span class="line">&#125;fa[N],fb[N],fc[N];</span><br><span class="line">comp <span class="keyword">operator</span>+(<span class="type">const</span> comp &amp;x,<span class="type">const</span> comp &amp;y)&#123;</span><br><span class="line">	<span class="keyword">return</span> comp&#123;x.real+y.real,x.imag+y.imag&#125;;</span><br><span class="line">&#125;</span><br><span class="line">comp <span class="keyword">operator</span>-(<span class="type">const</span> comp &amp;x,<span class="type">const</span> comp &amp;y)&#123;</span><br><span class="line">	<span class="keyword">return</span> comp&#123;x.real-y.real,x.imag-y.imag&#125;;</span><br><span class="line">&#125;</span><br><span class="line">comp <span class="keyword">operator</span>*(<span class="type">const</span> comp &amp;x,<span class="type">const</span> comp &amp;y)&#123;</span><br><span class="line">	<span class="keyword">return</span> comp&#123;x.real*y.real-x.imag*y.imag,x.real*y.imag+y.real*x.imag&#125;;</span><br><span class="line">&#125;</span><br><span class="line">comp <span class="keyword">operator</span>/(<span class="type">const</span> comp &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;</span><br><span class="line">	<span class="keyword">return</span> comp&#123;x.real/(<span class="type">double</span>)y,x.imag/(<span class="type">double</span>)y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(comp *f,<span class="type">int</span> n,<span class="type">int</span> rev)</span></span>&#123;<span class="comment">//rev=1代表DFT，rev=-1代表IDFT</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=n&gt;&gt;<span class="number">1</span>,k;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//位逆序置换，0和n-1不用换</span></span><br><span class="line">		<span class="keyword">if</span>(i&lt;j)<span class="comment">//j即i的二进制反转，判断i&lt;j是为了保证只交换1次</span></span><br><span class="line">			<span class="built_in">swap</span>(f[i],f[j]);</span><br><span class="line">		k=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(j&gt;=k)&#123;<span class="comment">//清除高位</span></span><br><span class="line">			j-=k;</span><br><span class="line">			k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		j+=k;<span class="comment">//更新低位</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">double</span> arg=<span class="number">2</span>*PI*rev/len;</span><br><span class="line">		comp wn=&#123;<span class="built_in">cos</span>(arg),<span class="built_in">sin</span>(arg)&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line">			comp w=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len/<span class="number">2</span>;j++)&#123;</span><br><span class="line">				comp f1=f[i+j];</span><br><span class="line">				comp f2=f[i+j+len/<span class="number">2</span>];</span><br><span class="line">				f[i+j]=f1+w*f2;</span><br><span class="line">				f[i+j+len/<span class="number">2</span>]=f1-w*f2;</span><br><span class="line">				w=w*wn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!~rev)<span class="comment">//IDFT的最后除以n操作</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			f[i]=f[i]/n;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,b+i);</span><br><span class="line">	<span class="keyword">while</span>(len&lt;=n+m)</span><br><span class="line">		len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		fa[i]=&#123;(<span class="type">double</span>)a[i],<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">		fb[i]=&#123;(<span class="type">double</span>)b[i],<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">FFT</span>(fa,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">FFT</span>(fb,len,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		fc[i]=fa[i]*fb[i];</span><br><span class="line">	<span class="built_in">FFT</span>(fc,len,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+m;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,(<span class="type">int</span>)<span class="built_in">round</span>(fc[i].real));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ####
其他优化 可以预处理单位根，无需在变换过程中计算，以提高效率和精度。 ###
参考资料 https://www.cnblogs.com/Kenma/p/18813688</p>
<p>https://oi-wiki.org/math/poly/fft/</p>
<p><a href="https://grok.com/"
title="特别鸣谢">特别鸣谢</a>，解决了我在数学上的一些疑惑。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Segment Tree Beats</title>
    <url>/2025/07/04/Segment%20Tree%20Beats/</url>
    <content><![CDATA[<h3 id="区间最值操作">区间最值操作</h3>
<p>先来一道<a href="https://acm.hdu.edu.cn/showproblem.php?pid=5306"
title="例题">例题</a>。
这道题要求维护区间和，区间最大值以及<strong>区间最值操作</strong>。
区间和与区间最大值可以轻易地使用普通线段树维护，但这个<strong>区间最值操作</strong>是我们要研究的重点。
区间最值操作，说人话就是给出一个值 <span
class="math inline">\(t\)</span>，将区间内各元素的值限制在 <span
class="math inline">\(t\)</span> 以下（或以上）。也就是令区间内所有值对
<span class="math inline">\(t\)</span> 取 <span
class="math inline">\(\max\)</span>（或 <span
class="math inline">\(\min\)</span>）。例题是区间 <span
class="math inline">\(\min\)</span>。 对于线段树的每个节点，维护区间和
<span class="math inline">\(sum\)</span>，区间最大值 <span
class="math inline">\(maxn\)</span>，区间严格次大值 <span
class="math inline">\(se\)</span> 和最大值个数 <span
class="math inline">\(cnt\)</span>。 接下来，对于区间 <span
class="math inline">\(\min\)</span> 操作 - 若 <span
class="math inline">\(maxn&lt;t\)</span>，则显然操作无效，直接退出。 -
若 <span
class="math inline">\(se&lt;t&lt;maxn\)</span>，则修改只会影响到区间最大值，令
<span class="math inline">\(sum\gets sum-cnt \cdot
(maxn-t)\)</span>，<span class="math inline">\(maxn \gets
t\)</span>，打标记然后退出。 - 若 <span class="math inline">\(se\ge
t\)</span>，进入左右儿子递归搜索，然后上传信息。</p>
<p>可以证明，此法时间复杂度为 <span class="math inline">\(O(m\log
n)\)</span>。 <a
href="https://github.com/OI-wiki/libs/blob/master/%E9%9B%86%E8%AE%AD%E9%98%9F%E5%8E%86%E5%B9%B4%E8%AE%BA%E6%96%87/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2016%E8%AE%BA%E6%96%87%E9%9B%86.pdf"
title="证明详见 P104~105。">证明详见 P104~105。</a> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u*2+1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> t,n,m,a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span>&#123;</span><br><span class="line">	<span class="type">int</span> maxn,se,cnt;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> tag[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	tree[u].sum=tree[ls].sum+tree[rs].sum;</span><br><span class="line">	tree[u].maxn=<span class="built_in">max</span>(tree[ls].maxn,tree[rs].maxn);</span><br><span class="line">	tree[u].cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].maxn==tree[ls].maxn)</span><br><span class="line">		tree[u].cnt+=tree[ls].cnt;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].maxn==tree[rs].maxn)</span><br><span class="line">		tree[u].cnt+=tree[rs].cnt;</span><br><span class="line">	tree[u].se=<span class="built_in">max</span>(tree[ls].se,tree[rs].se);</span><br><span class="line">	<span class="keyword">if</span>(tree[ls].maxn!=tree[rs].maxn)</span><br><span class="line">		tree[u].se=<span class="built_in">max</span>(tree[u].se,<span class="built_in">min</span>(tree[ls].maxn,tree[rs].maxn));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	tag[u]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tree[u].sum=tree[u].maxn=a[l];</span><br><span class="line">		tree[u].cnt=<span class="number">1</span>;</span><br><span class="line">		tree[u].se=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="built_in">push_up</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].maxn&lt;=k)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	tree[u].sum-=(<span class="type">long</span> <span class="type">long</span>)tree[u].cnt*(tree[u].maxn-k);</span><br><span class="line">	tree[u].maxn=tag[u]=k;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tag[u]==<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">update_tag</span>(ls,tag[u]);</span><br><span class="line">	<span class="built_in">update_tag</span>(rs,tag[u]);</span><br><span class="line">	tag[u]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].maxn&lt;=k)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r&amp;&amp;tree[u].se&lt;k)&#123;</span><br><span class="line">		<span class="built_in">update_tag</span>(u,k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		<span class="built_in">modify</span>(ls,l,mid,x,y,k);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		<span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">	<span class="built_in">push_up</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_max</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">		<span class="keyword">return</span> tree[u].maxn;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>,res=<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		res=<span class="built_in">max</span>(res,<span class="built_in">query_max</span>(ls,l,mid,x,y));</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		res=<span class="built_in">max</span>(res,<span class="built_in">query_max</span>(rs,mid<span class="number">+1</span>,r,x,y));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">		<span class="keyword">return</span> tree[u].sum;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		res+=<span class="built_in">query_sum</span>(ls,l,mid,x,y);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		res+=<span class="built_in">query_sum</span>(rs,mid<span class="number">+1</span>,r,x,y);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			<span class="type">int</span> opt,x,y,t;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;opt,&amp;x,&amp;y);</span><br><span class="line">			<span class="keyword">if</span>(opt==<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">				<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,t);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_max</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y));</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query_sum</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ###
区间最值&amp;区间加 <a href="https://www.luogu.com.cn/problem/P10639"
title="例题">例题</a>
同时有区间加后，原本的势能分析就不适用了。复杂度变为 <span
class="math inline">\(O(m\log^2n)\)</span>。对于区间加，区间 <span
class="math inline">\(\max\)</span> 和区间 <span
class="math inline">\(\min\)</span> 各维护一个标记。
<del>然后你就会发现真的很难写。</del>
注意，区间加的标记优先级大于区间最值操作。还有，在进行更新时要考虑到
<span class="math inline">\(maxn\)</span>，<span
class="math inline">\(minn\)</span>，<span
class="math inline">\(max\_se\)</span>，<span
class="math inline">\(min\_se\)</span>，<span
class="math inline">\(min\_tag\)</span> 和 <span
class="math inline">\(max\_tag\)</span> 相互重叠的情况。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u*2+1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2e9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line">	<span class="type">int</span> maxn,minn,max_se,min_se,max_cnt,min_cnt,add_tag,max_tag,min_tag;</span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	tree[u].sum=tree[ls].sum+tree[rs].sum;</span><br><span class="line">	<span class="keyword">if</span>(tree[ls].maxn==tree[rs].maxn)&#123;</span><br><span class="line">		tree[u].maxn=tree[ls].maxn;</span><br><span class="line">		tree[u].max_cnt=tree[ls].max_cnt+tree[rs].max_cnt;</span><br><span class="line">		tree[u].max_se=<span class="built_in">max</span>(tree[ls].max_se,tree[rs].max_se);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(tree[ls].maxn&lt;tree[rs].maxn)&#123;</span><br><span class="line">		tree[u].maxn=tree[rs].maxn;</span><br><span class="line">		tree[u].max_cnt=tree[rs].max_cnt;</span><br><span class="line">		tree[u].max_se=<span class="built_in">max</span>(tree[ls].maxn,tree[rs].max_se);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		tree[u].maxn=tree[ls].maxn;</span><br><span class="line">		tree[u].max_cnt=tree[ls].max_cnt;</span><br><span class="line">		tree[u].max_se=<span class="built_in">max</span>(tree[rs].maxn,tree[ls].max_se);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tree[ls].minn==tree[rs].minn)&#123;</span><br><span class="line">		tree[u].minn=tree[ls].minn;</span><br><span class="line">		tree[u].min_cnt=tree[ls].min_cnt+tree[rs].min_cnt;</span><br><span class="line">		tree[u].min_se=<span class="built_in">min</span>(tree[ls].min_se,tree[rs].min_se);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(tree[ls].minn&lt;tree[rs].minn)&#123;</span><br><span class="line">		tree[u].minn=tree[ls].minn;</span><br><span class="line">		tree[u].min_cnt=tree[ls].min_cnt;</span><br><span class="line">		tree[u].min_se=<span class="built_in">min</span>(tree[ls].min_se,tree[rs].minn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		tree[u].minn=tree[rs].minn;</span><br><span class="line">		tree[u].min_cnt=tree[rs].min_cnt;</span><br><span class="line">		tree[u].min_se=<span class="built_in">min</span>(tree[rs].min_se,tree[ls].minn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	tree[u].max_tag=-inf,tree[u].min_tag=inf;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tree[u].sum=tree[u].maxn=tree[u].minn=a[l];</span><br><span class="line">		tree[u].max_cnt=tree[u].min_cnt=<span class="number">1</span>;</span><br><span class="line">		tree[u].max_se=-inf;</span><br><span class="line">		tree[u].min_se=inf;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="built_in">push_up</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	tree[u].sum+=(r-l<span class="number">+1ll</span>)*k;</span><br><span class="line">	tree[u].maxn+=k,tree[u].minn+=k,tree[u].add_tag+=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].max_se!=-inf)</span><br><span class="line">		tree[u].max_se+=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].min_se!=inf)</span><br><span class="line">		tree[u].min_se+=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].max_tag!=-inf)</span><br><span class="line">		tree[u].max_tag+=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].min_tag!=inf)</span><br><span class="line">		tree[u].min_tag+=k;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_min_tag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].maxn&lt;=k)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	tree[u].sum+=(<span class="number">1ll</span>*k-tree[u].maxn)*tree[u].max_cnt;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].min_se==tree[u].maxn)</span><br><span class="line">		tree[u].min_se=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].minn==tree[u].maxn)</span><br><span class="line">		tree[u].minn=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].max_tag&gt;k)</span><br><span class="line">		tree[u].max_tag=k;</span><br><span class="line">	tree[u].maxn=k,tree[u].min_tag=k;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_max_tag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].minn&gt;=k)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	tree[u].sum+=(<span class="number">1ll</span>*k-tree[u].minn)*tree[u].min_cnt;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].max_se==tree[u].minn)</span><br><span class="line">		tree[u].max_se=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].maxn==tree[u].minn)</span><br><span class="line">		tree[u].maxn=k;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].min_tag&lt;k)</span><br><span class="line">		tree[u].min_tag=k;</span><br><span class="line">	tree[u].minn=k,tree[u].max_tag=k;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(tree[u].add_tag)</span><br><span class="line">		<span class="built_in">update_add</span>(ls,l,mid,tree[u].add_tag),<span class="built_in">update_add</span>(rs,mid<span class="number">+1</span>,r,tree[u].add_tag);</span><br><span class="line">	<span class="keyword">if</span>(tree[u].max_tag!=-inf)</span><br><span class="line">		<span class="built_in">update_max_tag</span>(ls,tree[u].max_tag),<span class="built_in">update_max_tag</span>(rs,tree[u].max_tag);</span><br><span class="line">	<span class="keyword">if</span>(tree[u].min_tag!=inf)</span><br><span class="line">		<span class="built_in">update_min_tag</span>(ls,tree[u].min_tag),<span class="built_in">update_min_tag</span>(rs,tree[u].min_tag);</span><br><span class="line">	tree[u].add_tag=<span class="number">0</span>,tree[u].max_tag=-inf,tree[u].min_tag=inf;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">		<span class="built_in">update_add</span>(u,l,r,k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		<span class="built_in">modify_add</span>(ls,l,mid,x,y,k);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		<span class="built_in">modify_add</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">	<span class="built_in">push_up</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_max</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r&amp;&amp;tree[u].min_se&gt;k)&#123;</span><br><span class="line">		<span class="built_in">update_max_tag</span>(u,k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		<span class="built_in">modify_max</span>(ls,l,mid,x,y,k);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		<span class="built_in">modify_max</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">	<span class="built_in">push_up</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_min</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r&amp;&amp;tree[u].max_se&lt;k)&#123;</span><br><span class="line">		<span class="built_in">update_min_tag</span>(u,k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		<span class="built_in">modify_min</span>(ls,l,mid,x,y,k);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		<span class="built_in">modify_min</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">	<span class="built_in">push_up</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">		<span class="keyword">return</span> tree[u].sum;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		res+=<span class="built_in">query_sum</span>(ls,l,mid,x,y);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		res+=<span class="built_in">query_sum</span>(rs,mid<span class="number">+1</span>,r,x,y);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_max</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">		<span class="keyword">return</span> tree[u].maxn;</span><br><span class="line">	<span class="type">int</span> res=-inf,mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		res=<span class="built_in">max</span>(res,<span class="built_in">query_max</span>(ls,l,mid,x,y));</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		res=<span class="built_in">max</span>(res,<span class="built_in">query_max</span>(rs,mid<span class="number">+1</span>,r,x,y));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_min</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">		<span class="keyword">return</span> tree[u].minn;</span><br><span class="line">	<span class="type">int</span> res=inf,mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		res=<span class="built_in">min</span>(res,<span class="built_in">query_min</span>(ls,l,mid,x,y));</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">		res=<span class="built_in">min</span>(res,<span class="built_in">query_min</span>(rs,mid<span class="number">+1</span>,r,x,y));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">	<span class="type">int</span> opt,l,r,x;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;opt,&amp;l,&amp;r);</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">			<span class="built_in">modify_add</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">			<span class="built_in">modify_max</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">			<span class="built_in">modify_min</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query_sum</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">5</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_max</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_min</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### 区间历史最值 <a href="https://www.luogu.com.cn/problem/P6242"
title="例题">例题</a>
这里的“历史”不同于可持久化，以历史最大值为例，我们称原数组为 <span
class="math inline">\(A\)</span>，定义数组 <span
class="math inline">\(B\)</span>，则 <span
class="math inline">\(B_i\)</span> 表示所有历史版本中最大的那个 <span
class="math inline">\(A_i\)</span>，形式化地，每次操作之后，都令 <span
class="math inline">\(B_i=\max(A_i,B_i)\)</span>。初始时 <span
class="math inline">\(B\)</span> 与 <span
class="math inline">\(A\)</span> 相同。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码先咕着</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOIP 2012 提高组] 国王游戏</title>
    <url>/2025/07/04/%5BNOIP%202012%20%E6%8F%90%E9%AB%98%E7%BB%84%5D%20%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1080"
title="~~高精毒瘤题~~"><del>高精毒瘤题</del></a></p>
<p>考虑贪心。</p>
<p><strong>对于两个大臣 <span class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span>，当 <span class="math inline">\(a_i
\times b_i &lt;a_j \times b_j\)</span> 时，<span
class="math inline">\(i\)</span> 排在 <span
class="math inline">\(j\)</span> 前更优</strong> ### 证明：
因为所有大臣排成一列，所以我们考虑其中两个的关系，就可以推广到所有大臣。
我们还是取两个大臣 <span class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span>，他们前面的人左手上的积为 <span
class="math inline">\(x\)</span>，假设 <span
class="math inline">\(i\)</span> 在前面更优，则有： <span
class="math display">\[ans_1=\max(\frac{x}{b_i},\frac{x\times
a_i}{b_j})\]</span> 若 <span class="math inline">\(j\)</span>
在前面更优，则有 <span
class="math display">\[ans_2=\max(\frac{x}{b_j},\frac{x\times
a_j}{b_i})\]</span> 显然有 <span class="math display">\[\frac{x}{b_i}
\le \frac{x\times a_j}{b_i},\frac{x}{b_j}\le\frac{x\times
a_i}{b_j}\]</span> 若令 <span class="math inline">\(ans_1 &lt;
ans_2\)</span>，则必然有 <span class="math display">\[\frac{x\times
a_i}{b_j}&lt;\frac{x\times a_j}{b_i}\]</span> 化简，得 <span
class="math display">\[a_i \times b_i &lt; a_j \times b_j\]</span>
证毕。</p>
<h3 id="code">code:</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,a,b;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(node x,node y)&#123;</span><br><span class="line">	<span class="keyword">return</span> x.a*x.b&lt;y.a*y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ll</span>&#123;</span><br><span class="line">	<span class="type">int</span> num[N*<span class="number">5</span>];</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="built_in">ll</span>()&#123;</span><br><span class="line">		<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">		len=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">int</span> x)&#123;</span><br><span class="line">		<span class="keyword">while</span>(x)&#123;</span><br><span class="line">			num[++len]=x%<span class="number">10</span>;</span><br><span class="line">			x/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> ll &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;len&lt;x.len)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;len&gt;x.len)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=len;i;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;num[i]&lt;x.num[i])</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;num[i]&gt;x.num[i])</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll <span class="keyword">operator</span>*(<span class="type">const</span> <span class="type">int</span> &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">		ll ans;</span><br><span class="line">		ans.len=<span class="keyword">this</span>-&gt;len;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="keyword">this</span>-&gt;len;i++)&#123;</span><br><span class="line">			ans.num[i]+=<span class="keyword">this</span>-&gt;num[i]*x;</span><br><span class="line">			ans.num[i<span class="number">+1</span>]=ans.num[i]/<span class="number">10</span>;</span><br><span class="line">			ans.num[i]%=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans.num[ans.len<span class="number">+1</span>])&#123;</span><br><span class="line">			<span class="type">int</span> k=ans.num[ans.len<span class="number">+1</span>];</span><br><span class="line">			<span class="keyword">while</span>(k)&#123;</span><br><span class="line">				ans.len++;</span><br><span class="line">				ans.num[ans.len]=k%<span class="number">10</span>;</span><br><span class="line">				k/=<span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> <span class="type">int</span> &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="type">int</span> k=x,len1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(k)&#123;</span><br><span class="line">			k/=<span class="number">10</span>;</span><br><span class="line">			len1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(len1&gt;<span class="keyword">this</span>-&gt;len)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(len1&lt;<span class="keyword">this</span>-&gt;len)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		k=x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;num[i]&lt;k%<span class="number">10</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;num[i]&gt;k%<span class="number">10</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			k/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll <span class="keyword">operator</span>/(<span class="type">const</span> <span class="type">int</span> &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">		ll ans;</span><br><span class="line">		<span class="keyword">if</span>(*<span class="keyword">this</span>&lt;x)</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		ans.len=<span class="keyword">this</span>-&gt;len;</span><br><span class="line">		<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="keyword">this</span>-&gt;len;i;i--)&#123;</span><br><span class="line">			k=k*<span class="number">10</span>+<span class="keyword">this</span>-&gt;num[i];</span><br><span class="line">			ans.num[i]=k/x;</span><br><span class="line">			k%=x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!ans.num[ans.len])</span><br><span class="line">			ans.len--;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.len==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x.len;i;i--)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x.num[i]);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">max1</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;y)</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">ll cnt,ans1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;a,&amp;b);</span><br><span class="line">	cnt=a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;e[i].a,&amp;e[i].b);</span><br><span class="line">	<span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		ans1=<span class="built_in">max1</span>(ans1,cnt/e[i].b);</span><br><span class="line">		cnt=cnt*e[i].a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(ans1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[Ynoi2018] 五彩斑斓的世界</title>
    <url>/2025/07/04/%5BYnoi2018%5D%20%E4%BA%94%E5%BD%A9%E6%96%91%E6%96%93%E7%9A%84%E4%B8%96%E7%95%8C/</url>
    <content><![CDATA[<p><del>写 Ynoi 题会破防，我试了，是真的。</del></p>
<p>分块 + 并查集。 开一个值域大小的并查集，这样我们就可以 <span
class="math inline">\(O(1)\)</span> 修改所有块内相同的值。同时通过维护
<span class="math inline">\(siz\)</span>
数组来快速查询某数出现的次数，且可以随并查集的合并而合并。
接下来进行复杂度分析。注意到，对于本题的修改操作，块内的最大值 <span
class="math inline">\(maxn\)</span> 单调不增。<span
class="math inline">\(maxn\)</span> 最大为 <span
class="math inline">\(10^5+1\)</span>，<span
class="math inline">\(m\)</span> 最大为 <span
class="math inline">\(5\times 10^5\)</span>，可以视为均摊 <span
class="math inline">\(O(1)\)</span>。
对于整块的修改操作，我们分两种情况讨论： 当 <span
class="math inline">\(2x\ge maxn\)</span> 时，令所有大于 <span
class="math inline">\(x\)</span> 的数减去 <span
class="math inline">\(x\)</span>，此时暴力更新 <span
class="math inline">\(maxn\)</span>。 当 <span
class="math inline">\(2x&lt; maxn\)</span> 时，令所有小于等于 <span
class="math inline">\(x\)</span> 的数加上 <span
class="math inline">\(x\)</span>，再将块上的 <span
class="math inline">\(tag\)</span> 加 <span
class="math inline">\(x\)</span>，表示真实值为整体减 <span
class="math inline">\(tag\)</span>。
对于散块，暴力拆散原来的并查集，直接修改并更新 <span
class="math inline">\(maxn\)</span> 就好。 整块更新是均摊 <span
class="math inline">\(O(1)\)</span>，散块更新是均摊 <span
class="math inline">\(O(\sqrt n)\)</span>。 此题卡空间，无法做到 <span
class="math inline">\(O(V\sqrt n)\)</span>
的并查集空间复杂度。考虑将询问离线，在每个块跑一遍询问，答案直接累加。这样我们只需
<span class="math inline">\(O(V)\)</span> 的空间复杂度。
以上方法无法正确处理 <span class="math inline">\(a_i=0\)</span>
的情况。注意到，修改操作不会产生新的 <span
class="math inline">\(0\)</span>，所以直接在一开始用前缀和处理掉 <span
class="math inline">\(0\)</span> 的询问，之后就不用管了。</p>
]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【MX-X11-T1】「蓬莱人形 Round 1」仅此而已，就已经足够了</title>
    <url>/2025/07/04/%E3%80%90MX-X11-T1%E3%80%91%E3%80%8C%E8%93%AC%E8%8E%B1%E4%BA%BA%E5%BD%A2%20Round%201%E3%80%8D%E4%BB%85%E6%AD%A4%E8%80%8C%E5%B7%B2%EF%BC%8C%E5%B0%B1%E5%B7%B2%E7%BB%8F%E8%B6%B3%E5%A4%9F%E4%BA%86/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P12147"
title="~~这题评黄？~~"><del>这题评黄？</del></a> ### 题意简述 定义 <span
class="math inline">\(f(x)=x\oplus(x+2^k)\)</span>。给出 <span
class="math inline">\(n\)</span>，求 <span
class="math inline">\(f(0)+f(1)+f(2)+\cdots+f(n)\)</span>。<span
class="math inline">\(T\)</span> 组询问，每组有不同的 <span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(k\)</span>。<span class="math inline">\(1 \le T\le
10^5\)</span>，<span class="math inline">\(0 \le n &lt;
2^{29}\)</span>，<span class="math inline">\(0 \le k \le 29\)</span>。
### 思路 由于 <span class="math inline">\(T\)</span> 较大，考虑 <span
class="math inline">\(O(1)\)</span> 或 <span
class="math inline">\(O(\log n)\)</span>
求法。先打表找规律。因题目有特殊性质 <span
class="math inline">\(k=0\)</span>，考虑先打 <span
class="math inline">\(k=0\)</span> 时 <span
class="math inline">\(f(0)\)</span> 到 <span
class="math inline">\(f(n)\)</span>
的值。由于涉及位运算，考虑同时观察二进制。打表得到 <span
class="math display">\[
f(0)=1=(1)_2\\
f(1)=3=(11)_2\\
f(2)=1=(1)_2\\
f(3)=7=(111)_2\\
f(4)=1=(1)_2\\
f(5)=3=(11)_2\\
f(6)=1=(1)_2\\
\cdots
\]</span> 观察到一种对称性：<span class="math inline">\(f(0)\)</span> 和
<span class="math inline">\(f(2)\)</span> 关于 <span
class="math inline">\(f(1)\)</span> 对称，然后将这 <span
class="math inline">\(3\)</span> 个数视为一个整块，则 <span
class="math inline">\(f(0)\)</span> 到 <span
class="math inline">\(f(2)\)</span> 的部分和 <span
class="math inline">\(f(4)\)</span> 到 <span
class="math inline">\(f(6)\)</span> 的部分关于 <span
class="math inline">\(f(3)\)</span> 对称。同理，<span
class="math inline">\(f(0)\)</span> 到 <span
class="math inline">\(f(6)\)</span>
的部分还能继续对称下去。为了方便，我们把最短的块 <span
class="math inline">\(f(0)=1\)</span> 记作 <span
class="math inline">\(K_1\)</span>，称为 <span
class="math inline">\(1\)</span> 阶块，<span
class="math inline">\(K_n\)</span> 的长度记为 <span
class="math inline">\(len_n\)</span>，<span
class="math inline">\(K_n\)</span> 内所有元素之和为 <span
class="math inline">\(sum_n\)</span>。则 <span
class="math inline">\(K_2\)</span> 应当包含 <span
class="math inline">\(f(0)\)</span>，<span
class="math inline">\(f(1)\)</span>，<span
class="math inline">\(f(2)\)</span>。以此类推。 接下来，尝试将规律推广到
<span class="math inline">\(k&gt;0\)</span> 的情况。 打 <span
class="math inline">\(k=1\)</span> 的表，得 <span
class="math display">\[
f(0)=(10)_2\\
f(1)=(10)_2\\
f(2)=(110)_2\\
f(3)=(110)_2\\
f(4)=(10)_2\\
f(5)=(10)_2\\
f(6)=(1110)_2\\
f(7)=(1110)_2\\
\cdots
\]</span> 我们发现，<span class="math inline">\(len_1\)</span> 变为了
<span class="math inline">\(2^1\)</span>。而 <span
class="math inline">\(K_1\)</span> 中的值变为了 <span
class="math inline">\((10)_2\)</span>，也就是 <span
class="math inline">\(2^1\)</span>。继续打出 <span
class="math inline">\(k=2\)</span> 和 <span
class="math inline">\(k=3\)</span> 时的表，发现如下规律： <strong><span
class="math inline">\(len_1\)</span> 为 <span
class="math inline">\(2^k\)</span>，<span
class="math inline">\(K_1\)</span> 中的元素的值为 <span
class="math inline">\(2^k\)</span></strong>。 ### 实现 考虑分治。 考虑从
<span class="math inline">\(K_x\)</span> 推得 <span
class="math inline">\(K_{x+1}\)</span>，我们发现，<span
class="math inline">\(K_{x+1}\)</span> 应分为 <span
class="math inline">\(3\)</span> 部分，<span
class="math inline">\(K_x\)</span> 作为左右两部分，<span
class="math inline">\(2^k\)</span> 个 <span
class="math inline">\(2^{x+1}-1\)</span> 左移 <span
class="math inline">\(k\)</span> 位作为中间部分。容易发现 <span
class="math inline">\(len_{x+1}=2 \times len_x+2^k\)</span>。 反之，从
<span class="math inline">\(K_{x+1}\)</span> 推得 <span
class="math inline">\(K_x\)</span>，有 <span
class="math inline">\(len_{x}=\dfrac{len_{x+1}-2^k}{2}\)</span>。 由于
<span class="math inline">\(k&gt;0\)</span> 时的 <span
class="math inline">\(sum_n\)</span> 都可从 <span
class="math inline">\(k=0\)</span> 时的 <span
class="math inline">\(sum_n\)</span> 通过位运算 <span
class="math inline">\(O(1)\)</span> 求出，考虑预处理出 <span
class="math inline">\(k=0\)</span> 时的 <span
class="math inline">\(sum_1\)</span> 到 <span
class="math inline">\(sum_k\)</span>，之所以只处理到 <span
class="math inline">\(sum_k\)</span>，是因为 <span
class="math inline">\(len_k\)</span> 刚好略大于 <span
class="math inline">\(\max(n)\)</span>，即 <span
class="math inline">\(2^{29}\)</span>，已经可以覆盖所有 <span
class="math inline">\(f(x)\)</span>。 其他实现细节详见代码注释。 ###
code 这里的递归过程很像线段树。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">536870911</span>;</span><br><span class="line"><span class="type">int</span> t,n,k;<span class="comment">//同原题</span></span><br><span class="line"><span class="type">int</span> len;<span class="comment">//中间部分长度，同时也是最小块长</span></span><br><span class="line"><span class="type">int</span> cnt;<span class="comment">//阶数</span></span><br><span class="line"><span class="type">int</span> sum[<span class="number">40</span>];<span class="comment">//k=0时的块内和</span></span><br><span class="line"><span class="type">int</span> lensum;<span class="comment">//大于n的最小块长</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;r||y&lt;l)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//超出范围，直接退出</span></span><br><span class="line">	<span class="type">int</span> len1=(r-l<span class="number">+1</span>-len)/<span class="number">2</span>;<span class="comment">//左右子块长度</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(y-x<span class="number">+1</span>&lt;=len)<span class="comment">//查询区间已小于或等于最小块长</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1ll</span>&lt;&lt;k)*(y-x<span class="number">+1</span>);<span class="comment">//(sum[1]&lt;&lt;k)*查询区间长</span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)<span class="comment">//查询区间完全覆盖当前区间</span></span><br><span class="line">		<span class="keyword">return</span> (sum[u]&lt;&lt;k)*len;</span><br><span class="line">	res+=<span class="built_in">solve</span>(u<span class="number">-1</span>,l,l+len1<span class="number">-1</span>,x,y);<span class="comment">//左子块递归</span></span><br><span class="line">	<span class="type">int</span> l1=<span class="built_in">max</span>(x,l+len1),r1=<span class="built_in">min</span>(y,l+len1+len<span class="number">-1</span>);<span class="comment">//这里要让中间部分与查询部分取交集</span></span><br><span class="line">	res+=<span class="built_in">max</span>(<span class="number">0ll</span>,(r1-l1<span class="number">+1</span>))*(((<span class="number">1ll</span>&lt;&lt;u)<span class="number">-1</span>)&lt;&lt;k);</span><br><span class="line">	res+=<span class="built_in">solve</span>(u<span class="number">-1</span>,l+len1+len,r,x,y);<span class="comment">//右子块递归</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_length</span><span class="params">()</span></span>&#123;</span><br><span class="line">	lensum=len;</span><br><span class="line">	<span class="keyword">while</span>(lensum&lt;=n)&#123;</span><br><span class="line">		lensum&lt;&lt;=<span class="number">1</span>;<span class="comment">//左右子块长度相等，直接乘2</span></span><br><span class="line">		lensum+=len;<span class="comment">//中间部分</span></span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	sum[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//k=0时，f(0)=1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">30</span>;i++)&#123;</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>;<span class="comment">//左右子块和相等，直接乘2</span></span><br><span class="line">		sum[i]+=(<span class="number">1ll</span>&lt;&lt;i)<span class="number">-1</span>;<span class="comment">//中间部分</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		len=<span class="number">1ll</span>&lt;&lt;k;<span class="comment">//中间部分长度</span></span><br><span class="line">		cnt=<span class="number">1</span>;<span class="comment">//阶数</span></span><br><span class="line">		<span class="built_in">get_length</span>();<span class="comment">//获取覆盖0到n的最小块长</span></span><br><span class="line">		cout&lt;&lt;<span class="built_in">solve</span>(cnt,<span class="number">0</span>,lensum,<span class="number">0</span>,n)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 时间复杂度 <span
class="math inline">\(O(T\log n)\)</span>。 ### 证明 对于 <span
class="math inline">\(f(x)\)</span> 的值的二进制 <span
class="math inline">\(k\)</span> 位及以下均为 <span
class="math inline">\(0\)</span> 很显然，因为 <span
class="math inline">\(2^k\)</span> 最低影响到第 <span
class="math inline">\(k+1\)</span> 位。而 <span
class="math inline">\(x\)</span> 必须增长 <span
class="math inline">\(2^k\)</span> 才能令第 <span
class="math inline">\(k+1\)</span> 位更改一次，所以可得 <span
class="math inline">\(len_1=2^k\)</span> 和中间块长等于 <span
class="math inline">\(len_1\)</span>。由此我们还可得，<span
class="math inline">\(f(x)\)</span> 的值发生更改（在 <span
class="math inline">\(x\)</span> 每次加 <span
class="math inline">\(1\)</span> 时）当且仅当 <span
class="math inline">\(x\)</span> 的 <span
class="math inline">\(k+1\)</span> 位的值更改。如：令 <span
class="math inline">\(k=1\)</span>，则 <span
class="math inline">\(f((1)_2)\)</span> 到 <span
class="math inline">\(f((10)_2)\)</span>，第 <span
class="math inline">\(2\)</span> 位发生更改，<span
class="math inline">\(f(x)\)</span> 的值由 <span
class="math inline">\((10)_2\)</span> 变为 <span
class="math inline">\((110)_2\)</span>。接下来考虑高位。我们发现，<span
class="math inline">\(k+1\)</span> 位以上，连续的一串 <span
class="math inline">\(1\)</span> 会使答案形成“若干个连续 <span
class="math inline">\(1\)</span>”的结构。而高位连续的 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(1\)</span> 的变换恰有 <span
class="math inline">\(2^{n-1}\times 2^k\)</span> 的周期性（乘 <span
class="math inline">\(2^k\)</span>
是因为要考虑低位）。可以联想一个二进制数的不断加 <span
class="math inline">\(1\)</span> 操作，观察最低位连续 <span
class="math inline">\(1\)</span>
的变化。以上两部分结合即得我们观察到的规律。
这个方法被喷飞了我不能理解，我感觉很容易注意到规律而且代码实现没有那么难啦……</p>
<p>友链：同机房大佬 <a href="https://www.luogu.com.cn/user/1411149"
title="yonghu10010">yonghu10010</a> 的<a
href="https://www.luogu.com.cn/article/2piluq58"
title="题解">题解</a>，与本题解使用相同思路，但实现方式略有出入。</p>
]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>pb_ds 简介</title>
    <url>/2025/07/04/pb_ds%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="这个密码看着不太对。" data-whm="这个文章不能被校验。">
  <script id="hbeData" type="hbeData" data-hmacdigest="e5e09838120de9718eeb9d008593fc29200a8c42fba46509444a0c652b64426c">8ade9e8308e767f1a274156f57751d9a3f5b26898da3a0bd68eb817414d883a079b01c06d83aff195d034fe3e1dfb14cd836a9495008b96df4990fee0de4a1f2dec8ba03409cf72db1f8d7023a5cc9024301d725ebf0d2733d54212d4150a0a2bc38b509dfb12f541c6c1edfcf0c21e45dc0003bb62e64a97572121e2a24ea4bea2921031fcbdc5d024132c89e688ef3fb7827a4a82740c79e07e2c73064902901e3e920d5534cb4f4250648bf734276455bb003e7594d0de366611d6d709a4195b985c90edae738b63d9f9903eb64c2757b14d311e3690045f6c23660039ed364cd8fdd74ebc2c9e65d3cd349a5ff9cd2da51db3c2925da3c2bba6efacf67e4f9c0f8b380c5546dd91cce76efb894ef7de4f585e02c609b3106164459be49badc4092ffe4969692d60707a6173f6a077d273938c991f364419ae9ef790cf9ef207fb0e647897ce6cbeee0f4d06c03763f877daf02e520859a74215333c5ea55e622a447a579b609cf59eab7dc3c9d6e098a54d0c33f388f5ccc7363738d13a4064a59e377485b0bc823a1de22b0546a514ffc4e674f22e9967ad0b62502a49b66d9aff59501566c8d090042b512f2bea1d2902e9d420561c75e3ce9f4602dab226b9fde7df215a5d7257e9700f16ed98b1a39a55a486e7c0dd3c205b059ee1686275f82beabd101db25dd3709ed7c7663025a41165b96d17bcbe5f4ded4d257edefdf7cc7c6e42350d07bb47cb2129c1ba13735d6800c1b8e5b06e138c1c17565c185f32c76cbe1ebff3d3248d546b9828c3566f91beb24df4c9c18b2081b9442a587187adeae8e37bbba2c4d7e3919c500bc812a74f5e4af58f608eb2d6f8d479a3948adde43d97bf643d4dcd35643abd76a9e87cb86fc55254ac1af1ed9a9923b3436addc16b8323716a08f2d8c18f5f2ad9e26604d44339a817d56caf8b1cefc912fec9a85669ad013c8ead9d7200d6988fe50110dbd282ad117e1f1a6e5f704476cade03f657c10e890778b86e59ef960811ef40b11fc014453cb5c053f7427732524ae547ebc51c1a7a4adc810c92a7a597836c45a1d423ac08aec41d64a75090a1f28ea498f9f3be5eb7eabc0e14303965d330f624faf1f94367104af88282d0f3644ec8ecf1fb9f30290766d34f733305e1074f5fcf2709c36e1e4cdb69048300ab1acdcf69d9a533a8c9c5bbe2a2d1adb78c2dac2e763a877f6644cade9ca90afbf3ae6bef0935bf92974c8c21fdefd04a45b12ca59319cfc4ed5a5c344e1a9d96568a6e6d53b4819179258cf7eeb809e8728d264290cae4f55a51f7e9ddbe0c7d2e6e61037cca62c129a7431c26d9e1f299776639a3990378b215d35429c1fd05cb23c21f4200e67758a327f790492b8af3f55e215c38916e3d501cf7bfd1e5e1276d09bd93a665b0c46862a534e22accf3cca42c0dc6c4183270df806629b1b83f46993095ab52971473d0e4aa65b20e3112568f37e1a3dfcc76a0fa3f0d0a17d9c2e1305ba7dee0d4cc88b0d7016684bea62fb1b5be695a539ef4f83722c0b56bf44eae344d452b34413db0baf7829769f7738e7926ad429947c9027c0223ff4b4031aca8cb65e01f1281bc6012ef95e533aaa75789cbfd869976ac046aa53536b392f70eac20788223295f142535301291aa8479fc47535ae4af582ceea8b2a83de1e93c7784572b864ac7a5b003225e94271c2a813eb1a93c4d3157ce82f75de9d0c18dcc5703b68faab67a075da12bf14ab8eda6bc76e967d1ff48dcdce9985f718bba604b0d10f02faf6ddf5a1b0348dce22d8978f56161a7f5922c3aeb137a89c3ea01faea663318d8bd708dd71a05b7a6ee272d2e660980f9941f504da88e5b8d8f708bb279b427454212e64a0ca4e6e665a4689fda526c053f38b86278eb451502c0bd1211bf5b75fe235304c14edd20854ac98c9afdcb25f573aee372ffc3ee182fa10cc7b478fba5efa09462ae6474e4b443bdc942b21d098a16ffbcf3d0dd059670d61829c98b15673f6969dc9433dccec7a26b4916ba18cfa10d91d0eaaaea1275d447d1bed6b235cc8fd6fa695e6e21a91e6b3051d59f169d59a93d8d96e587ff53fd6f442235e4f62c593e2ac7ce55d32c3b2357fdc706fe5258903c241a3fac5437d9aa627f455f6f8b8ea89296d7706bc234e61f4b8fbd2309d2e7b251f15d6fd5775ed098e613b78357b0c5e0280f98e71a4a4670f01115581a93589123ae5aa38bd503fe15a0df38ff1f7dc9106f344476a9e90dd47d2add0d3d380546c9ec99f7f93c5c499b0b3297aacad7cd19f56d90b7370fbcffb2f00e9e6f3cebfe2b6a932840581ba7caf9ed90d2f3ed4c76be31baf08286a56428310c88dfc50498fc3a618426fb6d5f9a117a0faa4578429a61129e0ba44de5d5571c610685848c2ccb1ed2e9b88e7bf2a5beea50d56e0ab7b0ab09e61f0f8110fe986e82deb72988c280333de2039880642a92b2339b3958a94eabd98a1e9ae27252f224aa8d81f26dd5cd614af1883f55fbe05d1987c73bd564855415de6928e03897a25367b183e85de090d4fcbc2bac45d276eff6eabca155d7d86e32da77e9a8f67758006732bced3ae48a2cec9a45cebf81274ba9264f8892204878fa879d4598fb52e044fcfb46ae89e0421d0ae77e3200c25c3fbe72232ada8a68a73c87d2ec7e474b295274b6fe27ebffcdd403e810fa73ab2e1b3ada64f9bee7fde469b25f308d2d95418d6b2667d8cff28ec69db9cdf0d77731daca72f26b35870649a58307c6c6f8f8dbca9d66aef7ce760ea5ba66eecdba30fbc416859eca217688137b2587751e5a8fa9e38e293b21f12dd7741633ea60de5e573ab31b1b8884e9ac3afe081f77411218013e29e0b0db328b88060b6d1ccc31b62dbdaec5e7ccfbeb4645cb265e766391d8f30490f72f10ecf168b720752ad64876d207a3d0b902a63b04761cdc61e742621eb70fa969969a6fd89ffb0f4deeec2bc65ec325a1d120189fd1e8422e130e3a158be44b92dc26c75af55186eaba80914bfbda77642dc0b8355afcc7af6b480d23bb37de45cd80efc4670fb8fcc1b93ca1bef72051fc83a56dc98b191e71266ea51efec28017c0cc871b0191f13e8d8da8a77c4615220a3e2f376222a99639201ccd2c6d3ccc165f213077c827834d2bb12cab1d4b05a8cb4d8b522fbd90a7fb414b01b23a0f49ba2608656d792198c059f7e3c95a8e37dcc25ee9bc4f2382e571f18588f241f6d39e8f82f5a0bc1e395876e0694d340702bcefbeaecfe4e2f02504aff0be7c3d7aeb338b2802d4aecb48ae9be328006c6531622f1fc76eb61e8f8767f3575eb0607d2ace032af72e831d63fe71b9b501facccb28600a24dbf8353aa5d9c04d542b34763a6fe08c18141a49c46a3350434847207802f25841ffb4c15ea26885390c691fffd1fe36d2e520020415e55898fc29905fd893ef5fb8ae340ad47eeba28649a01b8e6e2bfbae87edbf470003d89ba439dbd9a917edf6502390d88e08420cd10319e82b8818cd9749b340a635d90386e38d47a94c72278537c48f104ff43292fe36eb7af0be9d4ab40ed1d124898b6c23b924d1d7fff7e674a8509f50dee7023cce41284e2b1f585bfd93f1f7f1bb606a84306584bcd929b2b4c116d34f0456152776193983bf222fe640af7ab1d8940a5824b3a0d6c8f955f572231871174f97056a7ccab7cbea4084067ba620924ed69f4f269a99eb01087ea4e98301f8c8f743261ff020c8b6100cbc3b3c2a68b3698003f7eb8dec1594390670dfa870f2b55d454f1fc7598acef9aedf437892a3fb77759d7c75978b00a5f1642d775e89e1123090ee023e1dd57050db45e72ebfbbe5af16f108655e1e55539bb2c82833424061bab9bcf05195c2582f9dd6a4c0c756c01ebef8a033d59700b6ca3d0e46e654a25173c1b48c609dca5600ec434b028355414e7f2ae221a2bc986435f7aedc23573914a1d00595055d47c455711055423cff874960e106012dae79382a473621baaff6b4bd3318d5fe36723c57ed1079c68baf66f27ff8c75626003b06fb93b9993e95bf5c8d47b4d399a2d5155f55b7dcf1f32e6fe19c30f41453ff6a7b180f8b69af1e1e6361f906e636834f51ae6aa467ae6a7c849893ce63dbc05faba4b760ed1e404e63c1a5b8c12befd40d837f65496c9758fcb78373c1b5de005b6a67dac44a4870bb82ff9e92f53999e149ccb3eec10e5b946db817b8210aea4fb74b6ccb91ee6b43018b5e19765823a5e9db97a22908adec6d507881e803c8267897ecc89b6c2b70d6e1a73c1290f82dcd972344978b24158094467fd11a6e55180f5be0a93e98ee59cc4722700e81e0b20ae4723b4d45937320cee17711fadba604510a04e50a9f022d5cc3926c33b3ee82de6dab1b51dbe892312cd34e3330d419c21af14e1c8a1b465d7e64c9b676e5dc205974ef9b2131684a875294b5a2a135667026ae3a7b326e8a2d01ef95b95490670709e2328157c5e2fa884158b692fb50f2e31e99164e2c5a6e6416369eb3b06c03e28725d9d374091bed3eabc6765681ba36b7c705dc41fe1c1f482bc0853e06a8817a8130eb5e7fb5b8d32ce47bf0cd7847965b5211df37c0a11342c99e164f8cb10261fb13ff4a2a4665654f6f46af5bd4b3de2f3e092a1cfb4671a34ab9d159b167705d0c2332009b47e1cf5db362591126f0eaf85eec5feb7420c74ad92ce9ce38d879f4f5228d8de34ecf03b27ee66047e8f9a98dfa9261b791fbea21cf05ea9b207082783ddd27ceb2fceeb11614a0d77bb86999ef37197ee9d6568c81feee2dcd6fdf469199a29e91f5536a5320109f7ebc15580d8e554894371a2e134ee0183fb868469e7c5ebdbb781774aec3f562c5c1c136374f72a5ffd7decd2c39c67fecdf244686662eb44e6a845e4df2fbe9ceb5e7d67fee77430e88a55836b3fbdeb9d23070cca80af89bad4407efaa9e50f665d4bf06d5b794c0b0c255e0e2f9b3e462741363e88f93a19a2755fb7223cdf5f4eabe87c7f088cf4265b3277509d339401d33db810d70f6db38a747669fcf48b210360486d7897ad8fc85c0639c64e6f7f1e56ce3e7ffd79561ee929064618ef7770e92e688a07681abd3b274193b525448d5d4b9bee344b534cac95b91b8f8cf185f6fe635317979861d8dc878e75794f2f850d5776c49c885b03417f60872a0817c12a2e4271a885b85a60195ca92f53e977fef1df313bed38d192f11770e0457b1118792b323ce0e153947ebfa447e6b0dbfce0e801e1ec1072b73b88cf97f4c8345dd03069e63d16a264bf157c5c2e9107e0fbd7563d5909348591c37699aa8b6498e223730125b3f07c31ff72616372dcab7741bc36c6ee26c923a90bcf2ebcb7019846d4b7cef87b4225349f988a65e5763e6e58b2a3a57c35f9e819b72ff7120971a15e44b20bafbf4342565fe79a4fa008342fdbd30da631aea626f2d96558d8616e82dfbb0a40da41c4304cc93d06d9e26d7c713bd60b35526636399a400e20ebd450dc81e75e660183f395e82aed3dad7eab40b626a795c652e4e6ea6ffbfae0b5e241d11346bbfbb1df5c11851e2551d6c144de3fd37a684d7e15ef816cb6c5789d94d588c832d66a02c7a32598c8cb8473213e4b2049eb94890c10aa227cc3e1e3c8aaf57570ae40189245696f847f97242ecdb976a99071f05cfdf17845b328d71e636a1a88b15650ba2fc444d2df9051b02f224ee085143259e2b3944cea99a2b5129cb243982d0e22f9428d2a03bcca5e1aa9782bd81fae11a0aa9934fa29ea9fed13ce90c1651e6416e025ad0284b0827bb42b98d658a5d7c7180a8bb7c8b039919bc3b95de23147acf95f5cf74aade1fd636500a97fc0ce6720697145955efce8b474f0907040a9f7418fa97f22aa67f13e17948571353630cdb2f7f0259327d5c40513160b9178cc3b1622d80064a975b92ba43fd2777f36ad98c12f0aa9f3cb4bc300659516e5587fc8c16e51f18df19ac5136c7bf03415b89ee756ce62823cd545923577ab9e81e2ae0cfcca848968cca96938091fd2000863851fde7c3616366518876f91e32960bb42d71291d92a128cbe652be9555e3bbb166474b82373e941ace6d90f9a5efbf8fb644306deac5fa3b7fe7d78aad859311dfac77628c20cdbd42401fbfc3c8f886b0e1dc55eeb071594144d3d71bf17932b638c3007d1e63f81ed1da885c6b2e17e09ac3d6e02a52fbb6b91caa461fa6d003db24c740655e7ec2bba65a54c0d786f92b4c2024b65be7bab9944fe95184f6dac29c3f914cb0fec5a630fa9a9a0aaeaccd2ac6f97c723e3b6ec471973803e3fc81502077205a6e5dcb7a70fecd25485d76cd1bd43e3f73af5ba73ef54f134e185c322abfd8248fd6f841ec874c16c04d27bc860214682e52fb214455369665cdc39958eaa9de42b9670533374f0101dcefb950fe0231ee50bc9e5629accba46d0cf6b02759372d19c419bf31dc08e9cedf400334e1d0fb1303da1a0414b369928235387697153c7f657fbdcbe9ddd622cae1b7719771dcdbd31873271fe6fdd32d9922aaafd8c916bb5c098694344c6c64de9f94f11900a06dfc9f942c1924fb3c68f2106dd4ff425f0a302c95add3faa33da5fba91e15fc2e8eb541a9646e5b606062005c9be4951fb7d17acc6943923b40425ff64648ecd7bc2f87f0a24c705cc2e531e9cc85caa82cb7d67a2fa44e9825ed933b379158eda955bec18b6c37a44887a331466ab5de1a40c215bf08196e672f86cbb1635aaf94bb0f85046e92e11e5a8c4c6f29ae9d27a17cecf84bfe7c0421ad9199727ef99b666cf587901e35047875a2df92cab724d64bd2bc260a0a30a34164f725ab1f6dbc9943a859a1bafe43c77d1921767d1f0026b9214120f511e6a4469c2bfcce5eb19293eaaa1fede3df403e7562694c14a9ac6d1873ea479fb09779d8e87267cc72b6b23c2d3725b5f4282d92126ca3adbe3ff3f6bf680217922f9e1e05bfdc215b2472407cdfa521c0506ba5d5e263a3375f63824002b3ffc47d552deaaa86c9e5aeadde3ac9c330f296841794531a94077020184531d49f4c0ef00b290960a5fe240a144424a1dc1ef8f2d178c308b0ae53e395f045ea66a4f7206a6b88a3ce7ee462615cb3974e97a9167891ae8a200abd6217622646a4dd5c2dc02794248ad5e824c7ee7104127abe2aae37845a14d6e12b6cec2771148c52ae1e0b0c02c47bb481a2f92c0c6f555d424b7869e55aeff9aa8a82a0ad1c7ecdc9bb09102ded61e8638e87f8a9caefbac67171608edf71ccb9f7d5a001902e713e4da0fb8d09e158ca87e4883a0043e351789bd5bdd729ad217556cb5dfb345cd7fb36dbec1d4ebc15221fad639494af41ef964f96ab878479c3d0c58d9f214ee77865fc6e19f7ed88d65c03e680162a51646b1a322d5b9b7a9c58fa6bd38ed4c6681b8b3827c1edc8f3cac66eec90ef22554c7aa508190f8a6b83cfc710dfd09fa6144967adaed915e9425e543dc4347b6a8b43e31be6800109ffd57687831b4d86c3ac1f07e4df6596472049bf4e2e6961b42a50d6253b6b3eb9bbfe3ac81e7fb2dfde75593427de3639cb1a579be6dc651da0053891484a01c3c480bd6bd7ae7ef430356d8d0fc3286e7a5abe22b89595db5588a23b6d7cd0ed847b5692e3d820db31f03e047f8c938dc23386b7198c52854dec9543036b515def3c242905427f0884cd82221ebba948bcad0999733099d3a16c9d25f6c7ddde11baa52163273b67d3a76603ded54217ad3a6ceb1606075fef023370f9a9a948c20dd39e93498e782b56fed2db618ae630b6424868c0380bebbc12ea4a747f0f112556e6adcf9b007848ff439a3011702eb3c79247f9011d652ee41cea621ae7387849b2d35aafda98fd9b747ec874dffafe2c45e19f07e64d2e1ee494155d0ec27e691cfe03c96fa28234f5da6426b865b50b98ee9dbc711a07028d7fd0ac1aa417c57a5f0848042b620e062590c4c11652a09f5bd090849f6c5af3cf611c7a43c43e324d1735b2e0d49f7e46781f3206f9e378c7222a31d899672be1e4b38b9a79590ccce6518fe47efb1709fc1f2b3c51f5fe2612b28dfd2b68f7e3dcb5dee05e8c86937e1b8be63b5f71be58e05b108e99ef5415d0845a5fa5728236055253024e7dd8d85b93cf80a45a7fa3e0e6d1068728d4428b99c17d25118e64779c87df25cec1c9769642a313aecf48992314a52a6ebe0c9e833ada1354a8e9a5f814d629e95a583c1b5f40e932bec563ad1b461d919850ae00e50b0162687dd131c068f9e729e58f584dbf9f21fae57ecc5d16672c2866e153ed076242045d549405b5068fe6d8919b94d39bfc0dd0fe144bc6044cbdb45213acb3b3c6fe90d514e9b237f68f8ce09ff71b6195c2e36605e4ae916188468146def8ca73f8bc9894d4720e01b3808dca6b53486aac6f0675e2ae2467ade174f17a94f35e4df0fb08d5faabf0dcea401cf14ce3441960cd566bec1e7ff279756b6b860d90722d443640d838bbcffb089bd7fce37f6a038ace0dad883fb5ee2709d1dcbaa3c8238d0ea98ce8e1664068949478558e21c5491fbb1b7fc40e2ea582cf7df291ec042a96c0167cd2cfd049a40fc392fa0471474633caf7e4a07262254502578ec1e85d09cf20beafac8c5957e1478d2f39fb550222328dc8d8e86279846e698751ee86c51ed666978f44b16f37773a07b509e8efabd2a1fb9482de2305aacfd31de8a8fb3cb3133d542174e23ba341713c856d3c51bff039e39ddca778f15217fef4e452e63c5ffa3f42efdb3798c26f61048b4d6c45c3f57b59eb5543573262c79659d28b60d32a1feea0d1eea76f9065796c7cf1267fc576828e45f1fbd0172cd30f83499d3a700022b8fbafd77365aaa25a05029c5ae8f939774a4d839bc82916815c4f07fef48d833b3c9c44ad30a00620779d4df6cb391c8c316b56c9ca29ee99152134b880ea7bd4b3b80cd07fb63b2873c1f61def23bee403c17f164276d311a59c9de24b98a6b2ac4656cc5501530e0715fdf1b478d6c06ef0cc4678fbb73319b595fdece230e28f71a20a95e893cfa6ca1a41b49cdc77e6f3295598445559640efd7a9a4e5051d1c1d8e663f4b313f2a73f4dbdd58dcc4ca4ff9cc32ba17e398000be2c27276321b267f8048f6127799cd3efd3b786de0d6aa06679819543b012ffed7cc4507a7d14fd2e796a0356a84adb7833196e01328df4357f48d42762be9830d7e078d6f3995e8fa3b90e18fce3e2180d5144f97bb131a78c893c93f0640fe785e9d75f1b1dd992c9c0bb74574fae558c4849aa02e65c39d42b86a703bd57791a672d25aecee982fe3166d22c566598236f4b9fbf5223dd3309b887a1717e8cbc53e7e5f24d70ae0c45f1932b15da546318ab844eb6af5d974d760786fe78420042ddd2fd7d7ef75e113959fb65dc89ac83cda6efe62d33e09d472f8f486f3a1a5a5dbdb323d5231760d0fd4997bc260cd1ebe8988d43883c71ccb866ba27c70f0baff20e0a7799857e677a4fcaf0ad693127e4196de1a3ec0b268c4f61c8f0c60117600c2b0700450a7c6d03302fa3e70d1687b0a8f298a6e845dd7a382a5c5f32e1776c3e298c4e297f9919966521457ee0bdb41c24463d9b5e089fab9b1d49a41766f274dbc0160d3c3ba7e56f877e95fbca520b8c93a031ea42a4829a9d3d39edbafe4f32145ed20d8a4cacd74a56ceda2d2e599eca875155147d8ad2088ae0f75d6d2e256d12c1f420fd7f2540e806e1ccbf819118b43f8b1cddd56af8e2d32867a6284c9f2627496e21304fdd5e98ac816a1beaed9e32913abd96f4914dc1df12dd1c02138ed189cec51f1c8dd16a8054368d14fd56925887c45e4cc7267487c80152dbaa40be764e2577d4c3aaeefacc67f8afe4e4b6223d59994799f8fbac62dc4124d9c7c3d4d1fa0fe7c53ea0c50c097425962ad97acc0ade77f985487ff9454620d13365ce5c26f952daf56c4de387b32128a34865966342a93efafb83571773213a1c97a44a10a7ba7a238d637faa2a652ff3920aca71b7d9a6a341ea8ffa7a56e720543708aa663b36ac9bae910add8ea8a997a6b4b56dc00a69ef75662efc6b2955155d37a8989f76afdee6fb1d56957b95d905b831e702f4318c9e56ce0689bf69315885f3a40703c5c5d91bfc5143d5e42d004ded6d4619bb3e767c88da9847ac67bad1ada3a3e26a74953c720dbcf8b38c8a719d162b5c410c9c66e43bf04973c124db35de24dfc5ab69177677695a7b4204cfe046dae7737b03462c5ccd6dd6ac2f4d43594ff737b7e7115b8b0c2f10501ae5746caccebd458a35993e81ae8858d4f6ad8f7228be2b77703c80222871a8d2589e0386d40c6f006b9994fc4693205faf01c66ba3111bd69a0c2a5bdefcab093f5a76c6e30ddda694c5dbecac1fea837576f917e2071739c74e44422db342ffe80a513e3bd8543d6cdf5848d19c97644735566c0ffefb82e6ea7146c911c54764969e5242695e983c5c15aaf2bd9ad5202c0508147f20bf9f96e1d168330a0bee9b4528f7d7cda6c899cd48718e5d65e552453c2b47ffa70a386b126aed507b3720a2c92e1bd85f3f0281f9d5c8a3e9def8429efd35bcbe73e9c6e049b9cd6a12b585a8b382b5c48210e322a285bff4b7bff2c5d6567e4d848f70d2e9657a4efd8d4968b49d04a8c509ae2b1418dbe0a3dd07dca538cbb01e553f875db9bb35e4fe57bb1a580b96a553429de815c6275e48682e48a81c93a4c6073ff30b898e76621c10ae71c5c71d9fc8eae7430d6372dacf32e430edd595277e84447224cf4e0f864be4a305632a3408515512be92d9fa8c35295da021746b40c3daf4725bf7b6eba1b147e450307f89c5cb8247cd8bc1a78edea28457baa0d59a4df4e64a305af899699ca6af3c8025bfb683d03322f320983725da22914981538cfcb91b05f3de21133b829fb50b0559b7cc407c789f666c3948e3234f4ed8587d5d5e391b49c2632bb6736228ef09fb3118838027de4799d23b3910b63cc913eab90e843c6642b106391f203a47fa7ae68a9b5025176e0d2a46ac5f95fe91a4ce026e07b77a88200fd8f73fa01280f04a62b1eecf0c03315b9f70ad08c1252615a8d631e0ffed58b5c3f2f551cf4be4c12e894446d293bae03e0192f38e023be99420b220730f2bd6c7e93b409f5c812bac00ee8028cc670dcdd7a3f92d2cdd6ea2e2271c50e4648624fa94de7eacb2666bd290f48547f3aede0548898c76f9617a5405fba87c71f2d777f7207ad2c10884c74c7b47c2944488f1c2d9853e1a8710dc0f385f2c979ec361ae0e5ffaf2eac7c6431a5bc1e659cdb2bfd9a47a176e68b0fd9e797105b5976ea46cce54e87b1c6ae30510f3916eb4ba989ee2419fcd5fa0102f58a428cce503c60cd149a7a518d055ea8c61fd06d37e05719a8cbaec971b49f1df73f0157296f6ec83d7d18cb036db3d2039dbcdcede63a9b56a5862b28b7199d2212c83d6c15fa94d2307680ceafd4b6955e0c8188d8fd49a38261c5dd6ee02aa22e8c133d04563e4e00fbe0949bcb50763460c0a837ba535a7241b7c07c7a20005a1774c7f801fc2b1a3cf1a164c05bedaa58621fabd2ef058036fd45884936d54f6c3f2ac24359c9faa5a15429a00a99a95a1b5121832a1a6e20552077aa125b195fcc747ec6aa3aa370e8b9c1d07310107a6d408b08f9920ed5a1c81c68d4d69b18925a308533f8e06356807942976693cb1f3f8601a11f49381909d523a2e78547f3f58f9f8278e9918d7e5f44a8402833fb533622ad669a37e4c0980c68f6f6924ecb52c965486c5266ae77ec435c971a3d94316468f4f6c738176b990fa944a08b1b16d021c972348907a596b9adc3e7a2d7f47083d5efb799e0d4d38b4ed68fb04c8d776d96320ca26afd8b4b44c253a53812cedccfab8982347170be91dfa361cd7f674af6e6c30b0164ae934ae344fc846df100a0502f465aecb31fb37398a4c6f6a91731bf2ee7b46366769ac1e8a97e6da61a95afa5eba04331935a48b18a46bff1dfadd00d68eb314efa3fad468d56a933cd86acddf605dcfca4b76904d1ec8f25dd727c58c5a8507c102b7fb4c54a32c370ce104a73d46c55e59be7099f305f16846fb774f21166cd9c3ae4b7c47c189deeccd77ba44c470ce795a162079d60104683a9e755ae3bc1b76bca7dd5716d235af11c27eeb9589bb54446fe03a78cc3a4a61ca6f63afb19fcdba815f45eebac5bf1bf2bffca14691aef235fa2310f55a27f8ba980b40f7f6e80bfe7621c7426db3832eb933b74b213c06b22045a9675284d0a2610dd6153d5705d73d5a173f8dafdd509ef68e4c4c9d78ee141a5dd5e3be64c0eafd031ac09b5e9819802e0d5214afba6c6c1b8367d78848fd39d6dadad761f7613a590915e287128a02ab71984c3e4d280d34d783c4960a9b8be575d8a60690ed8671457dd3e56630fda24954c999f89c5436d44a2fbec973ea65bb9aec29b46be3a21bc5593d4b251c896ed5802434bc934540ac96b93abfc2308f90d60d5ec8d9095d9e8253b64e31ae6ece56ba9f4e836152723789d563d4a9ff7f4d9839416c04cd19ebd9722ea45beb20598879bab12de44ec130ef482d11e4405b0577e92a39d177ef1535bbb2d7c88422f2cb9b20f16eb455fc616b92c14b4dea1fd6f644256814c7b815f0c8229220ba23d7684a2063509da0c9a332aaa6dadc104a19f0d24c8b499ca8ad2bb7e82ec4c3a9029e54532328f802d8bd2266b8992aee7ddaeb7be9a8d56004aa5c49ea7ea06035a511802f835193c5fed734bb8f85b1e7d47f36a8b311aee84fca8f092d8594328beac3b47d200653f667e8b71da4d37766d8e26cf837e08a7e2953daa0bc416186a6467a999a891c46c9538d2e27aaf1d383a14ddb2e4221d8e8d39d26a927d37e94b30a874836de1911ccf4a95c587f982f645ec7d7e74a66cf87a1a98a6c86d814fabab489f770ee28d67593a41a993cd87f8c77862cd1c962e6540b0c48beb40498538bf77d6200796dce03a79fc1bd0696e2a09c9ac4ae7644eb2f7392e8ec4c1d58932382f111d6266a52f39bd0d18321f07ba70c6d939a4b04bede8232025dcfc3764087dbf6763c2ab6206ceaa33b472cb5c2d988c92e88ff4eae21d7b3feecd8a899b99f8bcabd3c420e62a29c16b0ba22352f94e66367d38952e1395b8990c75a8e112730232da481f8a722981bff24ce88ce97c9487566e2585ef9262a60ce1518637f7ab298df9c7d93b6ee1b1bf5a5b58cbb841dbb76dc48a6341d9ef2d6b248683a1f6911c996196248d53f6d7c1f5314cc14fca5f0b5fb97c4ed086bc267f4dd235ed40a288d514e45ab319b5bff6e31e9aadf43ca44e97e1df64bf0842684111c120e11bd86d7558ab56175946bcb876f3060d7b8cde83227d06e025184d2da3bf0008ebc2fe34b86be5cb70deb591316ea93b24d9f3e9ba78386c23909c6e4bbd6134eedafa9ebd3b6ef9973187fc10e5858c43beaaf6cb6c00328dee23c05d383c3de271297297bd64e92b3fe1ffbb06a76830c8e107d25b7e61735242e95d40a7fd8d41b0defefb89b1f9523e472e2634beabd84fd1471c5d60ad657d05ec361881a5b178b9318637e8c0b3269c7fc776a1d22fc894e4ca1a7a50952b397f50cd0eba74ee33eb6b53c8ed6653eba1ac2c14a0a2782a13360b5ff51c0a3cdbb98d7c601717da350028ee34ef1efa7b6792cdf89fc526ce17827918690eaafa2e173dee36ca7aff82ec29f75c7478c00dd5e7a33fc86f07cd63d9082cdcbdc11892c797c3b07871864d696446d9de1afe49a14d8ffeebe8f052fb528f51a0d2247fb9b4c1b97cd5f2397238e5975182c4bb99e661f3c3a018c335667dd01e0e866dbc9004c6c2925344d4758548b526464db68b1c952e42e272393d031c75e033904cb709ab2e8c13c715a51ec0cc74b753591c4c2bec878cd93b3133871f1a605c7f9770bb6b62eb6e4f0d4c7b57b1eee07b26acf1944d00dce8bf63a4f8713336bcc7b353a20e5c9014fda148d5d82317cf46eb5e1fc31790b8a56f4693352bff3b71c1367bdd26495c322902c390a264fb650946f764be8b522b5d911c240c0ab159c08cc7a3cbed98fe9914f84b408efaeaf962d0b9b74e01b9a7c33aa7a273901373de1a4383b57f5979360f6caf69d1ba735b5005a9eae3651f65d7c2d5ff512d03bb4c881fe80a6d3fdb9d0732c1d5d83d2fc84a13a434f338c47939da1ba01d5b7f7dfe091b37ba8246c583046bd91f62449d02a50f4eae800089a8e82f55808be2310c7c6c8d40d603a7a7d60593390f286a5cbcb89f51e5ef8b2fc4ef95f652b9ef69e5871232a9528bc6e27a5f51ee5b7fd41a934169fb152f7827d8856b3e09c3e516cd4677d55f0f0669551c9e3b9e0007fa0bcc82d049d6af23096a275c53fa535b9bad2a9cceea29909cc37781048023cf0506e73278205cabad7520846d89f871d06051fbb0cd20805da2c7fc8393450d66449c12940d69fc1c7c9f9fa8235abfbfcb58e6650c6e9198d4ffe71107c3ab3c61826c3b1ab403dcaf9c186a39ddcab71275170b9ada851e6c379bd4ed6db9685ef0f646ba76cc2222c44136d6f572fe518c2c05e690bd4eae73c0fd1a53e9c731731ac54914bcb91b32ec1780c95b549b6f0f5bb985ffca5793b72321291a1ec4bf96550e1bffdd99d62cc73b80aca75f7a30ed9157de08b34243774412fd735c1460624d13574579f1f8128b3f8e357694b136939ef406f21f7de6922451a7727f6f3dd10d846ef7d2a1b7d8d60ce3f56c07a3f06b220f3cc9e4018ae84987b879ebb20eb077be6a086a6664579620e173e26a08a32d13927514aa1f0888733fec304ae49a8f9168bdfed6f5cc47afc1c0775d1539ad94cfcb6e8c2a989e4c9486053e7c9f5a02f8ba91a4c96d925b28824e60e26f891717bbf31ea469c6cc68609154f00247c80f37d4a903874daebc96a09190d5d48db0f1c7da04e7a9e101f6d365fb36d1e2f135ad6790773ac250afd6628cb1fe0362beae6bd86eae7734cfe2a037d4a4828d5dc338f21d87e88c955da9747f7950774538283ca85c368b789e2b5f5311f78d7ba604c5220ecf87ecb21e675cc7c7af9bb3dd765acc22b81f7ce6eb46dff30171d854505e6f2fc2a592c9913256abe6a62eed0879a4b3cf7bf95eea0cf0651829477bf21b0d688ec82767439524061163a9083f006ec876d1da2b8e7fed79d2a4ce4dce0a3de1b7aa2d3b293a861ed918a54979da0d19d48548247fc4c921c6de7d9c034f533b85738d9759e1fea5d6edb2d2b874f3a9df5c153bfe0e4fa61cf46c212d34de0c9c474acf70074f3671be67582d8c00e49b42f0e7d17c22f04ff702e5c0154f35dfc008b88d9a23e6da7c7d3fc448d417db1aab4588615e928220d92cfce68dd6fd1251201a731b7fc8691a4cf70ef2b15641034e9a5f4127f86cd17cd34838628353a32c0073aa0075c2371dbcec0c9e1eb0f8c1373f8685c08cd0faa6a8578966667bbf59fa1f8869062b7b8c44dc2bd281ce9cbfddc287f0f385dd7ba0f6ef5fb67182b0ac875724ab223cde05b43b9228e4aa61545532619372a73138bf215aa44200f381a0515b585b46f12fa6819fa8f3a0ebcd997716f418a3d89ef85ebfb36f733988c144c74141435013e5c178ab1ed8204a88a3314db01f85966b984a20d979586ae732def6630acdd1995230c1c4c5fc444613d4058a257eff55e7ecdd5c326cd5886f8bf1158bc08c86f3a00e547b49e56ab2c4927efc17d535c2b476f9fb7b47c00316516e33ee43299d3863051214cae25be9b12fbf995fcfe1a97aca4037cebd8a75f5890b1316bb7145ffdfee67ec8362d10fc0dc2e06dd581999ccbf94b7a015550a0d8342866994a3285f91bea843be6cb25b2f106a701d83b3bd812ed632ce789215e4e8d6fe37402e53262b62ef26e7490d71f9d67446b2d3292cec3d4852a9b014f6d2297714d603de3baa7257b1ddb69863919856483a7142586074e45053949f8a522df46efef516cbdf690906a3b50517b361504d0c3fbac8f06bfd943a1d8b0978ba96451402cb0b59575d9a1ee80fd59e79d5da09adc710aa4bc32fd9789ed3b8de9df7cceb80cbb7d89f2fee8364a95f978ca58deaef2af0c0d1afaea5ffb5b3a6440d08e51cdfc218e3e0cb278d3da4b024421ddac5b69e70a19eeea2ad0445383d8b7f9d02d37415206c8ed7ea72bb73146b580ea7f71da646206ed78cb26fa423888f52fb896cea7ce5fed855b0ebf65276b9e9689d0f2ffd9fd7a9926227475e3479f6abcee0861a06f504eae90e9f4dd3a66114f61de0d4bd15e0645a8debdd460b2cf4c59664bfd844ef3c146add5637c3cd317ed3d26c62ceab284b4a0cfa7b6d1ba8844e301cc524e2b6933e2308541d3d407ed8ea70f10a0efb1d63a538cbb9a8cda7f835c107dc8a45dae834d6e1d0f7953028369ccc54b2d6451c94e795bb34f87c63b5e1066b5d26a0016c117ea29909ead6a15fbb0ff5bcc6cbdb42ff8b5ad0e9f9f790e306198c9cb274b19e759468b4e641d99853bd0e91b05e531645cde582e2e7cdc210626292ff29a1b7e7f0dedd062516e705b2a09528745d77a72367d9a1b30ee848ee45e2c25bd1e9ab3eed1a9c1969636b3c5a8a297a854f7edfb078e9b114f0553be0c4ba8f3899e0cf4d1978176639f68f9ec45782a40523eea730bd373ae89ed884398354c9500cddd22434889c726265e84785a582fb4c29102a3c00e2fa1eb39a0073b04a9e1ea9f380ac62f795edd8d2bb6b2b344a11c51f47d917c2c9b081336abfcd7ce32ae468637fdb5f47e9a10eaafe4fe4fe83cb692702b5daf26dbb2918b23e9b7def6eeee1085749360f0a39ecce5d425e678763a9a961edb9247b8070f4f518e6a155ff555072ae86371dbb78d17f1f7c151bce8abfc334e96414971f5b1842afed81d4b5721937096a616b4474d30e9338cb827f620abd5ff600921bb68818a48afce253da1beb3d4076056a002b1df0a6441bd79938e091d820aee5066bb69b3b543a6d6a85592e3235cb6239e9124e99eb94aa9a9d58c20e26b20d45a8438bd6ac7d02f479a0fc9da97384d3e5fcc549fd098c0ba3b529f2ec0e849f7acbb607b377cb620fd05d337796897e4dc3beaf6a214797250d216eb07282774235674cb9144f239d713bb98dd45865ff7ad5b3c22313952305d2e61ff3eb21585a1dc30e1428fa64a39e1f82c63f42d6df7527710ef4bac5753a9da0f3b8936f0725169e06fd75771bc8f7499afac0a81fe1c58381dfb3304ae5c80dc00b5ed86133a26a6c2f04434a6b8b9baee4187c557346b3edbb43ae991096fa496c5e1b28e6f4c73b9f34dd8b85a3b00d37d3334f111d5815300f70de645aff61c4f433b23b5862f4f9d66d1a1292a7594f76b97d954648127acf477a24279832fbc932930291478ebe6faefc2beabec72a35f6a560503058132e45e059836e386433e42be4e9938787142e963feb9e86a9bd25eeb4d4d14a87d292f3db8e7d3dfa738ee3704e55cdb0f9f31ea787e86c75fdc02a1caf8aad6082daa2a2d5c85eeb7c3e900f1c27399a2ce6f845c542915e411dc67652f5c3d9e01298e8cc8bb36afbf8d28aeba976f4df72b4bd9f1240e664696e1b6c7e196af79e33693f4651a6efa8e07ef481298f9059551fcfaa644ac1cfe57c7727faa1d710331fc487a9e966396f9adc172868a811d25f0fc78019b8bd05508c86750649a2e61fcf8929de9715cd96e98b8ac3217fed748965e3e11ab2d7465f283ee340fd52d3109962d72c30327cf353cb656f76d806478bf046168fad0ac541099f9add8e7e2829ddd7b5706c707930f38d369ac2d816bd05a5b5512268ebd4dc9c3d168f45cc411df79e1d19c0c38dcd731eb11763ef9f518854c350e1e6d5c59dc0e0a6e845bdce0aca3a7779d065661009ec1437d07bc83cb5b855465a629b62a6c8391ec19be7d33aefe7587719369ff588b88b9796ae44cab178eae13ab0d814b6ee39ea132e537a924cdaf58864deec0980fa9cf90f80b0cf4d2a11fa71cda31aa4af2368b1f277aa6f49cfef099cb4b3194ad8f86d6664ca0e24690c71b4971cad19646629153112e6aaba9be98df03b0a9cb790e7c17d24457cbaaad361b993fe5626cca91cf16ced198656032ec9ade019b65be07b69c8f289f9817d1655f41c64ba1308a984f173389cae581b7cbbeb28e5662f3f876a7e2b9b24ca0ab29ac9febe1d9c1bcd8cdce96c2b81262f2f0a6e48592f828ab131c4c20ca97d9517eb6a708e44d43b65850269d636b6ad186a0e7db5f8f01088b37cf34dbb647381a5197b7bad8ded2c17131f4ce0845c51c065042a0bfb810e99a009597cdb90b22145066d7a7ecc341dbfddcb96fa79a050d5de7d2515d0deab81f182ffa5f4a7abcd92d2b2d98fb81652412b1fd3ff68bc2baeff763bfa511c30e060bc3aad453ab8b1fa7f7ebd6e99c0a18671f3077eb4303cf86ad7ea4f57d04262d5292b032ab2e84163da971e943c2ee11600c2a8d5f481e23252bcf25edf6f06dfbbe75cd4513f4e48b64f8a4bf29f7792b460215d8723299112fe83b22fded881c908bb720011a1c5fb191cd7785212576fbcaf323b64027297db9a6d27a332bb521d4beaedbe08a5c186dbea35330bef91664b552a54baaf4c46cea5724eb431714770aa62b8306b88073bf2ecc401a09ea5e06a0274ffe9e73daea851c3c9ffff68ebed582b712263813c62bf975ea4a5b8a556c682656dfb09eb5fc6ca3adabc333c4989b7e3baaf0c58f3bca1e0aea6b3c7d68b92b48ec48ef0564188808de5be1ebb4ef0f7b40a3f92e1c12cbb4e229791c1f7719807a9cff4f052a5b694655d54fb9c2f3eb4b5b6f822707cf9774234a75f5e61156a343cb64b04491634e30ad36cdf3bf7a4e0e4159d01fb797fd752374ea54bcb06c8d524d2fe74d7b26cf05842e27b1467e1dc66a2fdfa9c2bbea44a376c1757a3c165307a5a833831838cd1503dc623b209bbe27d6de597e940e615a1df1be6a520930db20df0027074e183eb6c361c7e1d04524149dd894e19cfa9565e8978193fd5358850922530a2b27e33306f5ae76b33720da4923aa4bcbef3cb973f459714b805b9b31f488fc39faf6c2e184869612a8387c8d170713071aeeb3cf166d1c190a065d021eb6619a670626e48a36df38e7a1775915a7e7e7648c0726a14d0ffa7c7e8a4b469c45bd62513bf8e99d6e2467659e6fac2e12b603829f8eb193b531064f3a25c637ae7f1e4d5e9f1545efecffa0e35cc83079c6148c84d647725fac9a2d2ae073275fd8c24e9f8bbe14fc583e3545cbd5fd9e803e5fb4b2da1e8727e0d5e0790b3754b5fed6d22bad21e7ff7a3274d76a74ddfd827bebd2f4240f689ff34b6fd86a31e59e6d72a8566f06103d26871470924fe297bcf75b3633c36967ed968fb497c5387233d5baaec5d6e1ccc9dae985a8431076f0bfccf1a1c6bf66100631f3723b037f26411be1aa9575ca6132490bcfc811f80190ffc3be42012dc6693d9447a3d918a0465f1421aa4dc55bb94ec55120541ad2f7bb2f5fb90d8789528d7a634d44ea4db7eed992576fe2233d1e270ad01f0068c4ed60ab972e9083351072e261a2d2d621fb1897aedc5be9c2cf54b10914b54b6fecdf743d103007993a9c545ae7cc71114e74fc62f5ed1c1771ec800164c857932ce8aae82e1577f966db2d1e4dd6e907ab8b365e4f645442dd925f74503d070c572a2f10cbf425f8be35b308c9b1ffbaf2313e14eb16c0bf10767d89dd6f12adb4c768528509459942dd6ecdcd558976addcd3a1e96b848f9dc62a8561b7857ce347834564d4490da13eafb18e2d718b1fb0ab046b986e3fdc2c6841eb63da474f869dfc4fffc10b217bda4dba65c057e5be03e03fccd03d438047564801db823b7b7eb698f095685a72c8c770d5f42baa0d1892259d2d4b565af03f98ed17db7b5c43346fd7a5cb23b07dd8f576791683aafe7ae692850eaaf8452d9aa031fb8484b3e3b2fa55c0db9aa7afb5c9c44d4c5e64ad3108801cab940af11425cd13b713b973bd449b34b3b16c2da1413ef6aabb93e63f7d104bcb4114b8d855c4790931c4901202c749283ceadf3b2216a6692b9c5913787a49ddad907a97e382fc9f6c258f7f8c35d46b543dd74ad40a804b13a7d3e0e00d7b90e99e89ec576e21222cfce455c6822c70ae65ef100c4abe31db277508ba4c39d1df9ae7685a1b9d26487ff159e7b053bda81ec1bbccfa9b1c08a72c11e73675ef30e841f691e035687a914af6063139735a4c575337b30db78889ff7d15eff4f6b62f924a246c5283010e4542cd1ca6329d896163febae7f10e32690a9ba535d3a852e3f64779c6eed49230677ca151b2f900f41e58ad6e53c589b506714778c8c2ce24577c1ab841750bc7da06732d7aa63cb5a4665cf8347a0c78339249d3ed3febd02530af54986cef43229592ab1b5541ec477a2d051f4da6ebb0b5cc66aede403da621a160d66088c62e4aa5fec31d2a8ca7b8a3c54df71a0edaaf356ae7b5063438eadef36863987cc98070cd96d91b0cfd219de4a2f5af06adaf304018d53b130e30dfd7acd1b18e50d7800492792f533ff49d4615496feffe6e676171cbb741c5c75628f622e74ca83825bfc2b0366c99bc67b9cea7fe186bae97691c4e2b17b83b2cf890c44e214d3b0b1cdaf8c4494b8f78801234ef4be70a3e43ab6a3f2b29828235f919eabcf93404edaa85ab7553280e1be82ea46d22dcb5922a133f7f1b36bfa1f7bef7ff44d912a8530a3a6c557e969a3060e3144b394283a126395554bf59d9b9c689f91ffe624e271a31a66938f568dcc69adeeca041d0175756f525b96ade52d6bb7e29befa297c1e5a4731468b0c91250463130f67de4b0def978612f4d263151921198649d83403dfc6f4fdee354e602279e61e6d91f97aea5e3fe8e3ec6f73dc18d365c21bddb103f3f8157fc7269a30fac1c3ce0bf3651feea2785075f55ba1a15b71df8c0ae852ad79be8f2370e4a5d3e7b71b75a443092818b6ad815e904f8ca8505a60f9e75a408dbd86c8103542e5dc2fedb73564f793bf17ee52f5808f5ef64bd4c0a953e571f39d72c9f0c17fdbdd59857bd79be3ee7cff06d9982d5845425dd9394d94da12aea4283699fada35710beb14193116d13aeee465107f3c60e8147584ffb545071f5dff88f79542bd43d3fee44ef3a5314520e273ccc0377f7db75d55ad974e528bae0c6632565fd0d0892f6a9808d7e9666f3633404c5b10962a0c5a6b01f9f5edaa75362a29e2730d655ac590528aa444dc29d5ed5253a54c3a902054ad25f31493abd913fc54f3e87075f9c6f5c2ed05ca3c1c5ce07c77b100de0b456567789cb89e358ce4e084edd9d19d2881832f7ea0c1366e7b7c428b9b49b08f105ccc891ba8d20b7d47be4a1b8b95d922989660dbc9541bcf813182faa5156d5ea6dbf8ababbd3de24a168436ad9f8f7d170ee95063c073bdd18db6f2b024701500f053c2c218d8255beb22a1101f644735460262c6eaef1b7588e6fcaf46d075ac8abe2bb4447555cce99e25df0915f9868e9711f39a81c5352d9837c33f4cb4b55fdce2b2e6db4a92eafc983daf9e62aff47c88408143381e3cccd01df5ea7fb70f0cd178a2b00ac261890bf82c5badff8e30ea6c0b436490c7e882c8c4ccb467c3c83acab1ae763adf1d7b25d7cb87bdd3a1b3040b5a6712ec879972fcc5310c09d7e646abaa50cd76c5ba19c217fab074861e562be6cd4e1a1b6c469fff9af6730782011bfb1f3a08255dc154fa9d8d425b5372924154133957077d20aa6531e632dc59923a148430487e2a6710ec229eb7de6161b4781fe49fb9d793cba30c9f7263fb8c40ac4b387e192a4f9c4748ec2955f98eb89c16d1249c2e5342d80033180c97e53b75882216f99046b81a6b076e9f62ce4adef965a4eaf1c69bcd87b04cc5d76148fe90c741e0380653942fb6011e9888ef0fa2de3b526d155cd5059ee0356dc8f5e108d4407a7b4a8badaff335449ea19c4697808a3832c15a4b413ade11bdf28311680d7924334e0bdfb1bfcf3e0e86abd4ebefcb4e665114cf092ad8f2bc6fbb38f947a0ebd76a66dd02ed2636d8c466eef5426bb6b7ab80602ec23a9b8e2aa047fc80e1ae9e8ef62fe9499f08fb4e0243eb9cd028b9700b4593088451294ff2ae4569200279c1b39e7b94cebe22853e02ac22f1f24b9ff85454b69077dff5fdfd9e264dd011fd168e00e4b6b0cb0989d61a738c2936c3504abbef30c7743459b3cdd810cbd5082f3a08163ef317a7ae36ae54de30293f373cfa66e7e164b484a3cb8107e6b7d3beac7d689c678b11564e890cc16d37b13fc3f6b7a0884d73ad2bc494058237798cb0744f8e046e861c9582effca6c0be258a2c8a3b4d7f8ec723d8f441419c43a0477965d21b8133fa845c07cbd7969301dc1c67c425638a168a296f52db0aefc615ecb5677da75d9b18686292665d516e6b79deff72c2f857b950a2efc0abc7437da644998ec1fae7438379aef3137a99ceafd9771e7070731320dad51348ab85f90b88af754b08f9ec00a4cdca07eb62fbe68073919c5e61347ca3e1ba22c846d84a18ce5f5f90645bf798cef16345f9dfbdd68deb48055f8479ae18732e17fc1663a9fa4700e539e98301c3a8e705c7212bffeb0c3624e0f32f025bdb79b06da236788ceb6ef8463cce74de930d5e1bdc6027420efbfc7dd50b0a7ee36789822e11a5e47170b121e4617ce3360f357491e71199dc06f14de47377b30baa2576f3e92cf255b6a14baf526e74a9d807b64a91d64f7d7290832cfa21f1730073ed24c94731c627653c35031ccbea5c9144260777b9df2019163f1ab9468a785f3d917e9ec3b477be7f95e9bb4215dad1b3d9ce8a26b40b440a2917c5ad1b655458aef217506c807bc9c6997470eecf4d993835dee95fc5e94dd0046ebec220015b26f6ff6813622abbafda9e78ae862ae80f836a014cee2e127a93b2723ae0203438d887834fbf181f0c61492fcac17c4f846cfdfadb51f39b552052f991293d8758a79c49e22ddedca7fbc459463b9e51cfe9ae0c5416ef7e9d27062a3a7d686db14284af1ce01dd244bdc1b73f5f4d1919d47aad7fe7ad217c8b6add49a02d6df89b6cdf387e939b0353e2d81771717e66b567d45cf894bb2decdb17596b6379caf4267a20636f3931deedcdfcc09055873e91c61fb0d255ad7a6d771da350bc179856943ee283fed179dfe83395702bc4f83a3a1a38ea7ab34626148585b3148ba1f6118a5f5ad768f589d349cb758029a19d354eb02ecef419b54940005db58835452b96a39092178f7ec4617afe46c40e3d659f98e149cd107ad649b8f41282e9540f66b42a530534d7899bc24f711011a834c86ef79b2ca48a26f37b167b6a38dde53c766db25d07e33b002ca451fd33a14ca8cbfcda092fc7fb62ac2fddb6e91c879042d4516f9507e257b8b273ab467b55bfd621ab34be40c3d7ea73c0ba7c45e483894052919c06d1cc67c8bb328bf39e9c37e14f0c77d9d513764f58dd976752897d5e3027e591ec294a26e42757847e98849d10cda78d9b567ba5b1dd6eec420067467986d7cd99626072565d7748cd1a7993f56727568bf1aea36dee2f962267ad16c1c89f11109a7632e6e1877b7c837306877c858432a3facd348c554beade9a4491acf332a2bda33c2f101f7dda61314229f7b71fcbe055b589d9ad5337003749f0dd8a5541bdeca973e74eb2e12a22e5e0b6f21f7af527d41af2d01819579a2b613a8914cb6116c66e93d6c1367a9ba0e9e9196b1b352210b5650af58a7aaeb128f080acb97ed6d371fa4d47c1589e4e33bd323598d51ab3eed5d29e9e4e433a9d623d218e7b77a1f48544160a640e5f734cea8059a8096d3ea274d404800f3562ad27a5fd7853f036b86d5ce50f471d5fc0ff76224e209d5e53654076c5c3d4df932f669b3127344aa1f2a7934cff0370ef699d3fda83bac129b5c66c7f5e07338f69ddcedb66df08bd194fd84d0dedea828b9453e8d7c872a4b54d81438183c6dcaa2b87509d1134a7b4134d88c594c004949c6acb78982b34804282411bd353524aabb95e0a71ee39d1185fcecfbf1bead88903066007701519609b6c170dc93061e18cb06d48faf15cf4ac6c61e1bebeccde13489f6beaeecbe4f54d786a4a21b450129f16a46152a7f3df8f7cab0531e1f8a79b455cbe4ca5bb6de8a65ab8ff3291746d010afe6407c9582b61110768798c89dc3ecec216b7bdeea5eade7858ba44e7bbcc98db380f5e407f4323dba1f399299143cfff20ea088c1b8abccd2ac087ff84fb5741a77b8c2af00bd880db0a4bbb25c78160d1426dd5c348500ffc4b3c33331c83aaaa01bf1f52c57bd680147832fb24f182010768e3bf5248ea4ae2c0d71dc452b3dd25c6b1a958371f226fbc2b47742094aa3951d0139a3122a79ebc7f52dc8fff18f7506794528d953e2d183032fc4184b0f0ef618005d24978c171ddaba8abf6ff854fe4e1fed7721c8b18df8b57272007d867d12ce8d174bda1738afb42bb9cd28931ea9a4b9df072b16308169c09b8509cff172c59b40ee2d870258151ddc5d413e59720b3136d2c643edaa7dec322cc516a58b0243b65aa7bf525adb37d2be071b3ddf18b4814a120c70c60e04dbcc56073cf53bbe63f18d7da0a656187d64c658477e246131d2760b94f0f267a124eef2702423390b2b01115099369f115020cf86b6d5d2704eab1f5ae9a9c04fb6a1b4d7044f8bab768fab793dac20f990e848ae8517f33cba282b127ea19541884dffe8111802d4623b11726e03098b054335996e0d7ecee20bcc0645c80424cfaef34c4094e530bb8fcfd8d0c2068a3f4b9cc4883b4a67c1279dc9291f74613f64d025b656266a62919d4b16429918a758399eaec25fd668f36904295e293ad5432ff6222ea275f1a28fac994376c12f463feea0ae1a22be68f8058d19c8d85cadbe7129bea6695738d5aafb7b72fc43ad32b258e40987aa34b65c5ff5a4e49d1e4a3471d5d56abd20035aad09fadffd042bb3964464b507350ff8095fdb2cd2966d536a697ed297f0bdf7837b07b9740b5baed83a8a5217f44963a4c45580bab4d8561158b33e719fd5600011dce0a4c993b49fd9cbb89f570803d021eaebf63ae9a1b236e7b517de9088acabd4a0e2077f54243c50c2cfe8c8455f3ba5e67fd104ad34238430f59d71eb39e3daaff78bd1e9222eaeee7910ed1da8dcc350a8d1115d9bbfe8b2180ae328c94f4dc325f82c7134a2b993401718677dfe74cd9e8f4f8983a82e9b6652104745c30dd96c8aebb65aea368d5b6468fbc4b153baa3d3469503c45f1757f147e5c836c5ef2bd0c4b21931a215f1f1a3c0b0dbaccf515930259b7caec2e0dc99c9077654b66924a6959129aa3a31af686c58ad3010ccad4afcd30e954edc842d6ce6cb76049b579c9b5c03108ffa1bebcb8f0f3ecedb98ff07ee6fd59677f71d527c36356691377038ea55c000268c96dd39c0eb9468878e3d5dd7440fcbb039ceafb836036fca26212dc2c7d0c616401de11f0b1a9d5c2810622b14cee8a7455b61f86c5ab56c86a7e0e746b8883fdc3aa08672a9f4b8c1ca4b1d11120a51d1c62537366c3e8638743b2ad0aa42fd22764d9ffb3023b8bcb01c9249674e1df796c381afb2e08e6c2621675ee1c02c96c2e639c5f301de989258eec4bb66a66a940f99649e983522b66be55de79696099770fa79f56558c3a04e92a207c9a9fe87d3439b7028c5fab8a10d91435353cfcdb854cc557352734f51bbf1dba2b70a9d804779f5135dd7c03f3a4271907918f0e1358825c494b1ae8d8b66ee8b7d614110eab8509b9662c684f2724328aeb5c64e439d6b5b77ac5549ab6b07c5ea427c06f1734312de026f60a6a3f13f548ac39cf8f811ab082f68e66d3f4792a149ed1e410a31d04366ba8bf65e1a1e6064a2a6f94b2a8899a4ec89cf68f0ed5370ae3fdbc30b4ee40e196f72d2376208831f366944b815d1d43f2b598f4d237bf1c6a6d9d091ddeda8ddbce95d93c82104cf6990b1e39372d33590a89e0c57d5a22d1ab716a086283d8227e165de08e0df0ff71a460864402dbd1e16929b2d9d25f8d48d9a5f8839ece08d281f402291a1470fc779d126643d7cef5e11f4d2afade6ef9b7b9b5626aa072f9977196f6cdd28f2fef800d3b8e68f8b128bd5c38549852c9644e14fd33f65914bdd1dc42037cb4141c6c8cfea792a3515b9fa6434260018fd8db0179fc66e61e87e60a588060973e5b77319a0ce2e4c7818cf801ebf0f7494d3a7a6ea897ddad8ee9870a010fced26ba2248fc2a3a4fbab48b84bb257a09b13db440c5520d280970623925518e5aaa25bab2dd907373e68128271f173775c5f5e16d36a2eedc6e2f85b937614e2714ca9d464ee6838e3b14396701095ecab7ef28ac279fe1b12baed02c1fc59b050e0edd22edc73b0b7645457fd4dc36d21c4a5529cdbdb623b0cc136fbe68afff0336df46f636de3114e2b26b9a55f3a8b216ea1dca050aa61f073bf3eef40e27b070070a23155d02ffb88ecf507447bf13176aa7410a0d527b8ceb1246e642a9656f2974abaf5ed7203b6580b8deb0a73e5f5200c6078fdafe2aa8cc81098e287873db2d86bbb1d52460f338c7ceb62a11eff3f8dd20bd2482f38cc5ac409cb2af5fdf7368cdd78e6c8f8956a895c199feee33673436a1335e49fd03b9f4bf2484071995d5d2f3c9005ab867c3b46d1bc9b4cb06c1ba598d2184987b9ab4b31a0d9c512d3ed486e13d9bba076290b6a3c7f7bad14dd1211cf32a7493cff1884d647682a3c131b002ef1a0884e784503fa1a5da1f1ed81ef317c26e690c0606ea84aa180d8cc24af5ef636ee8efc9083d3b57f8581c8c1b5999c0431007359fda07c04dbbc81e7ba24df79da0bc14ceecdebd09c0cfca1f3de0bef259fc6494106e9d7d3f7c26f1003d23cd8027ee829a15402e166f80d0a637d94a8bab2d9d854e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">这里需要密码。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Kalthyix 团队周报</tag>
      </tags>
  </entry>
  <entry>
    <title>五一集训题目合集</title>
    <url>/2025/07/04/%E4%BA%94%E4%B8%80%E9%9B%86%E8%AE%AD%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="a-simple-task"><a
href="https://codeforces.com/problemset/problem/558/E"
title="A Simple Task">A Simple Task</a></h3>
<p>因为字符集大小只有 <span
class="math inline">\(26\)</span>，考虑直接在线段树每个节点维护当前区间的字符个数。排序时直接暴力区间赋值，复杂度会有
<span class="math inline">\(26\)</span> 的常数。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u&lt;&lt;1|1</span></span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> tree[N*<span class="number">4</span>][<span class="number">26</span>],tag[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        tree[u][i]=tree[ls][i]+tree[rs][i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tag[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[u][s[l]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!~tag[u])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        tree[ls][i]=tree[rs][i]=<span class="number">0</span>;</span><br><span class="line">    tree[ls][tag[u]]=mid-l<span class="number">+1</span>,tree[rs][tag[u]]=r-mid;</span><br><span class="line">    tag[ls]=tag[rs]=tag[u];</span><br><span class="line">    tag[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            tree[u][i]=<span class="number">0</span>;</span><br><span class="line">        tree[u][k]=r-l<span class="number">+1</span>;</span><br><span class="line">        tag[u]=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="built_in">modify</span>(ls,l,mid,x,y,k);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">        <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">        <span class="keyword">return</span> tree[u][k];</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        res+=<span class="built_in">query</span>(ls,l,mid,x,y,k);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">        res+=<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">query_ans</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(tree[u][i])</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>+i;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">push_down</span>(u,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_ans</span>(ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_ans</span>(rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;</span><br><span class="line">    s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> l,r,k;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">        <span class="keyword">if</span>(k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">                a[i]=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i])</span><br><span class="line">                    <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,l+a[i]<span class="number">-1</span>,i);</span><br><span class="line">                l+=a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">                a[i]=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">25</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i])</span><br><span class="line">                    <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,l+a[i]<span class="number">-1</span>,i);</span><br><span class="line">                l+=a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">query_ans</span>(<span class="number">1</span>,<span class="number">1</span>,n,i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="heoi2012-采花"><a href="https://www.luogu.com.cn/problem/P4113"
title="[HEOI2012] 采花">[HEOI2012] 采花</a></h3>
离线，树状数组维护之前出现两次及以上的颜色数，每次出现 <span
class="math inline">\(2\)</span> 次后在之前的位置加 <span
class="math inline">\(1\)</span>，并且把之前的之前加的撤销。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,c,m,x[N],tree[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        tree[i]+=k;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&gt;<span class="number">0</span>;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        res+=tree[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Query &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r&lt;x.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="type">int</span> pre1[N],pre2[N],ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,c,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(x[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">read</span>(q[i].l,q[i].r),q[i].id=i;</span><br><span class="line">    std::<span class="built_in">sort</span>(q<span class="number">+1</span>,q<span class="number">+1</span>+m);</span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now&lt;=q[i].r)&#123;</span><br><span class="line">            <span class="type">int</span> temp=x[now];</span><br><span class="line">            <span class="keyword">if</span>(pre1[temp])&#123;</span><br><span class="line">                <span class="built_in">modify</span>(pre1[temp],<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(pre2[temp])</span><br><span class="line">                    <span class="built_in">modify</span>(pre2[temp],<span class="number">-1</span>);</span><br><span class="line">                pre2[temp]=pre1[temp];</span><br><span class="line">            &#125;</span><br><span class="line">            pre1[temp]=now;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[q[i].id]=<span class="built_in">query</span>(q[i].r)-<span class="built_in">query</span>(q[i].l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ynoi2012-noip2015-充满了希望"><a
href="https://www.luogu.com.cn/problem/P5524"
title="[Ynoi2012] NOIP2015 充满了希望">[Ynoi2012] NOIP2015
充满了希望</a></h3>
注意到，任何情况下，查询的答案要么是 <span
class="math inline">\(0\)</span>，要么是一个确定的值（即有没有被修改过），这个确定的值必然来自
2 操作。所以维护时间戳，利用树状数组查询区间和。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,q,opt[N];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">segtree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> tree[N*<span class="number">4</span>];</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tree[u])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            tree[ls]=tree[rs]=tree[u];</span><br><span class="line">            tree[u]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">                tree[u]=k;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">push_down</span>(u);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">                <span class="built_in">modify</span>(ls,l,mid,x,y,k);</span><br><span class="line">            <span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">                <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tree[u]||l==r)</span><br><span class="line">                <span class="keyword">return</span> tree[u];</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">push_down</span>(u);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">query</span>(ls,l,mid,x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ll tree[N];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!x)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=m;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">                tree[i]+=k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!x)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ll res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">                res+=tree[i];</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;b;</span><br><span class="line"><span class="type">int</span> val[N],t[N];</span><br><span class="line">ll ans[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; ask[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,opt,l,r,k;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            <span class="type">int</span> x=a.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l),y=a.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,r);</span><br><span class="line">            a.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,l,y);</span><br><span class="line">            a.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,r,r,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r&gt;&gt;val[i];</span><br><span class="line">            a.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            t[i]=a.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l,r;i&lt;=q;i++)&#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        ask[r].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(l,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i])</span><br><span class="line">            b.<span class="built_in">modify</span>(t[i],val[t[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> k:ask[i])</span><br><span class="line">            ans[k.second]=b.<span class="built_in">query</span>(i)-b.<span class="built_in">query</span>(k.first<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="thupc-2017-天天爱射击"><a
href="https://www.luogu.com.cn/problem/P7424"
title="[THUPC 2017] 天天爱射击">[THUPC 2017] 天天爱射击</a></h3>
法一： 主席树 + 二分答案。对每颗子弹设一个版本，二分版本。<span
class="math inline">\(O(n\log^2n)\)</span>（常数过大无法通过）。 法二：
静态区间第 <span class="math inline">\(k\)</span> 大。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> root[N],tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum,ls,rs;</span><br><span class="line">&#125;tree[N*<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tree[u].sum=tree[tree[u].ls].sum+tree[tree[u].rs].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> old,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    u=++tot;</span><br><span class="line">    tree[u]=tree[old];</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[u].sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="built_in">modify</span>(tree[u].ls,tree[old].ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">modify</span>(tree[u].rs,tree[old].rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> old,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>,s=tree[tree[u].ls].sum-tree[tree[old].ls].sum;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=s)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[u].ls,tree[old].ls,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[u].rs,tree[old].rs,mid<span class="number">+1</span>,r,k-s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x1,x2,s;</span><br><span class="line">&#125;q[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">read</span>(q[i].x1,q[i].x2,q[i].s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">read</span>(x);</span><br><span class="line">		b[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2e5</span>;i++)&#123;</span><br><span class="line">		root[i]=root[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t:b[i])</span><br><span class="line">			<span class="built_in">modify</span>(root[i],root[i],<span class="number">1</span>,m<span class="number">+1</span>,t);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x1=q[i].x1,x2=q[i].x2,s=q[i].s;</span><br><span class="line">		<span class="type">int</span> k=<span class="built_in">query</span>(root[x2],root[x1<span class="number">-1</span>],<span class="number">1</span>,m<span class="number">+1</span>,s);</span><br><span class="line">        ans[k]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="legacy"><a
href="https://codeforces.com/problemset/problem/786/B"
title="Legacy">Legacy</a></h3>
<p>线段树优化建图。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K 4e5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 4557430888798830399</span></span><br><span class="line"><span class="type">int</span> n,q,s,a[N],tot_edge,head[N*<span class="number">8</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[N*<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++tot_edge].to=v;</span><br><span class="line">    e[tot_edge].nxt=head[u];</span><br><span class="line">    e[tot_edge].w=w;</span><br><span class="line">    head[u]=tot_edge;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        a[l]=u;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_edge</span>(u,ls,<span class="number">0</span>),<span class="built_in">add_edge</span>(u,rs,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">add_edge</span>(ls+K,u+K,<span class="number">0</span>),<span class="built_in">add_edge</span>(rs+K,u+K,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">bool</span> rev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rev)</span><br><span class="line">            <span class="built_in">add_edge</span>(v+K,u,w);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">add_edge</span>(u+K,v,w);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="built_in">modify</span>(ls,l,mid,x,y,v,w,rev);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)</span><br><span class="line">        <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,v,w,rev);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;ll,<span class="type">int</span>&gt;,vector&lt;pair&lt;ll,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;ll,<span class="type">int</span>&gt;&gt;&gt; que;</span><br><span class="line"><span class="type">bool</span> vis[N*<span class="number">8</span>];</span><br><span class="line">ll dis[N*<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">read</span>(n,q,s);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add_edge</span>(a[i],a[i]+K,<span class="number">0</span>),<span class="built_in">add_edge</span>(a[i]+K,a[i],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,opt,x,y,v,w;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(opt);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x,y,w);</span><br><span class="line">            <span class="built_in">add_edge</span>(a[x]+K,a[y],w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(v,x,y,w);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,a[v],w,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">read</span>(v,x,y,w);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,a[v],w,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[(<span class="type">int</span>)(a[s]+K)]=<span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,a[s]+K));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=que.<span class="built_in">top</span>().second;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[a[i]]==inf)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,dis[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="noi2018-归程"><a href="https://www.luogu.com.cn/problem/P4768"
title="[NOI2018] 归程">[NOI2018] 归程</a></h3>
<p>使用 Kruskal 重构树，倍增查找，时间复杂度 <span
class="math inline">\(O(n\log n)\)</span>。 <del>多测一定要记得清 head
数组……</del></p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>,M=<span class="number">4e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,a;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;x.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[M*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[M*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> tot_edge,head[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++tot_edge].to=v;</span><br><span class="line">    e[tot_edge].w=w;</span><br><span class="line">    e[tot_edge].nxt=head[u];</span><br><span class="line">    head[u]=tot_edge;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; que;</span><br><span class="line"><span class="type">int</span> dis[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=que.<span class="built_in">top</span>().second;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">		        que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q,k,s,fa[M*<span class="number">2</span>],w[M*<span class="number">2</span>],f[M*<span class="number">2</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=n;</span><br><span class="line">    <span class="built_in">sort</span>(p<span class="number">+1</span>,p<span class="number">+1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)</span><br><span class="line">        fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">find</span>(p[i].u),y=<span class="built_in">find</span>(p[i].v);</span><br><span class="line">        <span class="keyword">if</span>(x==y)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        fa[x]=fa[y]=++cnt;</span><br><span class="line">        w[cnt]=p[i].a;</span><br><span class="line">        dis[cnt]=<span class="built_in">Min</span>(dis[x],dis[y]);</span><br><span class="line">        f[x][<span class="number">0</span>]=f[y][<span class="number">0</span>]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">            f[j][i]=f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lastans,v0,p0;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(f[x][i]&amp;&amp;w[f[x][i]]&gt;y)</span><br><span class="line">            x=f[x][i];</span><br><span class="line">    <span class="keyword">return</span> dis[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;return.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;return.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		tot_edge=lastans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="built_in">sizeof</span>(w));</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">		<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">		<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">read</span>(n,m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="built_in">read</span>(p[i].u,p[i].v,l,p[i].a);</span><br><span class="line">            <span class="built_in">add_edge</span>(p[i].u,p[i].v,l);</span><br><span class="line">            <span class="built_in">add_edge</span>(p[i].v,p[i].u,l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dijkstra</span>();</span><br><span class="line">        <span class="built_in">kruskal</span>();</span><br><span class="line">        <span class="built_in">read</span>(q,k,s);</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="built_in">read</span>(v0,p0);</span><br><span class="line">            v0=(v0+k*lastans<span class="number">-1</span>)%n<span class="number">+1</span>;</span><br><span class="line">            p0=(p0+k*lastans)%(s<span class="number">+1</span>);</span><br><span class="line">            lastans=<span class="built_in">query</span>(v0,p0);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lastans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="scoi2016-萌萌哒"><a
href="https://www.luogu.com.cn/problem/P3295"
title="[SCOI2016] 萌萌哒">[SCOI2016] 萌萌哒</a></h3>
<p>倍增+并查集。考虑将区间二进制拆分，之后再合并。<span
class="math inline">\(f_{i,j}\)</span> 表示以 <span
class="math inline">\(i\)</span> 为左端点，长度为 <span
class="math inline">\(2^j\)</span> 的区间的所在连通块的左端点。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,f[N][<span class="number">25</span>],l1,r1,l2,r2,ans,maxn;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==f[x][k])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> f[x][k]=<span class="built_in">find</span>(f[x][k],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="built_in">find</span>(x,k),b=<span class="built_in">find</span>(y,k);</span><br><span class="line">    <span class="keyword">if</span>(a!=b)</span><br><span class="line">        f[a][k]=b;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    maxn=std::__lg(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=maxn;j++)</span><br><span class="line">            f[i][j]=i;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(l1,r1,l2,r2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=maxn;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">if</span>(l1+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=r1)&#123;</span><br><span class="line">                <span class="built_in">merge</span>(l1,l2,j);</span><br><span class="line">                l1+=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">                l2+=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=maxn;j;j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">find</span>(i,j);</span><br><span class="line">            <span class="built_in">merge</span>(i,x,j<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">merge</span>(i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)),x+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)),j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(f[i][<span class="number">0</span>]==i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                ans=<span class="number">9</span>;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans=(ans*<span class="number">10ll</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="hh-去散步"><a href="https://www.luogu.com.cn/problem/P2151"
title="HH 去散步">HH 去散步</a></h3>
<p>设边权均为 <span class="math inline">\(1\)</span>，计算邻接矩阵 <span
class="math inline">\(A\)</span> 的 <span
class="math inline">\(k\)</span> 次幂，则 <span
class="math inline">\(A^k_{i,j}\)</span> 表示走 <span
class="math inline">\(k\)</span> 步能连接 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span>
两点间的路径条数。但这道题要求不走回头路，我们考虑点边互换，记录入边和出边来避免走回头路。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">10</span>)</span><br><span class="line">        <span class="built_in">putchar</span>(x<span class="number">+48</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x%<span class="number">10</span><span class="number">+48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 45989</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> x[N][N];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="built_in">sizeof</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix &amp;a)&#123;</span><br><span class="line">        Matrix res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=cnt;k++)</span><br><span class="line">                    res.x[i][j]=(res.x[i][j]+x[i][k]*a.x[k][j]%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p;</span><br><span class="line"><span class="type">int</span> n,m,t,a,b,res;</span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        res.x[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,t,a,b);</span><br><span class="line">    a++,b++;</span><br><span class="line">    e[cnt=<span class="number">1</span>].u=<span class="number">0</span>,e[<span class="number">1</span>].v=a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        u++,v++;</span><br><span class="line">        e[++cnt].u=u;</span><br><span class="line">        e[cnt].v=v;</span><br><span class="line">        e[++cnt].u=v;</span><br><span class="line">        e[cnt].v=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">            <span class="keyword">if</span>(e[i].v==e[j].u&amp;&amp;i!=(j^<span class="number">1</span>)&amp;&amp;i!=j)</span><br><span class="line">                p.x[i][j]=<span class="number">1</span>;</span><br><span class="line">    p=<span class="built_in">qpow</span>(p,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">if</span>(e[i].v==b)</span><br><span class="line">            res=(res+p.x[<span class="number">1</span>][i])%mod;</span><br><span class="line">    <span class="built_in">write</span>(res);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="sdoi2015-寻宝游戏"><a
href="https://www.luogu.com.cn/problem/P3320"
title="[SDOI2015] 寻宝游戏">[SDOI2015] 寻宝游戏</a></h3>
<p>将关键点按 dfn 排序为 <span
class="math inline">\(a_1,a_2,a_3,\cdots,a_n\)</span>，则包含所有关键点的最小生成树的边权和的
<span class="math inline">\(2\)</span> 倍为 <span
class="math inline">\(dis(a_1,a_2)+dis(a_2,a_3)+\cdots+dis(a_n,a_1)\)</span>。
实现方面，使用一个 set 来查询前驱后继。这题不开 long long 一分没有。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll ans,d[N];</span><br><span class="line"><span class="type">int</span> dfn[N],son[N],dfncnt,idfn[N],dep[N],siz[N],top[N],fa[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    dep[u]=dep[f]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:e[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=i.to,w=i.w;</span><br><span class="line">        <span class="keyword">if</span>(v==f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        d[v]=d[u]+w;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]])</span><br><span class="line">            son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">    top[u]=topf;</span><br><span class="line">    dfn[u]=++dfncnt;</span><br><span class="line">    idfn[dfncnt]=u;</span><br><span class="line">    <span class="keyword">if</span>(!son[u])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:e[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=i.to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==son[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[a]!=top[b])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[a]]&gt;dep[top[b]])</span><br><span class="line">            a=fa[top[a]];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b=fa[top[b]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[a]&gt;dep[b]?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dis</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	a=idfn[a],b=idfn[b];</span><br><span class="line">    <span class="keyword">return</span> d[a]+d[b]<span class="number">-2</span>*d[<span class="built_in">lca</span>(a,b)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		st.<span class="built_in">insert</span>(t);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(st.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">		ans=<span class="number">2</span>*<span class="built_in">dis</span>(*st.<span class="built_in">begin</span>(),t);</span><br><span class="line">		st.<span class="built_in">insert</span>(t);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	st.<span class="built_in">insert</span>(t);</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">auto</span> it=st.<span class="built_in">find</span>(t);</span><br><span class="line">	<span class="keyword">if</span>(it==st.<span class="built_in">begin</span>())</span><br><span class="line">		x=*--st.<span class="built_in">end</span>();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		x=*--it;</span><br><span class="line">	it=st.<span class="built_in">find</span>(t);</span><br><span class="line">	<span class="keyword">if</span>(it==--st.<span class="built_in">end</span>())</span><br><span class="line">		y=*st.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		y=*++it;</span><br><span class="line">	ans+=<span class="built_in">dis</span>(x,t)+<span class="built_in">dis</span>(t,y)-<span class="built_in">dis</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(st.<span class="built_in">size</span>()&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		st.<span class="built_in">erase</span>(t);</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(st.<span class="built_in">size</span>()==<span class="number">3</span>)&#123;</span><br><span class="line">		st.<span class="built_in">erase</span>(t);</span><br><span class="line">		ans=<span class="number">2</span>*<span class="built_in">dis</span>(*st.<span class="built_in">begin</span>(),*--st.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">auto</span> it=st.<span class="built_in">find</span>(t);</span><br><span class="line">	<span class="keyword">if</span>(it==st.<span class="built_in">begin</span>())</span><br><span class="line">		x=*--st.<span class="built_in">end</span>();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		x=*--it;</span><br><span class="line">	it=st.<span class="built_in">find</span>(t);</span><br><span class="line">	<span class="keyword">if</span>(it==--st.<span class="built_in">end</span>())</span><br><span class="line">		y=*st.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		y=*++it;</span><br><span class="line">	ans-=<span class="built_in">dis</span>(x,t)+<span class="built_in">dis</span>(t,y)-<span class="built_in">dis</span>(x,y);</span><br><span class="line">	st.<span class="built_in">erase</span>(t);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">read</span>(x,y,z);</span><br><span class="line">        e[x].<span class="built_in">push_back</span>(&#123;y,z&#125;);</span><br><span class="line">        e[y].<span class="built_in">push_back</span>(&#123;x,z&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="built_in">read</span>(t);</span><br><span class="line">		t=dfn[t];</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">find</span>(t)==st.<span class="built_in">end</span>())</span><br><span class="line">			<span class="built_in">add</span>(t);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">			<span class="built_in">del</span>(t);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <tags>
        <tag>题目合集</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树·平衡树</title>
    <url>/2025/07/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%C2%B7%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉搜索树">二叉搜索树</h2>
<h3 id="性质">性质</h3>
<ul>
<li>显然二叉搜索树是一棵二叉树。</li>
<li>空树是二叉搜索树。</li>
<li>二叉搜索树的左右子树也是二叉搜索树。</li>
<li>二叉搜索树的左子树上任意一个节点的权值均小于根节点的权值，右子树上任意一个节点的权值均大于根节点的权值。</li>
</ul>
<p>二叉搜索树上的基本操作时间复杂度大多为 <span
class="math inline">\(O(h)\)</span>，<span
class="math inline">\(h\)</span> 为二叉搜索树的高度。若二叉搜索树有
<span class="math inline">\(n\)</span> 个节点，则最优时间复杂度为 <span
class="math inline">\(O(\log n)\)</span>（完全二叉树），最坏时间复杂度为
<span class="math inline">\(O(n)\)</span>（退化成链）。
显然，二叉搜索树很容易被卡，我们需要上优化。 ## 平衡树
二叉搜索树复杂度之所以不稳定，在于其操作大多与树的高度有关。平衡树通过维护<strong>平衡性</strong>维持树的高度，降低时间复杂度。
### 平衡性 对于一棵二叉搜索树，每一个节点左子树和右子树高度相差至多为
<span class="math inline">\(1\)</span>。 ### 平衡的调整 我们使用
<strong>左旋（zag）</strong> 和 <strong>右旋（zig）</strong>
操作维护平衡性。注意，维护平衡性时不能改变中序遍历序列。
先说右旋操作，我们有一棵二叉搜索树 <img
src="https://github.com/headless-piston/blog_images/blob/main/rotate_1.png?raw=true"
alt="image" /> 我们将 <span class="math inline">\(B\)</span>
向右上旋转，成为新的根节点，<span class="math inline">\(A\)</span>
向右下旋转成为 <span class="math inline">\(B\)</span>
的右子树的根节点，<span class="math inline">\(B\)</span> 的右子树变为
<span class="math inline">\(A\)</span> 的左子树。 <img
src="https://github.com/headless-piston/blog_images/blob/main/rotate_2.png?raw=true"
alt="image" /> <img
src="https://github.com/headless-piston/blog_images/blob/main/rotate_3.png?raw=true"
alt="image" />
左旋与右旋互为镜像。将第三张图中的树左旋可得到第一张图中的树。 ### Splay
树 #### 定义 一种二叉平衡树，通过 Splay（伸展）操作，在 <span
class="math inline">\(O(\log n)\)</span>
时间内实现插入、查询和删除操作。注意，<span class="math inline">\(O(\log
n)\)</span> 为 Splay 的<strong>均摊</strong>时间复杂度。Splay
树将旋转操作用到了极致，但常数在平衡树中属于较大的。 #### 声明
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>];<span class="comment">//son[i][0/1]表示节点i的左/右儿子编号</span></span><br><span class="line"><span class="type">int</span> fa[N];<span class="comment">//父节点</span></span><br><span class="line"><span class="type">int</span> tot;<span class="comment">//已使用节点个数</span></span><br><span class="line"><span class="type">int</span> val[N];<span class="comment">//val[i]为节点i的权值</span></span><br><span class="line"><span class="type">int</span> cnt[N];<span class="comment">//cnt[i]为节点i所对权值出现的次数</span></span><br><span class="line"><span class="type">int</span> siz[N];<span class="comment">//子树的大小</span></span><br></pre></td></tr></table></figure> #### 辅助操作 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dir</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//判断节点x是父节点的左儿子还是右儿子</span></span><br><span class="line">	<span class="keyword">return</span> x==son[fa[x]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//更新节点x的信息</span></span><br><span class="line">	siz[x]=cnt[x]+siz[son[x][<span class="number">0</span>]]+siz[son[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 旋转操作 设需要上移节点
<span class="math inline">\(x\)</span>，进行右旋操作。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/*右旋</span></span><br><span class="line"><span class="comment">			z           z</span></span><br><span class="line"><span class="comment">           /           /</span></span><br><span class="line"><span class="comment">          y	          x</span></span><br><span class="line"><span class="comment">         / \    -&gt;   / \</span></span><br><span class="line"><span class="comment">		x  yr       xl  y</span></span><br><span class="line"><span class="comment">       / \             / \</span></span><br><span class="line"><span class="comment">      xl xr           xr yr</span></span><br><span class="line"><span class="comment">  左旋</span></span><br><span class="line"><span class="comment">			z           z</span></span><br><span class="line"><span class="comment">			 \           \</span></span><br><span class="line"><span class="comment">			  y           x</span></span><br><span class="line"><span class="comment">			 / \  -&gt;     / \</span></span><br><span class="line"><span class="comment">			yl  x       y   xr</span></span><br><span class="line"><span class="comment">			   / \     / \</span></span><br><span class="line"><span class="comment">		      xl xr   yl xl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="type">int</span> y=fa[x],z=fa[y];</span><br><span class="line">	<span class="type">bool</span> r=<span class="built_in">dir</span>(x);</span><br><span class="line">	son[y][r]=son[x][!r];<span class="comment">//x的子节点转移到y</span></span><br><span class="line">	<span class="keyword">if</span>(son[x][!r])</span><br><span class="line">		fa[son[x][!r]]=y;</span><br><span class="line">	fa[x]=z;<span class="comment">//x变为z的子节点</span></span><br><span class="line">	<span class="keyword">if</span>(z)</span><br><span class="line">		son[z][<span class="built_in">dir</span>(y)]=x;</span><br><span class="line">	son[x][!r]=y;<span class="comment">//y变为x的子节点</span></span><br><span class="line">	fa[y]=x;</span><br><span class="line">	<span class="built_in">push_up</span>(y);</span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
#### 伸展操作 Splay 树要求访问每一个节点 <span
class="math inline">\(x\)</span>
后强制其旋转到根节点。该操作就是伸展操作。通过一系列伸展步骤将 <span
class="math inline">\(x\)</span> 逐步移到根节点。记 <span
class="math inline">\(x\)</span> 的父节点为 <span
class="math inline">\(p\)</span>，伸展步骤有三种： - zig/zag：当 <span
class="math inline">\(p\)</span> 为根节点时，直接将 <span
class="math inline">\(x\)</span> 左旋或右旋。在 <span
class="math inline">\(x\)</span>
在伸展操作刚开始时深度为奇数时作为伸展操作的最后一步。 -
zig-zig/zag-zag（一字型）：当 <span class="math inline">\(p\)</span>
不是根节点且 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(p\)</span>
都是左侧子节点或都是右侧子节点时进行。首先将 <span
class="math inline">\(p\)</span> 旋转，然后将 <span
class="math inline">\(x\)</span> 旋转。 - zig-zag/zag-zig（之字型）：当
<span class="math inline">\(p\)</span> 不是根节点且 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(p\)</span>
一个为左侧子节点一个为右侧子节点时进行。将 <span
class="math inline">\(x\)</span> 先左旋再右旋或先右旋再左旋。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//z为根节点</span></span><br><span class="line">	<span class="type">int</span> temp=fa[z];</span><br><span class="line">	<span class="keyword">while</span>(fa[x]!=temp)&#123;</span><br><span class="line">		<span class="type">int</span> y=fa[x];</span><br><span class="line">		<span class="keyword">if</span>(fa[y]!=temp)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dir</span>(x)==<span class="built_in">dir</span>(y))</span><br><span class="line">				<span class="built_in">rotate</span>(y);<span class="comment">//一字型</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">rotate</span>(x);<span class="comment">//之字型</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rotate</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	z=x;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 平衡树操作 ##### 按照值查找 查找值 <span
class="math inline">\(v\)</span>，并将 <span
class="math inline">\(v\)</span> 所对节点上移至根部。 若不存在值为 <span
class="math inline">\(v\)</span>
的节点，则要将最后一个访问到的节点上移至根部。此时的根为所有大于 <span
class="math inline">\(v\)</span> 的值中最小的或所有小于 <span
class="math inline">\(v\)</span> 的值中最大的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//该函数调用后的根节点即为返回值</span></span><br><span class="line">	<span class="type">int</span> x=z,y=fa[x];</span><br><span class="line">	<span class="keyword">while</span>(x&amp;&amp;val[x]!=v)&#123;</span><br><span class="line">		y=x;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x?x:y);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #####
按照排名访问 即查找树中第 <span class="math inline">\(k\)</span>
小的元素。利用记载的子树大小进行查找。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loc</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]&gt;=k)</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]+cnt[x]&gt;=k)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k-=siz[son[x][<span class="number">0</span>]]+cnt[x];</span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##### 合并 合并两棵
Splay 树，设根节点分别为 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span>，则需要 <span
class="math inline">\(x\)</span> 树中的最大值小于 <span
class="math inline">\(y\)</span> 中的最小值。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//x树中的最大值小于y树中的最小值，返回合并后的根节点</span></span><br><span class="line">	<span class="keyword">if</span>(!x||!y)</span><br><span class="line">		<span class="keyword">return</span> x|y;<span class="comment">//存在空树，直接返回</span></span><br><span class="line">	<span class="built_in">loc</span>(y,<span class="number">1</span>);<span class="comment">//将y树最小值移至根节点</span></span><br><span class="line">	son[y][<span class="number">0</span>]=x;<span class="comment">//此时y左节点必然为空</span></span><br><span class="line">	fa[x]=y;<span class="comment">//x成为y的左子树</span></span><br><span class="line">	<span class="built_in">push_up</span>(y);</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##### 分裂
根据某值 <span class="math inline">\(v\)</span>，将 Splay
树分裂为值小于等于 <span class="math inline">\(v\)</span> 和大于 <span
class="math inline">\(v\)</span> 两部分。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;<span class="comment">//通过引用返回分裂后的根节点a和b</span></span><br><span class="line">	<span class="comment">//x为当前根节点，按照权值v分裂为小于等于v和大于v两部分</span></span><br><span class="line">	<span class="keyword">if</span>(!x)&#123;</span><br><span class="line">		a=b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//树为空</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">find</span>(x,v);<span class="comment">//将权值为v的节点旋转到根节点</span></span><br><span class="line">	<span class="keyword">if</span>(val[x]&lt;=v)&#123;</span><br><span class="line">		a=x;</span><br><span class="line">		b=son[x][<span class="number">1</span>];</span><br><span class="line">		son[x][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		fa[b]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">push_up</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		b=x;</span><br><span class="line">		a=son[x][<span class="number">0</span>];</span><br><span class="line">		son[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		fa[a]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">push_up</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##### 插入
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z,y=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&amp;&amp;val[x]!=v)&#123;</span><br><span class="line">		y=x;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x)</span><br><span class="line">		cnt[x]++,siz[x]++;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		x=++tot;</span><br><span class="line">		val[x]=v;</span><br><span class="line">		cnt[x]=siz[x]=<span class="number">1</span>;</span><br><span class="line">		fa[x]=y;</span><br><span class="line">		<span class="keyword">if</span>(y)&#123;</span><br><span class="line">			<span class="keyword">if</span>(v&lt;val[y])</span><br><span class="line">				son[y][<span class="number">0</span>]=x;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				son[y][<span class="number">1</span>]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x);<span class="comment">//插入过后不要忘记转到根节点</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##### 删除 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="keyword">if</span>(!z||val[z]!=v)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//删除失败</span></span><br><span class="line">	cnt[z]--,siz[z]--;</span><br><span class="line">	<span class="keyword">if</span>(!cnt[z])&#123;<span class="comment">//该节点对应的值被删完了</span></span><br><span class="line">		<span class="type">int</span> x=son[z][<span class="number">0</span>],y=son[z][<span class="number">1</span>];</span><br><span class="line">		fa[x]=fa[y]=<span class="number">0</span>;</span><br><span class="line">		z=<span class="built_in">merge</span>(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//删除成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##### 查询排名 查询值 <span
class="math inline">\(v\)</span> 的排名。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_rank</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="type">int</span> res=siz[son[z][<span class="number">0</span>]]<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">if</span>(val[z]&lt;v)</span><br><span class="line">		res+=cnt[z];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##### 查询前驱
即查询小于 <span class="math inline">\(v\)</span> 的最大的数。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pre</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="keyword">if</span>(z&amp;&amp;val[z]&lt;v)</span><br><span class="line">		<span class="keyword">return</span> val[z];</span><br><span class="line">	<span class="type">int</span> x=son[z][<span class="number">0</span>];<span class="comment">//在左子树中查找最大值</span></span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span> -inf;</span><br><span class="line">	<span class="keyword">while</span>(son[x][<span class="number">1</span>])</span><br><span class="line">		x=son[x][<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span> val[z];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##### 查询后继 即查询大于 <span
class="math inline">\(v\)</span> 的最小的数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_nxt</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="keyword">if</span>(z&amp;&amp;val[z]&gt;v)</span><br><span class="line">		<span class="keyword">return</span> val[z];</span><br><span class="line">	<span class="type">int</span> x=son[z][<span class="number">1</span>];<span class="comment">//在右子树中查找最小值</span></span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span> inf;</span><br><span class="line">	<span class="keyword">while</span>(son[x][<span class="number">0</span>])</span><br><span class="line">		x=son[x][<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span> val[z];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ####
序列操作 ##### 区间翻转 我们需要在树中加入值为 <span
class="math inline">\(-inf\)</span> 和 <span
class="math inline">\(inf\)</span> 两个哨兵节点，防止翻转区间包含第
<span class="math inline">\(1\)</span>
个节点或最后一个节点时出事。与线段树类似，我们使用懒标记记录翻转情况。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="built_in">loc</span>(root,l);<span class="comment">//将l转至根节点</span></span><br><span class="line">	<span class="built_in">loc</span>(son[root][<span class="number">1</span>],r-l<span class="number">+2</span>);<span class="comment">//将r转至根节点的右儿子，由于根已改变，所以第二个参数传的是r-l+2</span></span><br><span class="line">	<span class="type">int</span> x=son[son[root][<span class="number">1</span>]][<span class="number">0</span>];<span class="comment">//根节点右儿子的左儿子，则x为区间[l,r]的根节点</span></span><br><span class="line">	<span class="built_in">update_tag</span>(x);</span><br><span class="line">	<span class="built_in">push_down</span>(x);</span><br><span class="line">	<span class="built_in">splay</span>(root,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 辅助操作 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tag</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">swap</span>(son[x][<span class="number">0</span>],son[x][<span class="number">1</span>]);</span><br><span class="line">	tag[x]^=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tag[x])&#123;</span><br><span class="line">		<span class="keyword">if</span>(son[x][<span class="number">0</span>])</span><br><span class="line">			<span class="built_in">update_tag</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span>(son[x][<span class="number">1</span>])</span><br><span class="line">			<span class="built_in">update_tag</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">		tag[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 同时，<span
class="math inline">\(\operatorname{loc}\)</span> 函数查找时要更新懒标记
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loc</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z;</span><br><span class="line">	<span class="built_in">push_down</span>(x);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]&gt;=k)</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]<span class="number">+1</span>&gt;=k)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k-=siz[son[x][<span class="number">0</span>]]<span class="number">+1</span>;</span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">push_down</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 无注释版代码</p>
<details>
<summary>
模板题 1 主体部分
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dir</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==son[fa[x]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	siz[x]=cnt[x]+siz[son[x][<span class="number">0</span>]]+siz[son[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> y=fa[x],z=fa[y];</span><br><span class="line">	<span class="type">bool</span> r=<span class="built_in">dir</span>(x);</span><br><span class="line">	son[y][r]=son[x][!r];</span><br><span class="line">	<span class="keyword">if</span>(son[x][!r])</span><br><span class="line">		fa[son[x][!r]]=y;</span><br><span class="line">	fa[x]=z;</span><br><span class="line">	<span class="keyword">if</span>(z)</span><br><span class="line">		son[z][<span class="built_in">dir</span>(y)]=x;</span><br><span class="line">	son[x][!r]=y;</span><br><span class="line">	fa[y]=x;</span><br><span class="line">	<span class="built_in">push_up</span>(y);</span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=fa[z];</span><br><span class="line">	<span class="keyword">while</span>(fa[x]!=temp)&#123;</span><br><span class="line">		<span class="type">int</span> y=fa[x];</span><br><span class="line">		<span class="keyword">if</span>(fa[y]!=temp)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dir</span>(x)==<span class="built_in">dir</span>(y))</span><br><span class="line">				<span class="built_in">rotate</span>(y);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">rotate</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rotate</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	z=x;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z,y=fa[x];</span><br><span class="line">	<span class="keyword">while</span>(x&amp;&amp;val[x]!=v)&#123;</span><br><span class="line">		y=x;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x?x:y);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loc</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]&gt;=k)</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]+cnt[x]&gt;=k)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k-=siz[son[x][<span class="number">0</span>]]+cnt[x];</span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x||!y)</span><br><span class="line">		<span class="keyword">return</span> x|y;</span><br><span class="line">	<span class="built_in">loc</span>(y,<span class="number">1</span>);</span><br><span class="line">	son[y][<span class="number">0</span>]=x;</span><br><span class="line">	fa[x]=y;</span><br><span class="line">	<span class="built_in">push_up</span>(y);</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z,y=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&amp;&amp;val[x]!=v)&#123;</span><br><span class="line">		y=x;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x)</span><br><span class="line">		cnt[x]++,siz[x]++;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		x=++tot;</span><br><span class="line">		val[x]=v;</span><br><span class="line">		cnt[x]=siz[x]=<span class="number">1</span>;</span><br><span class="line">		fa[x]=y;</span><br><span class="line">		<span class="keyword">if</span>(y)&#123;</span><br><span class="line">			<span class="keyword">if</span>(v&lt;val[y])</span><br><span class="line">				son[y][<span class="number">0</span>]=x;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				son[y][<span class="number">1</span>]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="keyword">if</span>(!z||val[z]!=v)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	cnt[z]--,siz[z]--;</span><br><span class="line">	<span class="keyword">if</span>(!cnt[z])&#123;</span><br><span class="line">		<span class="type">int</span> x=son[z][<span class="number">0</span>],y=son[z][<span class="number">1</span>];</span><br><span class="line">		fa[x]=fa[y]=<span class="number">0</span>;</span><br><span class="line">		z=<span class="built_in">merge</span>(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_rank</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="type">int</span> res=siz[son[z][<span class="number">0</span>]]<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">if</span>(val[z]&lt;v)</span><br><span class="line">		res+=cnt[z];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pre</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="keyword">if</span>(z&amp;&amp;val[z]&lt;v)</span><br><span class="line">		<span class="keyword">return</span> val[z];</span><br><span class="line">	<span class="type">int</span> x=son[z][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(son[x][<span class="number">1</span>])</span><br><span class="line">		x=son[x][<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span> val[z];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_nxt</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(z,v);</span><br><span class="line">	<span class="keyword">if</span>(z&amp;&amp;val[z]&gt;v)</span><br><span class="line">		<span class="keyword">return</span> val[z];</span><br><span class="line">	<span class="type">int</span> x=son[z][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(son[x][<span class="number">0</span>])</span><br><span class="line">		x=son[x][<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span> val[z];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>
模板题 2 主体部分
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>],fa[N],tot,val[N],siz[N],root;</span><br><span class="line"><span class="type">bool</span> tag[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dir</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==son[fa[x]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	siz[x]=<span class="number">1</span>+siz[son[x][<span class="number">0</span>]]+siz[son[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tag</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">swap</span>(son[x][<span class="number">0</span>],son[x][<span class="number">1</span>]);</span><br><span class="line">	tag[x]^=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tag[x])&#123;</span><br><span class="line">		<span class="keyword">if</span>(son[x][<span class="number">0</span>])</span><br><span class="line">			<span class="built_in">update_tag</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span>(son[x][<span class="number">1</span>])</span><br><span class="line">			<span class="built_in">update_tag</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">		tag[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> y=fa[x],z=fa[y];</span><br><span class="line">	<span class="type">bool</span> r=<span class="built_in">dir</span>(x);</span><br><span class="line">	son[y][r]=son[x][!r];</span><br><span class="line">	<span class="keyword">if</span>(son[x][!r])</span><br><span class="line">		fa[son[x][!r]]=y;</span><br><span class="line">	fa[x]=z;</span><br><span class="line">	<span class="keyword">if</span>(z)</span><br><span class="line">		son[z][<span class="built_in">dir</span>(y)]=x;</span><br><span class="line">	son[x][!r]=y;</span><br><span class="line">	fa[y]=x;</span><br><span class="line">	<span class="built_in">push_up</span>(y);</span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=fa[z];</span><br><span class="line">	<span class="keyword">while</span>(fa[x]!=temp)&#123;</span><br><span class="line">		<span class="type">int</span> y=fa[x];</span><br><span class="line">		<span class="keyword">if</span>(fa[y]!=temp)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dir</span>(x)==<span class="built_in">dir</span>(y))</span><br><span class="line">				<span class="built_in">rotate</span>(y);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">rotate</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rotate</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	z=x;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loc</span><span class="params">(<span class="type">int</span> &amp;z,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=z;</span><br><span class="line">	<span class="built_in">push_down</span>(x);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]&gt;=k)</span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]<span class="number">+1</span>&gt;=k)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k-=siz[son[x][<span class="number">0</span>]]<span class="number">+1</span>;</span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">push_down</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(z,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="built_in">loc</span>(root,l);</span><br><span class="line">	<span class="built_in">loc</span>(son[root][<span class="number">1</span>],r-l<span class="number">+2</span>);</span><br><span class="line">	<span class="type">int</span> x=son[son[root][<span class="number">1</span>]][<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">update_tag</span>(x);</span><br><span class="line">	<span class="built_in">push_down</span>(x);</span><br><span class="line">	<span class="built_in">splay</span>(root,x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">+1</span>;i++)&#123;</span><br><span class="line">		son[++tot][<span class="number">0</span>]=root;</span><br><span class="line">		<span class="keyword">if</span>(root)</span><br><span class="line">			fa[root]=tot;</span><br><span class="line">		root=tot;</span><br><span class="line">		val[tot]=i;</span><br><span class="line">		siz[tot]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">push_up</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(root,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="treap">Treap</h3>
<p>Treap
将二叉搜索树与堆结合起来，通过维护堆的性质维护平衡。所以每个节点需要额外维护一个随机的值，用这个随机的值来维护堆的性质。这里介绍旋转
Treap，即通过旋转维护平衡性。 #### 无注释版代码</p>
<details>
<summary>
Code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>],val[N],rnd[N],siz[N],cnt[N],tot,root;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	siz[x]=cnt[x]+siz[son[x][<span class="number">0</span>]]+siz[son[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">bool</span> dir)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=son[x][!dir];</span><br><span class="line">	son[x][!dir]=son[temp][dir];</span><br><span class="line">	son[temp][dir]=x;</span><br><span class="line">	x=temp;</span><br><span class="line">	<span class="built_in">push_up</span>(son[x][dir]);</span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)&#123;</span><br><span class="line">		x=++tot;</span><br><span class="line">		siz[x]=cnt[x]=<span class="number">1</span>;</span><br><span class="line">		val[x]=v;</span><br><span class="line">		rnd[x]=<span class="built_in">rand</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(val[x]==v)</span><br><span class="line">		cnt[x]++;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">bool</span> dir=(v&gt;val[x]);</span><br><span class="line">		<span class="built_in">insert</span>(son[x][dir],v);</span><br><span class="line">		<span class="keyword">if</span>(rnd[x]&lt;rnd[son[x][dir]])</span><br><span class="line">			<span class="built_in">rotate</span>(x,!dir);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">		<span class="built_in">erase</span>(son[x][<span class="number">0</span>],v);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(v&gt;val[x])</span><br><span class="line">		<span class="built_in">erase</span>(son[x][<span class="number">1</span>],v);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt[x]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">			cnt[x]--;</span><br><span class="line">			<span class="built_in">push_up</span>(x);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(son[x][<span class="number">0</span>]||son[x][<span class="number">1</span>])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!son[x][<span class="number">1</span>]||rnd[son[x][<span class="number">0</span>]]&gt;rnd[son[x][<span class="number">1</span>]])</span><br><span class="line">				<span class="built_in">rotate</span>(x,<span class="number">1</span>),<span class="built_in">erase</span>(son[x][<span class="number">1</span>],v);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">rotate</span>(x,<span class="number">0</span>),<span class="built_in">erase</span>(son[x][<span class="number">0</span>],v);</span><br><span class="line">			<span class="built_in">push_up</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_rank</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v==val[x])</span><br><span class="line">		<span class="keyword">return</span> siz[son[x][<span class="number">0</span>]]<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">find_rank</span>(son[x][<span class="number">0</span>],v);</span><br><span class="line">	<span class="keyword">return</span> siz[son[x][<span class="number">0</span>]]+cnt[x]+<span class="built_in">find_rank</span>(son[x][<span class="number">1</span>],v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]&gt;=k)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">find</span>(son[x][<span class="number">0</span>],k);</span><br><span class="line">	<span class="keyword">if</span>(siz[son[x][<span class="number">0</span>]]+cnt[x]&gt;=k)</span><br><span class="line">		<span class="keyword">return</span> val[x];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(son[x][<span class="number">1</span>],k-siz[son[x][<span class="number">0</span>]]-cnt[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pre</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=root,pre;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v&gt;val[x])</span><br><span class="line">			pre=val[x],x=son[x][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=son[x][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_nxt</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=root,nxt;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;val[x])</span><br><span class="line">			nxt=val[x],x=son[x][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=son[x][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nxt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="fhq-treap">FHQ Treap</h3>
<p>即无旋转操作的
Treap，通过分裂和合并来维护平衡性。因其无旋，所以可以做可持久化数据结构，并且是平衡树中比较好写的一种。缺点是常数较大。</p>
<details>
<summary>
模板题 1 AC 代码
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FHQ_Treap</span>&#123;</span><br><span class="line">	<span class="type">int</span> ls,rs;</span><br><span class="line">	<span class="type">int</span> val,rnd,siz;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> root,tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	t[u].siz=t[t[u].ls].siz+t[t[u].rs].siz<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	t[++tot].rnd=<span class="built_in">rand</span>()&lt;&lt;<span class="number">15</span>|<span class="built_in">rand</span>();</span><br><span class="line">	t[tot].siz=<span class="number">1</span>;</span><br><span class="line">	t[tot].val=val;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> val,<span class="type">int</span> &amp;lrt,<span class="type">int</span> &amp;rrt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p)&#123;</span><br><span class="line">		lrt=rrt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[p].val&lt;=val)&#123;</span><br><span class="line">		lrt=p;</span><br><span class="line">		<span class="built_in">split</span>(t[p].rs,val,t[p].rs,rrt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		rrt=p;</span><br><span class="line">		<span class="built_in">split</span>(t[p].ls,val,lrt,t[p].ls);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!l||!r)</span><br><span class="line">		<span class="keyword">return</span> l|r;</span><br><span class="line">	<span class="keyword">if</span>(t[l].rnd&gt;t[r].rnd)&#123;</span><br><span class="line">		t[l].rs=<span class="built_in">merge</span>(t[l].rs,r);</span><br><span class="line">		<span class="built_in">push_up</span>(l);</span><br><span class="line">		<span class="keyword">return</span> l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		t[r].ls=<span class="built_in">merge</span>(l,t[r].ls);</span><br><span class="line">		<span class="built_in">push_up</span>(r);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">split</span>(root,val,x,y);</span><br><span class="line">	root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,<span class="built_in">build</span>(val)),y);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,temp;</span><br><span class="line">	<span class="built_in">split</span>(root,val,x,y);</span><br><span class="line">	<span class="built_in">split</span>(x,val<span class="number">-1</span>,x,temp);</span><br><span class="line">	temp=<span class="built_in">merge</span>(t[temp].ls,t[temp].rs);</span><br><span class="line">	root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,temp),y);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_rank</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">split</span>(root,val<span class="number">-1</span>,x,y);</span><br><span class="line">	<span class="type">int</span> res=t[x].siz<span class="number">+1</span>;</span><br><span class="line">	root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_kth</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=root;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(t[t[p].ls].siz<span class="number">+1</span>==k)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t[t[p].ls].siz<span class="number">+1</span>&gt;k)</span><br><span class="line">			p=t[p].ls;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			k-=t[t[p].ls].siz<span class="number">+1</span>,p=t[p].rs;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t[p].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">split</span>(root,val<span class="number">-1</span>,x,y);</span><br><span class="line">	<span class="type">int</span> p=x;</span><br><span class="line">	<span class="keyword">while</span>(t[p].rs)</span><br><span class="line">		p=t[p].rs;</span><br><span class="line">	root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span> t[p].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nxt</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">split</span>(root,val,x,y);</span><br><span class="line">	<span class="type">int</span> p=y;</span><br><span class="line">	<span class="keyword">while</span>(t[p].ls)</span><br><span class="line">		p=t[p].ls;</span><br><span class="line">	root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span> t[p].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,opt,x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;opt,&amp;x);</span><br><span class="line">		<span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="built_in">insert</span>(x);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="built_in">erase</span>(x);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find_rank</span>(x));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find_kth</span>(x));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">pre</span>(x));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">nxt</span>(x));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p><a href="https://www.luogu.com.cn/problem/P3369"
title="模板题 1">模板题 1</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3391"
title="模板题 2">模板题 2</a></p>
<p><a href="https://oi-wiki.org/ds/bst/"
title="参考资料">参考资料</a></p>
<p><a href="https://www.deepseek.com/"
title="特别鸣谢">特别鸣谢</a>，为我解答了很多问题，以及帮我进行代码的修正。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>初等数论</title>
    <url>/2025/07/15/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<p>之前写几篇数论文章已经忘了，而且写的也不是很美丽，正巧今天讲课讲了一遍数论，那就当从头复习一遍。<br />
### 符号与约定<br />
非特殊声明下，本文所涉及的数均为非负整数。<br />
<span class="math inline">\(a\mid b\)</span> 表示 <span
class="math inline">\(b\)</span> 是 <span
class="math inline">\(a\)</span> 的倍数，<span
class="math inline">\(a\)</span> 是 <span
class="math inline">\(b\)</span> 的约数。<br />
<span class="math inline">\(\gcd(a,b)\)</span> 表示 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span>
的最大公约数。在不引起混淆的前提下可记作 <span
class="math inline">\((a,b)\)</span>。<br />
<span class="math inline">\(\operatorname{lcm}(a,b)\)</span> 表示 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span>
的最小公倍数。在不引起混淆的前提下可记作 <span
class="math inline">\([a,b]\)</span>。<br />
### 素数<br />
数量估计：小于等于 <span class="math inline">\(x\)</span>
的素数<strong>约有</strong> <span class="math inline">\(\dfrac{x}{\ln
x}\)</span> 个。<br />
#### 埃拉托斯特尼筛法<br />
原理：所有合数必然都有素因子，则我们可以采用“标记”的思想，若遇到一个未被标记的数，则其必为素数，并将它的所有倍数标记。反之它就是合数。时间复杂度
<span class="math inline">\(O(n\log \log
n)\)</span>。我不会证。简单的优化是标记数组使用
<code>std::bitset</code>，性能甚至超越了 <span
class="math inline">\(O(n)\)</span> 的线性筛法。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e7</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">bitset&lt;N&gt; p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="number">1e7</span>;</span><br><span class="line">    p.<span class="built_in">set</span>();</span><br><span class="line">    p[<span class="number">0</span>]=p[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)</span><br><span class="line">        <span class="keyword">if</span>(p[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j+=i)</span><br><span class="line">                p[j]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 外层循环只需执行到 <span
class="math inline">\(\sqrt{n}\)</span> 即可。使用安全的除法运算防止
<code>int</code> 溢出。<br />
#### 线性筛法<br />
也叫欧拉筛法。其时间复杂度为线性的原因是每个合数仅会被标记 <span
class="math inline">\(1\)</span>
次。更为重要的是，在筛出所有质数的同时也能求出所有数的最小质因子，可以优化质因数分解。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e7</span><span class="number">+10</span>,M=<span class="number">7e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,p[M],e[N],tot;<span class="comment">//e[i]存储i的最小质因子在p[]中的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="number">1e7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!e[i]) p[e[i]=++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=e[i]&amp;&amp;p[j]&lt;=n/i;j++)</span><br><span class="line">            e[p[j]*i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 算术基本定理<br />
任何一个数 <span
class="math inline">\(n\)</span>，都可以表示为有限个素数之积。即可以表示为：
<span class="math display">\[n=\prod p_i^{\alpha_i}\]</span>
这也是标准素因数分解式。<br />
根据这个式子，设 <span class="math inline">\(a=\prod
p_i^{\alpha_i}\)</span>，<span class="math inline">\(b=\prod
p_i^{\beta_i}\)</span>，则 <span
class="math inline">\(\gcd(a,b)\)</span> 可表示为 <span
class="math inline">\(\prod p_i^{\min(\alpha_i,\beta_i)}\)</span>，<span
class="math inline">\(\operatorname{lcm}(a,b)\)</span> 可表示为 <span
class="math inline">\(\prod
p_i^{\max(\alpha_i,\beta_i)}\)</span>。根据这个定义，容易证明 <span
class="math display">\[\gcd(a,b)\times \operatorname{lcm}(a,b)=a\times
b\]</span> ### 同余<br />
#### 求最大公约数<br />
辗转相除法，又名欧几里得算法。原理：<span
class="math inline">\(\gcd(a,b)=\gcd(b,a\bmod
b)\)</span>。递归执行，边界为 <span
class="math inline">\(\gcd(a,0)=a\)</span>。时间复杂度 <span
class="math inline">\(O(\log \min(a,b))\)</span>。 #### 裴蜀定理<br />
对于 <span class="math inline">\(a,b\)</span>，存在 <span
class="math inline">\(x,y\)</span> 使得<br />
<span class="math display">\[ax+by=\gcd(a,b)\]</span> 并且方程 <span
class="math inline">\(ax+by=c\)</span> 有解当且仅当 <span
class="math inline">\(\gcd(a,b)\mid
c\)</span>。以下是求解过程的推导：<br />
<span class="math display">\[\begin{aligned}
ax+by&amp;=\gcd(a,b)\\
&amp;=\gcd(b,a\bmod b)\\
&amp;=bx&#39;+(a-b\times \lfloor\frac{a}{b}\rfloor)y&#39;\\
&amp;=ay&#39;+b(x&#39;-\lfloor\frac{a}{b}\rfloor y&#39;)
\end{aligned}\]</span>
像欧几里得算法一样递归求解即可。这个算法叫做扩展欧几里得算法。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,x,y);</span><br><span class="line">    <span class="type">int</span> temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 逆元<br />
线性求法：<br />
要求模数 <span class="math inline">\(p\)</span>
为<strong>质数</strong>。显然在 <span class="math inline">\(i=1\)</span>
时 <span class="math inline">\(i^{-1}=1\)</span>，考虑 <span
class="math inline">\(i&gt;1\)</span> 的情况。设 <span
class="math inline">\(k=\lfloor\dfrac{p}{i}\rfloor,j=p\bmod
i\)</span>，则 <span class="math inline">\(p=ki+j\)</span>。则 <span
class="math inline">\(ki+j\equiv 0 \pmod p\)</span>，两边同时乘 <span
class="math inline">\(i^{-1}j^{-1}\)</span>，得 <span
class="math inline">\(kj^{-1}+i^{-1}\equiv 0\pmod p\)</span>，移项并回代
<span class="math inline">\(k,j\)</span>，得 <span
class="math inline">\(i^{-1}\equiv
-\lfloor\dfrac{p}{i}\rfloor\times(p\bmod i)^{-1} \pmod p\)</span>
实际操作中为了避免负数，可以将 <span
class="math inline">\(-\lfloor\dfrac{p}{i}\rfloor\)</span> 替换为 <span
class="math inline">\(p-\lfloor\dfrac{p}{i}\rfloor\)</span>。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    inv[i]=(<span class="type">long</span> <span class="type">long</span>)(p-p/i)*inv[p%i]%p;</span><br></pre></td></tr></table></figure> 不过一般都直接用费马小定理快速幂求出。 #### 欧拉函数<br />
定义欧拉函数 <span class="math inline">\(\varphi(n)\)</span> 为 <span
class="math inline">\(1\sim n\)</span> 中与 <span
class="math inline">\(n\)</span> 互素的数的个数。<br />
<span class="math display">\[\varphi(n)=n\prod
\frac{p_i-1}{p_i}\]</span> 证明：容斥，但我不会。<br />
欧拉定理：<br />
若 <span class="math inline">\(a,m\)</span> <strong>互质</strong>，则
<span class="math inline">\(a^{\varphi(m)}\equiv 1\pmod
m\)</span>。<br />
扩展欧拉定理： <span class="math display">\[a^b\equiv
\begin{cases}a^{b\bmod \varphi(m)},&amp;\gcd(a,m)=1,\\
a^b,&amp;\gcd(a,m)\ne 1,b&lt;\varphi(m),\\
a^{(b\bmod\varphi(m))+\varphi(m)},&amp;\gcd(a,m)\ne 1,b\ge\varphi(m).
\end{cases}
\pmod m
\]</span> 都不会证。 ### 线性同余方程组<br />
#### 扩展中国剩余定理<br />
又称 exCRT。<br />
给定同余方程组<br />
<span class="math display">\[\begin{cases}
x\equiv a_1\pmod {m_1},\\
x\equiv a_2\pmod {m_2},\\
\cdots\\
x\equiv a_n\pmod {m_n}.
\end{cases}\]</span> 在模数<strong>不保证</strong>互质的情况下求解 <span
class="math inline">\(x\)</span>。<br />
原理：exCRT 的本质是合并线性同余方程。<br />
定理：若方程组有解，则解在模 <span
class="math inline">\(\operatorname{lcm}(m_1,m_2,\cdots,m_n)\)</span>
意义下唯一，否则无解。<br />
求解过程：<br />
考虑 <span class="math inline">\(2\)</span> 个同余方程的情况： <span
class="math display">\[\begin{cases}
x\equiv a_1\pmod {m_1},\\
x\equiv a_2\pmod {m_2}.
\end{cases}\]</span> 设 <span
class="math inline">\(x=k_1m_1+a_1=k_2m_2+a_2\)</span>，则 <span
class="math inline">\(k_1m_1-k_2m_2=a_2-a_1\)</span>。注意：根据裴蜀定理，当且仅当
<span class="math inline">\(\gcd(m_1,m_2)\mid (a_2-a_1)\)</span>
时此方程有解。设 <span
class="math inline">\(d=\gcd(m_1,m_2)\)</span>，原式写为 <span
class="math inline">\(\dfrac{m_1}{d}k_1-\dfrac{m_2}{d}k_2=\dfrac{a_2-a_1}{d}\)</span>，设
<span
class="math inline">\(m_1&#39;=\dfrac{m_1}{d},m_2&#39;=\dfrac{m_2}{d},c=\dfrac{a_2-a_1}{d}\)</span>，则方程变为：<br />
<span class="math display">\[m_1&#39;k_1+m_2&#39;k_2=c\]</span> 因为
<span
class="math inline">\(\gcd(m_1&#39;,m_2&#39;)=1\)</span>，所以可以直接用扩展欧几里得算法求出
<span class="math inline">\(k_1\)</span> 的一个特解 <span
class="math inline">\(k_1^*\)</span>。<span
class="math inline">\(k_1\)</span> 的通解为 <span
class="math inline">\(k_1=k_1^*+t\times m_2&#39;\)</span>，代回，得到
<span class="math inline">\(x\)</span> 的通解为<br />
<span class="math display">\[\begin{aligned}
x&amp;=k_1m_1+a_1\\
&amp;=(k_1^*+t\times m_2&#39;)m_1+a_1\\
&amp;=m_1k_1^*+a_1+t\times m_1m_2&#39;
\end{aligned}\]</span> 注意到 <span
class="math inline">\(m_1m_2&#39;=\dfrac{m_1m_2}{d}=\operatorname{lcm}(m_1,m_2)\)</span>，所以有<br />
<span class="math display">\[x\equiv
m_1k_1^*+a_1\pmod{\operatorname{lcm}(m_1,m_2)}\]</span>
至此，我们成功合并了两个方程。<br />
对于 <span class="math inline">\(n\)</span>
个方程的合并，只需重复以上步骤，一直合并到只剩一个方程 <span
class="math inline">\(x\equiv A\pmod M\)</span>，其中 <span
class="math inline">\(M=\operatorname{lcm}(m_1,m_2,\cdots,m_n)\)</span>。时间复杂度
<span class="math inline">\(O(n\log M)\)</span>。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exCRT</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1=a[<span class="number">1</span>],m1=m[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a2=a[i],m2=m[i];</span><br><span class="line">        <span class="type">int</span> k1,k2;</span><br><span class="line">        <span class="type">int</span> d=<span class="built_in">exgcd</span>(m1,m2,k1,k2);</span><br><span class="line">        <span class="keyword">if</span>((a2-a1)%d!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        k1*=(a2-a1)/d;</span><br><span class="line">        <span class="type">int</span> t=m2/d;</span><br><span class="line">        k1=(k1%t+t)%t;</span><br><span class="line">        a1+=k1*m1;</span><br><span class="line">        m1=m1/d*m2;</span><br><span class="line">        a1=(a1%m1+m1)%m1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 其他<br />
附表：<br />
<img
src="https://github.com/headless-piston/blog_images/blob/main/prime.jpg?raw=true" /></p>
<p>参考资料：<br />
https://oi-wiki.org/math/ https://www.cnblogs.com/Tmbcan/p/18903233</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>双语歌词修复器</title>
    <url>/2025/07/14/%E5%8F%8C%E8%AF%AD%E6%AD%8C%E8%AF%8D%E4%BF%AE%E5%A4%8D%E5%99%A8/</url>
    <content><![CDATA[<p>lyh 大爷给的音乐网站相当好用，但是上面的歌词下载下来全 tm
有问题啊。这严重影响了开摆的体验…… ### 前置知识 #### lrc 文件
歌词文件的扩展名一般为 <code>.lrc</code>，电脑中的 music player 如
PotPlayer 在播放某音乐时会自动在与音乐文件相同的路径下查找同名 lrc
文件。如果查到，就会在播放音乐时同步渲染出歌词。<br />
你可以直接用记事本打开 lrc
文件，然后就会发现里面的内容大约为这个格式：<br />
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[11:45.14]Wha↗t↘ can I↗↘say~</span><br><span class="line">[19:19.81]Man↗ba↗ o↗ut~</span><br></pre></td></tr></table></figure> <code>[]</code>
内的东西叫做时间戳，表示应该啥时候渲染出这一句歌词。而如果是中英双语的歌词，大概是这样的：<br />
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[11:45.14]Wha↗t↘ can I↗↘say~</span><br><span class="line">[11:45.14]我能说什么</span><br><span class="line">[19:19.81]Man↗ba↗ o↗ut~</span><br><span class="line">[19:19.81]曼巴出来</span><br></pre></td></tr></table></figure> 对应的中文翻译的时间戳应当与英文的一样。<br />
#### 中文的编码方式 我们知道英文可以用 ASCII 码，每个字符 <span
class="math inline">\(1\)</span> 字节，然而中文的编码一般是每个字占
<span class="math inline">\(2\)</span>
字节甚至更多，正常程序中对中文字符串的某位进行处理可能导致表示同一个字的多字节中的其中一个改变，而其他的没变，最终变为乱码。<br />
### 问题分析 我们发现，从网站上下载下来的歌词文件长这样：</p>
<details>
<summary>
Take Me Hand-DAISHI DANCE&amp;Cécile Corbel.lrc
</summary>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[00:00.0]Take Me Hands - DAISHI DANCE/</span><br><span class="line">[00:23.83] </span><br><span class="line">[00:23.83]Lyrics by：Cecile Corbel</span><br><span class="line">[00:36.89] </span><br><span class="line">[00:36.89]Composed by：DAISHI DANCE/Tomoharu Moriya</span><br><span class="line">[00:59.59] </span><br><span class="line">[00:59.59]In my dreams</span><br><span class="line">[01:01.49]在我的梦里</span><br><span class="line">[01:01.49]I feel your light</span><br><span class="line">[01:03.38]我感受到了你的光芒</span><br><span class="line">[01:03.38]I feel love is born again</span><br><span class="line">[01:07.01]我感受到了爱的重生</span><br><span class="line">[01:07.01]Fireflies</span><br><span class="line">[01:09.020004]萤火虫</span><br><span class="line">[01:09.020004]In the moonlight</span><br><span class="line">[01:10.84]在月光下</span><br><span class="line">[01:10.84]Rising stars</span><br><span class="line">[01:14.479996]随着星星闪耀</span><br><span class="line">[01:14.479996]Remember</span><br><span class="line">[01:16.979996]记住</span><br><span class="line">[01:16.979996]The day</span><br><span class="line">[01:19.11]这个日子</span><br><span class="line">[01:19.11]I fell in love with you</span><br><span class="line">[01:22.03]我与你相爱</span><br><span class="line">[01:22.03]Darling won&#x27;t you break</span><br><span class="line">[01:26.12]亲爱的 你不会</span><br><span class="line">[01:26.12]My heart</span><br><span class="line">[01:29.979996]让我心碎</span><br><span class="line">[01:29.979996]Take my hand now</span><br><span class="line">[01:31.75]牵着我的手</span><br><span class="line">[01:31.75]Stay close to me</span><br><span class="line">[01:33.81]贴近我的心</span><br><span class="line">[01:33.81]Be my lover</span><br><span class="line">[01:35.68]做我的爱人</span><br><span class="line">[01:35.68]Won&#x27;t you let me go</span><br><span class="line">[01:37.53]你不会让我离开</span><br><span class="line">[01:37.53]Close your eyes now</span><br><span class="line">[01:39.5]现在 闭上你的双眼</span><br><span class="line">[01:39.5]And you will see</span><br><span class="line">[01:41.34]你将会看到</span><br><span class="line">[01:41.34]There&#x27;s a rainbow</span><br><span class="line">[01:43.21]有一道彩虹</span><br><span class="line">[01:43.21]For you and me</span><br><span class="line">[01:59.64]专属你我</span><br><span class="line">[01:59.64]As I wake up</span><br><span class="line">[02:01.58]当我醒来</span><br><span class="line">[02:01.58]I see your face</span><br><span class="line">[02:03.49]看着你的脸庞</span><br><span class="line">[02:03.49]I feel love is born again</span><br><span class="line">[02:07.02]我感受到了爱的重生</span><br><span class="line">[02:07.02]Cherry blossom</span><br><span class="line">[02:08.9]樱花烂漫</span><br><span class="line">[02:08.9]Flying birds</span><br><span class="line">[02:10.84]鸟儿飞翔</span><br><span class="line">[02:10.84]In the sky</span><br><span class="line">[02:14.64]在天空里</span><br><span class="line">[02:14.64]Can&#x27;t you see</span><br><span class="line">[02:16.85]你是否看得见</span><br><span class="line">[02:16.85]The sun</span><br><span class="line">[02:18.34]阳光</span><br><span class="line">[02:18.34]That is shining on the fields</span><br><span class="line">[02:22.12]照射着大地</span><br><span class="line">[02:22.12]Is it shining in</span><br><span class="line">[02:26.33]它是否照射进</span><br><span class="line">[02:26.33]Your heart</span><br><span class="line">[02:29.99]你的心里</span><br><span class="line">[02:29.99]Take my hand now</span><br><span class="line">[02:31.75]牵着我的手</span><br><span class="line">[02:31.75]Stay close to me</span><br><span class="line">[02:33.81]贴近我的心</span><br><span class="line">[02:33.81]Be my lover</span><br><span class="line">[02:35.68]做我的爱人</span><br><span class="line">[02:35.68]Won&#x27;t you let me go</span><br><span class="line">[02:37.54001]你不会让我离开</span><br><span class="line">[02:37.54001]Close your eyes now</span><br><span class="line">[02:39.52]现在 闭上你的双眼</span><br><span class="line">[02:39.52]And you will see</span><br><span class="line">[02:41.33]你将会看到</span><br><span class="line">[02:41.33]There&#x27;s a rainbow</span><br><span class="line">[02:43.20999]有一道彩虹</span><br><span class="line">[02:43.20999]For you and me</span><br><span class="line">[02:59.65]专属你我</span><br><span class="line">[02:59.65]And I dream of you</span><br><span class="line">[03:03.36]我都梦见你</span><br><span class="line">[03:03.36]Every night</span><br><span class="line">[03:06.95]在每一个夜晚</span><br><span class="line">[03:06.95]Cause&#x27;s there only you</span><br><span class="line">[03:10.9]因为 是否只有你</span><br><span class="line">[03:10.9]In my mind</span><br><span class="line">[03:14.49]在我的心里</span><br><span class="line">[03:14.49]Will you be</span><br><span class="line">[03:16.99]你会是</span><br><span class="line">[03:16.99]A stranger or a friend in my life</span><br><span class="line">[03:22.13]我生命中的陌生人 还是一个朋友</span><br><span class="line">[03:22.13]Darling won&#x27;t you break</span><br><span class="line">[03:25.9]亲爱的 你不会</span><br><span class="line">[03:25.9]My heart</span><br><span class="line">[03:29.99]让我心碎</span><br><span class="line">[03:29.99]Take my hand now</span><br><span class="line">[03:31.75]牵着我的手</span><br><span class="line">[03:31.75]Stay close to me</span><br><span class="line">[03:33.83]贴近我的心</span><br><span class="line">[03:33.83]Be my lover</span><br><span class="line">[03:35.67]做我的爱人</span><br><span class="line">[03:35.67]Won&#x27;t you let me go</span><br><span class="line">[03:37.52]你不会让我离开</span><br><span class="line">[03:37.52]Close your eyes now</span><br><span class="line">[03:39.47]现在 闭上你的双眼</span><br><span class="line">[03:39.47]And you will see</span><br><span class="line">[03:41.33]你将会看到</span><br><span class="line">[03:41.33]There&#x27;s a rainbow</span><br><span class="line">[03:43.2]有一道彩虹</span><br><span class="line">[03:43.2]For you and me</span><br><span class="line">[03:45.0]专属你我</span><br><span class="line">[03:45.0]Take my hand now</span><br><span class="line">[03:46.75]牵着我的手</span><br><span class="line">[03:46.75]Stay close to me</span><br><span class="line">[03:48.8]贴近我的心</span><br><span class="line">[03:48.8]Be my lover</span><br><span class="line">[03:50.67]做我的爱人</span><br><span class="line">[03:50.67]Won&#x27;t you let me go</span><br><span class="line">[03:52.52]你不会让我离开</span><br><span class="line">[03:52.52]Close your eyes now</span><br><span class="line">[03:54.51]现在 闭上你的双眼</span><br><span class="line">[03:54.51]And you will see</span><br><span class="line">[03:56.33]你将会看到</span><br><span class="line">[03:56.33]There&#x27;s a rainbow</span><br><span class="line">[03:58.19]有一道彩虹</span><br><span class="line">[03:58.19]For you and me</span><br><span class="line">[03:59.7]专属你我</span><br><span class="line">[03:59.7]Darling take my hand now</span><br><span class="line">[04:02.3]牵着我的手</span><br><span class="line">[04:02.3]Stay close to me</span><br><span class="line">[04:03.86]贴近我的心</span><br><span class="line">[04:03.86]Be my lover</span><br><span class="line">[04:05.93]做我的爱人</span><br><span class="line">[04:05.93]Won&#x27;t you let me go</span><br><span class="line">[04:07.35]不要放开我的手</span><br><span class="line">[04:07.35]Close your eyes now</span><br><span class="line">[04:08.76]现在 闭上你的双眼</span><br><span class="line">[04:08.76]And you will see</span><br><span class="line">[04:11.34]你将会看到</span><br><span class="line">[04:11.34]There&#x27;s a rainbow</span><br><span class="line">[04:13.19]有一道彩虹</span><br><span class="line">[04:13.19]For you and me</span><br><span class="line">[04:13.21]专属你我</span><br></pre></td></tr></table></figure>
</details>
<p>问题主要有两个：<br />
1. 全错位了，除了第一行，其他每行都应使用上一行的时间戳 1.
有的时间戳长的吓人，这样的时间戳会导致渲染错误。经我实测，删掉后面多余的部分对渲染没有影响，所以我们直接丢弃超出正常长度的部分就行。</p>
<p>所以我们编写程序对这种格式错误进行修复。<br />
为了解决中文乱码问题，我们使用 <code>fstream</code> 而不是传统的 I/O
方式。<br />
### code <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> f=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;.lrc&quot;</span>,ios::binary)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;fixed.lrc&quot;</span>,ios::binary)</span></span>;</span><br><span class="line">    out&lt;&lt;<span class="built_in">char</span>(<span class="number">0xEF</span>)&lt;&lt;<span class="built_in">char</span>(<span class="number">0xBB</span>)&lt;&lt;<span class="built_in">char</span>(<span class="number">0xBF</span>);<span class="comment">//防中文乱码</span></span><br><span class="line">    string line,last_time;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in,line))&#123;</span><br><span class="line">        <span class="keyword">if</span>(line.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            out&lt;&lt;last_time&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it=--line.<span class="built_in">end</span>();</span><br><span class="line">        <span class="keyword">while</span>(it!=line.<span class="built_in">begin</span>()&amp;&amp;*it==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            line.<span class="built_in">erase</span>(it--);<span class="comment">//去除行末空格</span></span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(line[pos]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(line[pos++]);</span><br><span class="line">            <span class="keyword">while</span>(pos&lt;(<span class="type">int</span>)line.<span class="built_in">length</span>()&amp;&amp;line[pos]!=<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                s.<span class="built_in">push_back</span>(line[pos++]);</span><br><span class="line">            <span class="keyword">if</span>(pos&lt;(<span class="type">int</span>)line.<span class="built_in">length</span>())</span><br><span class="line">                s.<span class="built_in">push_back</span>(line[pos++]);</span><br><span class="line">        &#125;<span class="comment">//截取时间戳</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()&gt;<span class="number">9</span>)</span><br><span class="line">            s.<span class="built_in">erase</span>(<span class="number">9</span>),s.<span class="built_in">push_back</span>(<span class="string">&#x27;]&#x27;</span>);<span class="comment">//限制时间戳长度</span></span><br><span class="line">        string content;</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;(<span class="type">int</span>)line.<span class="built_in">length</span>())</span><br><span class="line">            content.<span class="built_in">push_back</span>(line[pos++]);</span><br><span class="line">        <span class="keyword">if</span>(f)&#123;<span class="comment">//第一行</span></span><br><span class="line">            out&lt;&lt;<span class="string">&quot;[00:00.0]&quot;</span>&lt;&lt;content&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            f=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!last_time.<span class="built_in">empty</span>()||!content.<span class="built_in">empty</span>())</span><br><span class="line">            out&lt;&lt;last_time&lt;&lt;content&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        last_time=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 使用流程 创建 cpp 文件
<code>lrc_fix_tool.cpp</code> 并编译，将待修复歌词的文件名改为
<code>.lrc</code>（这个时候顺便复制原歌词文件名），与
<code>lrc_fix_tool.exe</code>
放在同一路径，运行程序，在相同路径下生成修复好的
<code>fixed.lrc</code>，这时再重命名回去就好啦。<br />
经实测，刚才的问题歌词修改后为：</p>
<details>
<summary>
Take Me Hand-DAISHI DANCE&amp;Cécile Corbel.lrc
</summary>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[00:00.0]Take Me Hands - DAISHI DANCE/</span><br><span class="line">[00:00.0]</span><br><span class="line">[00:23.83]Lyrics by：Cecile Corbel</span><br><span class="line">[00:23.83]</span><br><span class="line">[00:36.89]Composed by：DAISHI DANCE/Tomoharu Moriya</span><br><span class="line">[00:36.89]</span><br><span class="line">[00:59.59]In my dreams</span><br><span class="line">[00:59.59]在我的梦里</span><br><span class="line">[01:01.49]I feel your light</span><br><span class="line">[01:01.49]我感受到了你的光芒</span><br><span class="line">[01:03.38]I feel love is born again</span><br><span class="line">[01:03.38]我感受到了爱的重生</span><br><span class="line">[01:07.01]Fireflies</span><br><span class="line">[01:07.01]萤火虫</span><br><span class="line">[01:09.02]In the moonlight</span><br><span class="line">[01:09.02]在月光下</span><br><span class="line">[01:10.84]Rising stars</span><br><span class="line">[01:10.84]随着星星闪耀</span><br><span class="line">[01:14.47]Remember</span><br><span class="line">[01:14.47]记住</span><br><span class="line">[01:16.97]The day</span><br><span class="line">[01:16.97]这个日子</span><br><span class="line">[01:19.11]I fell in love with you</span><br><span class="line">[01:19.11]我与你相爱</span><br><span class="line">[01:22.03]Darling won&#x27;t you break</span><br><span class="line">[01:22.03]亲爱的 你不会</span><br><span class="line">[01:26.12]My heart</span><br><span class="line">[01:26.12]让我心碎</span><br><span class="line">[01:29.97]Take my hand now</span><br><span class="line">[01:29.97]牵着我的手</span><br><span class="line">[01:31.75]Stay close to me</span><br><span class="line">[01:31.75]贴近我的心</span><br><span class="line">[01:33.81]Be my lover</span><br><span class="line">[01:33.81]做我的爱人</span><br><span class="line">[01:35.68]Won&#x27;t you let me go</span><br><span class="line">[01:35.68]你不会让我离开</span><br><span class="line">[01:37.53]Close your eyes now</span><br><span class="line">[01:37.53]现在 闭上你的双眼</span><br><span class="line">[01:39.5]And you will see</span><br><span class="line">[01:39.5]你将会看到</span><br><span class="line">[01:41.34]There&#x27;s a rainbow</span><br><span class="line">[01:41.34]有一道彩虹</span><br><span class="line">[01:43.21]For you and me</span><br><span class="line">[01:43.21]专属你我</span><br><span class="line">[01:59.64]As I wake up</span><br><span class="line">[01:59.64]当我醒来</span><br><span class="line">[02:01.58]I see your face</span><br><span class="line">[02:01.58]看着你的脸庞</span><br><span class="line">[02:03.49]I feel love is born again</span><br><span class="line">[02:03.49]我感受到了爱的重生</span><br><span class="line">[02:07.02]Cherry blossom</span><br><span class="line">[02:07.02]樱花烂漫</span><br><span class="line">[02:08.9]Flying birds</span><br><span class="line">[02:08.9]鸟儿飞翔</span><br><span class="line">[02:10.84]In the sky</span><br><span class="line">[02:10.84]在天空里</span><br><span class="line">[02:14.64]Can&#x27;t you see</span><br><span class="line">[02:14.64]你是否看得见</span><br><span class="line">[02:16.85]The sun</span><br><span class="line">[02:16.85]阳光</span><br><span class="line">[02:18.34]That is shining on the fields</span><br><span class="line">[02:18.34]照射着大地</span><br><span class="line">[02:22.12]Is it shining in</span><br><span class="line">[02:22.12]它是否照射进</span><br><span class="line">[02:26.33]Your heart</span><br><span class="line">[02:26.33]你的心里</span><br><span class="line">[02:29.99]Take my hand now</span><br><span class="line">[02:29.99]牵着我的手</span><br><span class="line">[02:31.75]Stay close to me</span><br><span class="line">[02:31.75]贴近我的心</span><br><span class="line">[02:33.81]Be my lover</span><br><span class="line">[02:33.81]做我的爱人</span><br><span class="line">[02:35.68]Won&#x27;t you let me go</span><br><span class="line">[02:35.68]你不会让我离开</span><br><span class="line">[02:37.54]Close your eyes now</span><br><span class="line">[02:37.54]现在 闭上你的双眼</span><br><span class="line">[02:39.52]And you will see</span><br><span class="line">[02:39.52]你将会看到</span><br><span class="line">[02:41.33]There&#x27;s a rainbow</span><br><span class="line">[02:41.33]有一道彩虹</span><br><span class="line">[02:43.20]For you and me</span><br><span class="line">[02:43.20]专属你我</span><br><span class="line">[02:59.65]And I dream of you</span><br><span class="line">[02:59.65]我都梦见你</span><br><span class="line">[03:03.36]Every night</span><br><span class="line">[03:03.36]在每一个夜晚</span><br><span class="line">[03:06.95]Cause&#x27;s there only you</span><br><span class="line">[03:06.95]因为 是否只有你</span><br><span class="line">[03:10.9]In my mind</span><br><span class="line">[03:10.9]在我的心里</span><br><span class="line">[03:14.49]Will you be</span><br><span class="line">[03:14.49]你会是</span><br><span class="line">[03:16.99]A stranger or a friend in my life</span><br><span class="line">[03:16.99]我生命中的陌生人 还是一个朋友</span><br><span class="line">[03:22.13]Darling won&#x27;t you break</span><br><span class="line">[03:22.13]亲爱的 你不会</span><br><span class="line">[03:25.9]My heart</span><br><span class="line">[03:25.9]让我心碎</span><br><span class="line">[03:29.99]Take my hand now</span><br><span class="line">[03:29.99]牵着我的手</span><br><span class="line">[03:31.75]Stay close to me</span><br><span class="line">[03:31.75]贴近我的心</span><br><span class="line">[03:33.83]Be my lover</span><br><span class="line">[03:33.83]做我的爱人</span><br><span class="line">[03:35.67]Won&#x27;t you let me go</span><br><span class="line">[03:35.67]你不会让我离开</span><br><span class="line">[03:37.52]Close your eyes now</span><br><span class="line">[03:37.52]现在 闭上你的双眼</span><br><span class="line">[03:39.47]And you will see</span><br><span class="line">[03:39.47]你将会看到</span><br><span class="line">[03:41.33]There&#x27;s a rainbow</span><br><span class="line">[03:41.33]有一道彩虹</span><br><span class="line">[03:43.2]For you and me</span><br><span class="line">[03:43.2]专属你我</span><br><span class="line">[03:45.0]Take my hand now</span><br><span class="line">[03:45.0]牵着我的手</span><br><span class="line">[03:46.75]Stay close to me</span><br><span class="line">[03:46.75]贴近我的心</span><br><span class="line">[03:48.8]Be my lover</span><br><span class="line">[03:48.8]做我的爱人</span><br><span class="line">[03:50.67]Won&#x27;t you let me go</span><br><span class="line">[03:50.67]你不会让我离开</span><br><span class="line">[03:52.52]Close your eyes now</span><br><span class="line">[03:52.52]现在 闭上你的双眼</span><br><span class="line">[03:54.51]And you will see</span><br><span class="line">[03:54.51]你将会看到</span><br><span class="line">[03:56.33]There&#x27;s a rainbow</span><br><span class="line">[03:56.33]有一道彩虹</span><br><span class="line">[03:58.19]For you and me</span><br><span class="line">[03:58.19]专属你我</span><br><span class="line">[03:59.7]Darling take my hand now</span><br><span class="line">[03:59.7]牵着我的手</span><br><span class="line">[04:02.3]Stay close to me</span><br><span class="line">[04:02.3]贴近我的心</span><br><span class="line">[04:03.86]Be my lover</span><br><span class="line">[04:03.86]做我的爱人</span><br><span class="line">[04:05.93]Won&#x27;t you let me go</span><br><span class="line">[04:05.93]不要放开我的手</span><br><span class="line">[04:07.35]Close your eyes now</span><br><span class="line">[04:07.35]现在 闭上你的双眼</span><br><span class="line">[04:08.76]And you will see</span><br><span class="line">[04:08.76]你将会看到</span><br><span class="line">[04:11.34]There&#x27;s a rainbow</span><br><span class="line">[04:11.34]有一道彩虹</span><br><span class="line">[04:13.19]For you and me</span><br><span class="line">[04:13.19]专属你我</span><br></pre></td></tr></table></figure>
</details>
<p>打开 PotPlayer 播放，歌词正确渲染，问题解决。<br />
如果是只有一种语言的歌词修个时间戳长度就好了。</p>
<h3 id="其他">其他</h3>
<p>感谢 <a
href="https://www.luogu.com.cn/user/1389641"><em>Kenba</em></a>
提供“前置知识”部分的歌词。</p>
]]></content>
      <tags>
        <tag>鲜花</tag>
      </tags>
  </entry>
  <entry>
    <title>基础对拍详解</title>
    <url>/2025/07/04/%E5%9F%BA%E7%A1%80%E5%AF%B9%E6%8B%8D%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="这个密码看着不太对。" data-whm="这个文章不能被校验。">
  <script id="hbeData" type="hbeData" data-hmacdigest="8a1f10b92044d627399b0457e1e2a3543ca0a0950abaa567e588870448d2f6e4">8ade9e8308e767f1a274156f57751d9a3f5b26898da3a0bd68eb817414d883a0206042b26542125b70bdcc523644cad4e9a4ea799731395b0a77003ce61b73b5966381b8634277c91cfee6abff129ac21ff3b747020d6da2788e1a315de81770e4341437408d7d0c8eec9ba2246e2922098b2712219e936c477329faeef741ecf3cf89c9d74226c3cbcf4c9bb79dbb349f9202738c2b4985eebf8c03434dcb5ed61d4ea4c1c0a55036b549b8d214982b99be4a2f26d0358b4e56ca3a765d792db909cd76e714a1893e9b315ec2f5f87523aab12f9e6145a1adec06b6b3a72f512dc34a058d728c3cbf81afd35a4ca8f2ad2b909d93bd464477e56b7d4c1daaded21771b2b5afa02f080d13dc80b64eba9ee9362ceddc863ecb7daa3f93fb7960c7952a372f703dedcf826eb07d12c3465f691555aeb86db7855215c026ae5dbb4c32a21bb956bd2a1445ca75bf01bf5fe7154db779bc71e77ad8118b013417fbe4482ebef6da74d7e22113eafd86694f550316e0848acaed6af1aae0f7e319794e62afa39392d3914de1e53b80914d64296930e80a581e17b620b544787871e2414f35f0ae1f44613ec0fc99094b1d8b5dbcd173a67a8aef4b3f06b6f9deaec0aeb0b28241491b0a8344568d042a57f668225556dacf073f31cc6b6afede00c04b67477a4b74bb5968f5eb178813276a1b57c59127e09c8366f5fe55b3058e0557b2d682ff7f8631314a6bc22a3d21eb023213267e9b57804b772eba9062d111d7d42cabaf312bfc58ec23084bae7f609ad966197422ef79d1861cc4d5401312d75f52df026e79d6cc7ba4e0f5b46d7008bf08ef20600087dc6fd9c21ed8baa74a78d6be5e8a4c6c8485da89fbcf1084e844d49373b27d0ee5874948ddf9204d8596d8ec4963c4f7e764e0aa218e6b4b4707d946bd82f4066f8eeffd70d40d03f34ce503bbd9a51dfbae923a0b28e47d869edc46cb251e6d0b7533321bd840146a5fa53107f87b5b6a0925b9a1d51d2faa901988827e39befa31e893a7a1509a8058f7429aa67194d0d945236850ca6f5bbe796961be1bd1f768c4a2b0a405a0143545c317df5423f5728bf446ff596fad6f6d1ed1f92d0081b7e4875183637c9de581d3d07b27a1d235179ae1638cdaae9168178bd19d894797aeb7a3452a21d4bc69582bf974d02be19666dde25cbd20331813c51b60c1c2c8f3081adc3ae0b3beeb510115c11273fa3417536ed3584cc379423300aaf1b450e1ae8144fb92469ea5ed34e3a1c6974311142c60849771eca726d7bf51d91f2d594b09a9c39b9abd027f9c773f9f41bfe339a0f47e57bef15e4745b421f992e60991ba261a41efdd7b3d22825a53fa73b3dd555a8ea822e84e05834817e47c25a0394faf9cfb7d5dda8b2030c2a747c53506691d998607805dc3a098291a0e8a1dbfabb6716023c29341761d9d365f7fa9c2227218fa77bf82dcf9b3e824031e4c5bcfb3051d2b01e79f21543acb7f518f5d372f961f04c3806cfb7c5abd0c9eb90f8648ceb0f230412ff6ff2bb56ae450b36b77781ba9e7fe333d230dfbe3c50a0ecf266f0726facc952b7e3a8f2bd9991def8d9823af41abc8aaf4d9b4d9cca9ab931f508b1fcf11a34d53f9a31369e63bd30b42a4e14a0c97d72f918c12a45c94904313084925a23b9ccbf20e49136dae89315d70552153df0629a70ab98a984a81747837aed9704756ad81490651fdb9c6afab5c36f90439e642e677e68927b82431079b892fd98f8d3abfb19934116c0952be19f199157b63b2f953c524b2d6b4993bee70f8f941d734a7dacbada8a9a9e27eb5866210bdbd8a02d6e3e0c45216934b025201d5508dd883c01815be759971bcf8ba51b8b0c90b43587b3dcc911ca807bbc75afe561358fb0b0a331ba6359419b71a99b7f77cb1acf6bbf5e8010b878effc7ac732b214a40498dd1e3ba4f8fba1376e8009ab27605e851a010c03d1762b0ee35f638cf6d5caee10d8b45ce01e2f00b583863c8afcca941f6ab9a741fb0ebfa5e87263e76968047d74ce1e8eab2161d11916a0a4df64d358dff7c0fd472572cdb65145f94c25d5072d1c0e949c008d04629606f496fbab0d3c79ce18a7594497416c5ac787f1a986e2126fcddb487320bf5e0cd3bd5ec6e6b4cb4f042dc773559695790405012134836cd3c4c6b7ff3c82c4ec662d124e5b002cf380341b38fd8c7a5eaeb11e7145a568b781cc70e3d45931cbb562b3ebcd7da4a3e0bc6e04bbef02b3fe5a8a46fd28d05a5485b761ca13adcfd203f3f4db008efe8868fa04e28a22445edb199fddd90d26f1f43c0c8a1200a01485885c4c439e06b1d4620adaa70f87ef9b056e6c7ee9aabf3909665c72fae0043a821a1b29a8d46c1ede88e90b2efb80f71fd110297f26924f05c011e969f055485528704645ed6d5eeb02a7e72ee1056d6cb10aa14aea5f81a9ad2ba0662e24c4e61ac03f03bc6c5b560a97f652185bf594ce71a3505b6d57bd3ffcd4d2ac5e7c7de0a695fbe35ec300057683f5e472f3ad26d0c63934d5ffce30eb5ec32be92d9f3a4c0b56af635f284bc2ec721ea17880fe1530f5bf432433ad39addd62de71991c9fafe82f16be442b22dd1022c54a54d5a8e750fe299a2b63bf79806b3ead9f4a63946f54bbe858a0a7c9fdc0e6c630f4494804da9a414bd3839146e1bc9179e3cc8e25648fb570349aebc17115d81d64e42e96e3590c77d3aadc68549caa0494c5f6306b87bf440b9abb832fa022ebd6e04267b5139ca1e32d93b040067cb366422e9f7c8954b711bd08e70d69c579bdfd487df11270012929696c9e301bd3bfeeb4fe308877564de8ba287f89d709746553b5f489938e8bed500d0ff19669517d91e509ed91cf3453a68dc2bf4463c0c4c014a2ab0e17463af332baa2d42692924d2f727dcb7036e45dfd9121e2b2c50b72aca021716e095f5c52b8f627a4cd43bd2d56e544ec1870e37440dbb59eee11abccbebfc9ceda469c7b6e6724600d7c7384c401b95ffc60145732a344116945f55fd53ee136444e1e08442f8a7093d711b7e5c06bd5a47de385dde7761c8960021e5c41996a1c676927909fc988103bdf6220276d70980dd2439e15bf04c073507297135f45a7da5f1340e31aac3db213ab75b2e62b953447e9be92c3eac4fdaf22709a1724b58df40672fed2b043e714fc0aa19ff4190269e470e26365c503f7707f2b5c0e1923c3689bec7dd538a4d1a285ab908e681cb2f3ee768efd6555fbd14eb7bba00108abe9826223dfd550545eb09eac08f63b101b054a2b863efd6612f41f5e3d7aa933734069448a352f477deb182310522247454ea0d0c82a1136c03437775f695b3fe9eda590ac41e91aca1c4a3f80525054da9db97fce169c137c9a200596c9da641cf7ce5eb2d07706c86f5b89b21ddaf9aa35a422ff4b6d955495822bae6d8f8dd1a884ad21ef1131f4e64e3741d6451a06591837f26f56c8dca7be9cf43cc272c3951e9a27c419bc305b658487e3097ed9565cd42275df7ba1d62a59d485b67e446541c94f0e882a9f7c472113f19547bb7c75d845b9509f32da4d001970069e0bd5af6fe64a19449bdcc68b75b538c017d7a360f6a85a3a2ae6236db3cf88ea13d624a7ab80ecda6d23a106e10bac586b6a18b84b40aa5c2a8ec6fb8b69305471457cf992af656e1e9d02ca560603c17937284704b1cc627810f3b4b422b070e201938e84c431e2399e931cf992e223468d8a0a20efe5af17f3c694cf4dee62a8f75f8850ea537e9de2269ee9a0c1fafa049fd374da91ab345aee61a1f4e12c2b03a2ce024d5f94805fce7355313e5f08f81b042380fd061745478d3abbb156d5b95af45538ca10a7a63995c7a4fa390b07b8afef1287655b85c71c104ca1d62794c2a5494a9d8f7258007a9363dcc3632d60ae48eb61f17d565e3fad17ca529fdf73bb3e1c1b6448160d38936181021c851262791b61ebba3cc2cd41521520bea36a335d2b9b399451f88f98f0513326e392511ca6bd67011e8921fe80e153885c8f15cf8039c0de044d6185fb57f4a2ee5be943fd0100339abf08623d7e8c15571bb7f8a5751978ec0cf7cf66de591f38212633d03cd9d5441cc7b386ac5d08083ef9220525f80a854769e1742d50463507488fbf62932a0bd559b28023fd9d507b1cf1fdc4b677212cd846efbc418393b4819ab2ff630cff32bf1b010f9f749b6475ec6d37b4433d3734d7ff98056ea09799b5851bbb636a0dc168e198a6e9f0ffd8e6c60f3a55b9fffc26b25e020c2f81ee3540abc9d606d7115dd08865cd8f8c0a2ee3af7d1024645d4a7594a3cf1a1e92d26591cce6ff8ee3ebff3a9ff3446bf3dda0d68372f738a8d8e6f06b9f471e587d4098f5e472570a1294a7a1eaa32df94f88f5576c33b2e58a3b75642da110c83e686ab4be3a16e0f41b6c66b6afc97c126be714fb7f16316b916f3346ef5054bfef1759ea26a8c97c531086b130b0cc17bdc10360589570457f34aa12e532bd63b79284cfbf9bfee304ba2d71962061e947aae2ebce09d52c22f39e582b45d6ec164cbea9e5463b2da32626bc6aff0019432d0718b5aa8b45ef8b80cf2ac44d5d23a0ae1a37df6fdadbb18c4196fcd76a35f2e5887f62a49e8e6b65a5e6fd78cecd79bbd215c672e709369b154516c90205252bf047b821372953c048265ed8ea4b0e9a23532b24ddf56c37393ec056cc2d2e06a1dc6017d6a598182d5a0c4bbbb1f7bbeb700d6cf190da80264c8c0cd7e5ef681b678841bb8ba530337e4ef98d78d6a4411ce9de7a90d7b3f145564f9375424109795621896f5f2528e2977a38049e3e857c4f992e1d40d2ffba94924fb9f598de6e2059474deb2a87673899e582118263935ad08152140715facda15a0dd519c5808ad9b5fb2af1852356a452aa83236c1c5bac44b8d96157bc36558c3c11469b5c9c19c15dfc225b8327932121ecb69e8c4d0ab5165abca47aeef8051dde63816ec7339de53916b504338ee7bd36f5002b562d584f0ba9960daf41b010baca636791832fca370b23766692013b1a9591caf5fa81d3be88d0dc6313c777f361b31b072730658807173f0463cb1ddc36fe2ece450c6459f70de4a0124043a9f58c96e9682b9022dfb2b2223c3450346ff7ba9edc3423c8bdbef81f8dd0efe847bcb20ab9553d6b1567a9d438fcf29e414fd51d6d86185420c8186fad981f486043c4be81ffaec876360ecc47d7b130e2a187bbeab8bbf403236d60ff0aa84ac6eec09ef17049333888add5d9106c3d3e0403ce932bb33fa9352feda72bd2e5ef2a552fdbe8519a78d906c3e703c5cd6b458a92175e6ff75daab3aa19b9da6a9b1a8f07bb3ee42fc1e9a04b46e2f422e63813bdb0a6b18ca10c28675dc0743b38b793c7f6fff966f5e58254c12a9957365511b576a1156ab0f25625fc72ace814abbe515bf2bb89582b588c8d4edcf7350b34353d208b5f996abc7aeab9f370a5e2e775177ab5d47441886875a8cac5bfee526c63b0782cd195777137df801a08b40ffc9e594bd6ae334a50677ab1d4078daa25eb71a5bab83ec7f8d1ee997185b9c6aef2bdb9b0a061bab4aa7437efac29c36a0ead5b2a2b5635d6d8fe4e675942441b4f7f5102c7503baed238b95836655d177014ea1845194073e1f50641727f8a3ebb5718ac54e52f56017ed5b59c755218d8593150fcdb3722a275981cd1187f38dabcf7c0231dd12e458c6088fef01f426558583756cf96ae4eb30f2636ef5a113209a6c8ea3335d45f42ef84fe6bd894dc14b7817453d818c35005718cdb4fd30cc3c9e867c6d708e8a3847662e33d28671dce4e2806d68db349061e1c76ab65ae5e0d726221a669ef4d58d59e49854fff7d405e89d8c48251fb994f2c4b29570def083240eb7b3d7cd65964af413d26faa2e2b3d7ac2eac148cb1577b588e152daf1acd3fbaaa9c4864b09f31e4635605a5e746b0db791c51d9f684936335005e4c46f19af1c45e8a86a5ab2f6a81dc30b2e0a94eace91342c9d007f1e54810b8eaef1dc1a84229623683e35788b2d987796bb4df5a76769d53565b8128ede5e9f2d9a76008499b9ce5c11d206def222c82d094331654e8dfa013efad085836e05ff9ca00d83d141452461615eee35109e2c298b684f005ed284210c00cbc0e33002014f529420a86568142919e58c7188b2ea7c7755e9697409e5448913d109a2b86fbb280a0f03519e481525ff84570904ed0000e9065da8bfdd230bc394be21da5747dd9dc9d896be68975a70d7e9e5488b782c0bc9d869d16fed3042249abc79cb60ec4518e186af10d624520ae8354acc7a52e47c957ffaef12a4834ffa4f3cae2d270fdc5828d5285d300a2a1af67268229bd8d5b469f69fcc5257b197d6c4e4f914def45103c7301c6f7d5ea58e6f572cfc241fd35f2470c76168b3915869e707a980b70b3e46701f2e40b93a12d1cc5179cc838a460508d9e4eaa667140b225d4d695f132f5f603e148d9511e56480888bb965af0e1e19e9a4e9aacfb018ef44418372fbea091255d32e7bdee4dd920d83b38e993b83fdde278a38486badbe7913e72244995e882bf436a7e8de948aa8b8f4c82e36f3d31ee68f118049f67b80abe6d76dd35ba8194430e8dfc5c46b33a8b64fbe854123921eb28fed0d3b592b91e79186b50baab9ea312f24046936c0b22bf83d3351cea2c64b3ebfba705ad22152eb74d1c753128d3ae0609c5493629dccabb9f7d696671988c8edeb0bea71ec00c589d6e12a4dd39b1dabc57411feb3269a2db54ff48063bfedb04713f84d0e9cc83196c1755260b2b0f022797910df5df332b7e21c1f015680dce55643b2443bf6a83da7e3b99652099cf04619d964556b3b50a716d65cbc9d67ec40f173f1da343e9ff9757b44a5e22efba492b0ac06cb960ed0c6b6c4868b2f2d224788a75530b71fbea3f80934e495180c9939e730e6cebf76442658fddd8aac4b0371c60e9909feef9e20528e6b4577c46101deee16eb339cc3754c6527882faaa0980455d03e1ed508da3b491aecf1f2ffe923b54ceb909eb8153057c5ef72ae74e7a31c40d9625e3675356ee0fc69bf38251b14800288f7914186a6cdad48fc72b5ae6e8e9402a147e6b0076a93a96246b8a81d52213be085e4f87413b55f0f0943da4263f4ccf1648bb95abe3e02fdf27d3b1ebfe1a549fcb99db7b8423d963a1e2c908733b7ceb146eec96ee3d9cc6d124aa92c9c2b298c4afbe7543a60a4aeec559c4b35cd84b0167ee7c18be769cf51721b9d8f2e366d7cba42778ceb4a8e43b9db760ce3c5f429854a3646ed044cbc4ea0fb2b524f05ec925470b03a10aed61857617f3094af6a55630942a2f7e0791804147b1a3fc1c1493084bba4cbe0e67d90accfea5e169aa6ac4694832fe3c5ec367820486f12b6019f84133e627fadd4e5fbde1b50236ae0c4d263ce7dee9179cdaba3940e85a9582311f4239fab47729d0ee1c6d0a640f3a3e2ec54ca855203b62e2d40373919511c0b823a9239b9af759502ed6a3a356378aa2fb5efc8d6b0049768d037dae41d82e27047c7705f0e01ab5f00f10271ce794a118205f636d8de3bc970cbfdb13d21c379e1effd6989195d90de6e43ef507991975970e75a770be7439f4fc81838f54a4687a278144cba418fe35b9af4747383d6cb7a626bb8689ca7171b172bb8737e70ef7338e48164fc5382362fa647a2cc847b3e6d115c530603c326ef532a4869a7743c66bef621c23b8fb50d958afe8e4427a04607ed9925d3c7e1ffededa6b1f7fe80e6d37306bfe2dc4337f40e7abd64f21e6697dffb296b23012d8f8cd710f0a0c028101d4267db381425fce7b6435cb027bd5048b0704c7343c2d8211b09db9afa57c69f74d92149f6981ebb11e5f5a8949c0f3bc3a1e6e2f79bdd09a0eef7543926e80f09cb29663565899d7f67b9fae2dca28d7c2f353a1c0391fce2bea9bb11cadf972359ee1eaf463c28d2736b962e0e3f5d469a134b9d3cb5e6e895182ee6cb0a6d9592c13059990912201caaf6b581e4c5931b2b72e4b932ac1e97e8628baa5b6eeca76bc09d0630fccd94cd07f411f44889e94205306f50d7754eccb38871b5497c83a21d698f99e69deabe880a59c0b81b85db753acc692902a560596a04343e5ffb70851f0df7b3abc28f9d534003ca16dd21104701099959c5c3a1b35ffe82b11fd81bcc4816e7b39a78be586001cd3c99dd52ca4bc41f76976dc1b5e9a7764c436987af5d190cecad2ed1044333626263185b72dfa8c052dff0eff50b3ed528a56fb972a8921e9233f597c50653ef8e17fa59d33919d898aaf2d089b01e6671bdb00f6bc2cd3790885140e62816543140e90a5f64f34aa3540bcdb860aff5ae5045436acbcd84d6423876308d8dd363a2c4e9712df121f88089ce45b28967296da41ebdb54a091bdc00362685e079317634dcec381a387db4ba4ce72d3269af1a854b80ddfa68aaa9260ee327211c210fd3f2434869d2f78984361abea7e5627f3b588489ad6a71f215b4f7e6e60ac049e40d532e3cfb9503e474de2963717fdc13e0f56dd3227c4efae6e7b6652778ab197021dc728ce256b203c27be8f70c9112bee121f1cde8ff70dcfdc246c05fc0a9ef98e6237a52c8257d037698c2d298bbf01e2b16bbb4c6c5fcb413ad09004714d17e01f7df92c9b0a2d992a1003c5b208b956ae35c30574db3ffef4e065577af5dc861bb2b87c92636f823e8656850185aab0ab438b0b036fa85a4de79e2805eac46fc48aee860e10ee38d856d4330b7432190897829e182001652de755eb8442e04764a8f61a4212d05c1758e3a256103ec095df02ad409d17bef624731f4d8dbaae1478908cb8c642a13bd1f03228e838988ffe377620e16520e0ee6870415a97fd2c89a55c3a3f82e6aec04a8c092670ba3d1d6a0d86d79375695be78121de4e66a15eba2a0129413db7415b44880cdc3b897e9fb51b1f2aa134903ffbbb5c4c76343952e16fcd125ad580534e163a2553762c35f41a1ff54f3dfb4981431d91eee2c234c880ce71fa68599d3f96414ba87146dc0daabc3afdf1fa76a848405be416ebc31b1f1a13199c7557f89550bdc5c5794e60a669542eea4987b8c4bbfd33be43c4e82d67b9b5f8621d06b742402983435e4e70e41115aa17fff09ebfb05c08a39e86d3fae2abf9cee1ddc97fc326e8bfb7bafa70dd34ee1bdd984082c689279f85baf92a349f143759362d312b224d0ec61fd4469914dfb54834209c6cd67c4f214ad3c20deead325a437c40f243220f21f5ca56cdf129c31c7c34df10d4ff1ceb2106a8ffc2aebede8af3a334c594b4987231359d5b616c050478cf7de63f13063db6aefddceee4751d375347c7e3b8206548f27c2a1ae1ab81565c7f29c39dc0a997a0ebe11fb73bca479ec66e89cccb3261e1f6740d7f02f0103221fb6a47dbc9073629561bbb365b6cf04f65aee418bff67d2877fa3663f4074f0dd24abadde7131681dd91781ec4cdb2cbc64e9b0c31ba98ccb5d80b832b7af6ccfb7586a19f41c89eb3f9a2596e1ef02166c93b5d30a2053f7d676b11f5301d3b95818bfc44bacb762891ae5ee1fc6c41c2115a616c29f8b317327eeb2e37d7afaf0576e839217cce88db6ff555de59f426f07b9fbdf6e32788504e7d7864c3fb6a3cd484ca42958989ae4e105108dee02e200c14077d34eb56ae620d4d86123fe2aeffb4e1191bd019345e00b1b0e16cb7c5331664d2d035d92f4ee3e287c448f0c15bf11b04f7c401eb5ade84aab49c7eea20e564e42acfd5e8b7efba8f21a7c8719b8b87cb5db45b19b89190eaf9ba6436daf53b988cbf838daeeb9224bc1da7717c33a1fae6e48cced68651fb47f932e1182fdd2e33d17acee321fe4c0c6604652b1c35149c48a208af2021a944ff488b77ddb9828dd04faf88e4885c4afe516f8328ad2f57974adb1a98a74c2ef8715ed0d867e86da5c18aa672fc64af302fa11dd327f1f3305e326e148c3f55cda1d16f337f41980a8a58d8772d8741fc34185f1d2bb537d0430d3eb0781ee9ef21dd826ff4ea1aa707618a30f8ae9be3fbfb26280aa2e4fc821a7346eb6167fafe0443ab69a44d84582341a79ab91a58f70aa090dd04516e6e6768e989a62c5c73d2c234448797d57f353b163fe527068937d163e3fa42d024ac274183e212e03741b021556935b01b5dd8a0b5e500bfdcfa37c5be1b827d81abb2ef7265a9630117a95be6b3b34e1467ccafbbc7fd2d974b2a80fd48bbdcb09ab18f80cf966c92ca88bbbe346ac26eb123286e2aa4001ac44ec2f01e3f70a53a3b10826f8d7099eca6fbff6c3c631a898a9a2c17f809c10176370f0390d006b1df4dc556fb58c47faf0a5d9e2a1b6c1562a6afe7d1eea22f8a7370bd3920945fbc765ad802ba7311da4f211d9c24bccdc09814273127c7db28b67835ad6c46aad26af4328e0f52c8a190dc868c076a2cd5d87c3a7e86cf737deb85b4a33e65b3fcf97409ceb57e773dfcabb7736ffcf5d7b7a3c25d26c05b9e0a26d2e8544d2cb8b63c6c1745fed13431886a8686a472c16e1ba874d0caf49aee5823c5da918469ddff2bbb075a8c8510a738fa3021ca241c7bfb289c3e9455a5973f0b4f0943b0b25dbffdc1843b180f280c42ae45d0ceb7f13af5a10fba293d6ac7599c59e371a69e1f47620a053991d9f1f5593266ef9731e5ec7d7e6f6cf2aab48e8e9f4d97d08985cb4285cff2591298c29808695908373bb3ebc597ef2f918894e14609804ef9ea24669ceaaca8bccfd88190dceaf19b9e5a901ceb2a76cab563dcf885514e2bfa4d0c30b50f8856de59f034bafa567b233f806793375f9c3e705c67f1d875140a81aa5eff8dcadbd3db4d5409926f58388f1e935d017e81bce752391ac793889fc86eea9e73cd4eb0f1f18425be569b557964cb3d07a50afdb9d8b1f1100e7b2048b2de3143b6ae8f4ebbf9b83d16d095e06319cc78c115ca82506b7b8e3039c3efb0318f87a1261605e0024d6d5d59d57f6738a9071f958f2c8fc69e13d8f5516c1b88a7ba8be83199afda7cb64331a1ab3d88c2d2c274fc655c0322e9a00ee1bd4e21805e255dea648bc1ae1852143f12476f664b5562b717edcf72da9eb7f98aa4428ec37c3a080eb5291a873339c17c7598486d27276c2873ad07b2f491edfda7eeb977cd08c023d615aa0f8512859875de73a6423847145bb0f272f07d5a4311d555b4484df87acb9a234d47a62e5b1a8799d532d39b727a427f2e1386b0407cc95aaf9578835bdb114388cd3945a85ad67510892d7ad27f2ef56bd3e1bbfafbd1feb434a0828fdd3a8615a0663733986e57eb4e1be75275590f942423e99b9b1ea536c154570d14f6f9633b9a601ea9062de1c39a0ede2a53ac4dc463344c23784548d0f79266013e8f577014ec9c5f9231b4af5abf70019f9678cf35b7dbd0259ff55325b4854dcb90989ae881d7357687afab6c7f4a4cbac212978f8f86d19f03fccda420245128e1938e515d320248df0ad0167f0e23d99b1da20f7b126261084bf312daafbe769b5ee1c86dbcc0524aa0177a4a404faa24180f4152d053e45306642598664b81dbcd42f3e9e53d11ad6d2085bb1f7d571b676d0d0852abe6256eba1567c0ac223a927c4f8b660e6c1508fd86b35c06642a1d4325edde096d19f0751374414afd871ef2e6386339757bf644a3a63829173c65ba03997b251e42ffe46575f8c691556ea9e891b9b8d43d36953ed31f07b32b0b9f1f24cb9d69f11dfa1ba10209fc4b696e796d75eaaa247b0ab7eea218c35d0743e8111144bd3979d2ffd0e84b4344260d155a38d13d6dc29958e11d8e9f3cabbb78ac1dcfca17901b961a5506192a4506313d454a9b45e39a8f6b4a5aed86c47863306162e243c2344c8af6a9cf11460aa2a9322132ae348c7679adb02969498e83cce2ca2beb969eb6a94fc3185f7d0251607ef12e2df480a5c53929738fb481950152946daba33f6478062f09f10a7952c28f3adc2497dfc3ebd82a6ae14b65ea93c3f844cc9a37a358e276f874cfbb68172284c63301baadc83f93aa92b79d83edaf84488b435975ccf806c6aabda6924d9079ba87d645919afe876c01e940510372603f44d832977dea76c1e6dd8747d09ccbb4d60a47daa75ce9440a721a778d8beec259b33fce7552ba6a68f8a82836e01b68888d1c7bc39d4dbacb73623e6cd22251217eefc1360048670492b17102ad1b71749a4c05db4aaa04aec91ad8350191fd81b6d85d742d58eb756c9ff9e1611b96370b8473c5f7b1a3d63831ff6e5e9014932581cd9fc097b73714fcc7f8880dc8390e3793799e68609e5da8b8aac5a12713ac8d95260578a8bd786870fec2ea13f7a67684d3801a65fd0fbd9b84374e1d1fddc15ffb1edc260e4180f32bfa8fd350bc9e057ff7dd4344c3a66baee55b2a79206562d9490268b6be841932f2353b4743d5f019e8716a6abc1e5af3b2afd37ed9c7778ec3ef25c0c930f0f6de4ab8b711d615175ed37508738d7d07e77a9058f2681839f3122cb2c2ba400fd796858c08b10cec10ef553e2e4b4405f811a7a1993df899d2fc76ab190c5213aa6163f3ffc65a22476d8aa7f15da30d03aef2d5bab1ee1f5795f0c33078b31310da9dfd5ee19b05c591aad12451bf594b4089c6fcf1f1d91709dfdaaa22d3ea0371fdd0255f512888dc070d5614a281933b31d42dd4ff31e9c3a40ecca4e6ef0de66cae58a87219ad5e56c8f99a71bfe6a2936bb996dab66f5ee5edf1e08a5f7be6beffc4cf25c1aa894bf694bb3ee6ff76e3deabd4ce4d67eace62327b1839fd58529da6b57b92fa15d9d31f81f7586690e9b93e37563cf89e01c8f36c35276f7866c46b83f4d176c65974e7ac65a41ab478872de04bcddfafdcdd841e87fbae2fc55b745bd15f2a7e4c9c6be013b3d63d1555fe662b2a44e129d94b259cf8241019bd7a113f527a128972e4d90293d4008a6cb348b7bd5bc4f1ebfc20cc4a53fc7639db962bacebcdf7a0e7f5de183c052ef75cbe8afd1074a73b887cbbe82427aa3e2afd199f7954c9835a1394f4737c2731979493746d68892483ebee4ba6822f719d18dbb781f5f3fbd7511279ac665b56f45d84031ca1a839ecacc010106cde90da8a3ef860ea6c0e1cdf2b6cd4b0d27edea2ef591875c019e96079dcd4aaa35a74ca7c4dff9f0f45f8be374fcb9e3f83c893f22743f1b3ccdff06e16c781c7c244a9a4be24308c12f372323af0cbc4701b9457938231a8797e0f64876cab46c6545de97d1e76134694056d887656d45ba4b218ee6f95972565f85716f6586b9541b83c7a257944ebf912b11090e674a1af71070a359b7554529779d400bdab6749f017f6dde52057889ed74c8dd93dc9cf9ecfa40feb9dfa1089d409c6bff128a9707c426777e0c7f3511b83be55023d0cb57787a806fcaecb12031279d8be2d672899ebbafee48292c86a948440d818fb6c3f57b9256603b93a2261846eaf50c0d07b611d3af5b8cfaba48b0cf16ad5dd89836b2d6287fec636b1b4a6fd66c00f904262b7138fe6bf67e8d560fa9982dd8e9eb9ad13cf9b2a08d51eaeb102ed6c15baa4ea75b4ec14eb5225167026e07651d810bb652bd5963121cf7e3e8277cc2e17f21835dfd285c4c0c19aeea0e04baba0e5f6455617b4a72c3e0a738cc9551a5a590907f3aa5def2267f3d5e9efea8ae074f2bb888ed12e4f3bd32ac28c915a7b58bb0ee164ff3df9bd3f5a45083b38425d18702eb9471d93a2bb036d6b00fb7e200093f9c2fc09efb793c49ea766b1da77e1039e9b90fa1aa1be60154296f2009fc30c5f99bf52771ed2626433459c1df0623a8bced2486368528c9303ec147bf350149ff78c6f47f0f3282ad038001cda153475f7f408ab42479fef46bb4e6afee750d397e5ad7ce937317e9ec7cadf909cc1789bb168e3263a9a26ee1175694b7f5aed3b89cf1ba91fb0e8f99aba10a1277a277b87c6a54fadc26ca0ecf10f2719a9b83ea8e083cd6041d1d8dd532ec69a5674d7b6a1bcd284282fed702ae4b098eddeac4b881e465d1e62975d12dc00ec788f565669fc8b55dc60860947c4cdf5ff5cafc331ee35881f52bf6ec941671dffb1b1e019ae9bfe51aed9478088d3846ce85991ec95020987d948e407f8cbb7e38d2efeaf9e3561bd2ba53622fa19eb90a0915c8fc660cad0e35b76b9c8b81fb9775731b3b80c7978b826c1214e138dd1e75abd62b86dcc51c61f711214195d6b8142b5cb390e11f4c62bc90911f72a4c10dfb41a32e168cd8c015e995c7c843f8dd42068d916cd329cee8df2934e7cc24897a1725fa47f2dfc99f1206ddd2d1041c32fe7362c1a92157774cfe035fdb2044c951d6074f75df6a181f5db4bb6f23e61062cb99fc3e90235907bea5083115cfdb7c7dee1e88c70c7f2a7f9461b86c947860135e30c0e1e297d6b84d096a98be4abda971e5d821f93c8fa15f6acf59ec1eb7da7aa8d59f21f9a14a7dbc4133d1db5f498fc6bba5b5d9859fdc3d62b40bdeb9d3a9eb3c1e9d7cd1959c7083dc51f1b68104940f932b7fabb890b702e03499cb63aaab5b2004f8a8298378a9605898f2d4cce1eb7de47619b28f5c1df9bbbd74c67291ca4ce489d62995daa00acfa42a8e70278feedd4130bed3c818deb9153bdf5e11b2ae6addae210ded0a5ffc3127746f0f8e364014c9a7c8635ee626f8a4ec2fe9390a8dcceada49e6870f8627666b5d8e0bb45f00b445ce4c21921c7ca738216ae3aa93d57c9966bb05d258ac3e01f55ff27f918cfc1431ab35e8dd1ed33b850a0bec1c45ca24716bb08a727eeefa8553974b4c6c114a1890e399f6b1ede46bc1ad0680661ebd538726b2c2185641d72cd2f234ab3b745531be17245d1ef8681d6371de83d9226b83155b5832bb75a079b39bb0e00e40b484c1b633dc218e921e2fee55718358c456b1327d3952ccbb2287fc2afb8b63623c34b9295585bae5e88f654fd3cada67343e885001aa4e3b8bbe1f245d7eac383471cac90515438c1be08d1811ee0aa5e51062fe0fe6d899e113992cfb894f3e63e5412ff5ddb40877242a11fcd280eb832c55f50c492bad35b58fd8853140ba920b08ae8d047cd4c2f2ea19e62c465da9c8be8e0d91e684e57fe5576c8c6a20ea7064e7d119e563fc2412cb7f93bf4e834789240b8e948b887704821efda8c442c1cbe64e73432f82ce165484c3dd3bf54a6ff7243a1897dbaedad78e67b0c1c92b14a329037f33534ef6974e705b11264f985bcfcc2fd82ee0a4537c295f1cebb3bb9208069f269bdddd6a73a82f6f148a8c23c9b8d96c1f163ecc0ca4a679bfa554c01fe9e2e4be1e3a80a0ab54926f3215b4c8eb5a52ff18e7fd36dbf92ed0f8f79f17a752ac2d5ac524f9379d4f9499ef9e3432b63fa2705aad5211d0f03b311ea924a782294ed1016cc2bbecb255fb72ecc85bc433af4ccca9ad029fa7833a22e182ff3ad1a66061d43f21bc37208120bbd1111f5bc792418596521b1a4e6e5918ccc91df203184326a30fe46f8548e588cb8b600d5bd6a89dad31f4f774bfc8db2057a1639f9c782df2d9463a0e00f2ad196dc8764430b838afe17f45a748eb2e0de7cefb6133f0c222b7bad8e330836fe115fc1f89e06dec778325ed81478c78825372b41b245542cacce7dd1dcecdc670e8796a23f655b077698f9e616f7542405b297856bb7d68c19f604bff5c7954666c84c91e454218115473708214f15324ba88ca7cfcebb0dcf7b2fed0563d8e6e717eaad1da4780817f17ee8d94082fda643bc10c7785d5670163a6ffbba346ed993519866e0c775d8e6feff8b4f71cdce873c65fd623cb597e97d4d5d761fc53700832e48fd64b8063dfe8339c4e127abb84af6c9aaf8af6164ca733053a828e744dbe9a1f28b89735762fe03e9842d764f2ef6de386b68f4a94c1cf4bdf2dd396853e6c940dd4a951dba11f9bab9d8b04295d0b86b7f52f1c3816aa7b896820d3e3ce81148942caaf74100e05b579681128aa4bb2a02683cfc435c3e4d3b0856d975d769ec9a2cb3e181a88b66b2a08e3a85576b32575f829af5dfa099ef4741bef08a4bad97a5319d9d03592b5f8a3cd271e5f64ce114c4717f2b22addf3b1bdbf827e3f06cc3eacffb3abd3dd85788b24b3a82a59a7025a24787ae773594a67f637ef6793bf29c1fd0478f277764cddff07d4a8f0ee074bb478cbfae495fcf3983e1f13c28ec5bf2401263ba7c4842ebf4f3bdd4951066d632ce14c9e521d729c2677c238f712c32e100d175fcc905d5ab4a6eccc85d68052f831d5aff89f4f7fd908f52e0529e036158d21578357684f9ed8ec546205ff9bff9753aea925d805ffdc5b6bf80e6c313b09e960844c37ab2995582f6151488e46e606e22f19607360c1ed7721d07232f9d2dc3859098404e92c8f11c8be60d061cb4846cdad59ae147c988e55498b4dfeaef7b32b739685c65364e94a633536e313d58a5d738b8ad27f379934b557b5644e9815f60259c773b51f3c24edce0d4e6d91a85f634f3f16030ca219dcd3e119c7a9149e4918e8ff5f62701703e89e3abbc054b41cad63e0885d63347a739b35156e10e08517fe126dcacc911bd47b536963305bd631665a97a05529b4bf576e80e84022c946735dc2fbbf7c4f89ffe9d59e419f9a6e8008d3449b91ea4ec40cefc7d360d3595c8442488bcceac3316b7af345aed33dc7fc9c437ce7b8c4a9c2e121f691075e80886169e5a1d4c5876f05e1f023ef436fb1db9763245fd1260992e3dad87cdf66998f19fe1704ff68de65188c2537ed2799ec098c59b2935cace84a7c9e5e43a596ae79af6ce54ebee2f684c5978660030bd93c52dc908816d7b23ebbf59d89948056d6117107c9d9986b55e480f57978d3bf8a691b10608ee826ca898d5183cc619c82a4cabcccaf376164d13f14f3da5dc8819142ef503646bc45bae724a3d4ad386a3a990a342d148fdaf35b70fdbe0325ba1b47db15bc3622b68920b5e61734295be3398e46c0a8da10fdebbc52fe7f66c134292633fcdcd44fd250423a1500d493e357d5d5ec29e646847be44a0d4c7078f668aabe641158ea9dd0a70638812ba0de441e5141141b66b84f23d02af2f1dbd7a4ce359f0f5ac29b16b0e443c38d3430247b98edcfd4c76eb2d2ed37377073b8895819d650853a9a5ae9f0fdeaec0c1fa0397f42480755f448e990a04ef87b579cfa2f2ae383db4d23cef3fc4bf73e49adf4099889c01d398049fda3b16201b16406a5086718492d06dab7b5be0d5f2f45b905bad41812b66d58300753a2a4c87364b6e60d5a6ca71d21484b59837d1b97c23e0c8436132144a0b6db6cd36d02461cf5608cd74d8cd2c0c652cb2b88eecfa02e8678eb7a1eb03c4f5b0b609c68f3203034bf549d6d122aeadb222ad2a882259151ad78c2c66c95143b55b1cc8275dc832c736684436ce56701f5f08722bef634dd2600f90b90ab4f6f2ca9d511898051255dc8471a58b6a068ad84eca901d28042526a8eeba132622191eaa3ec720c3a5848d06f8e104bf3b3cedc837a6e1dbbf0501b5eb5343ec76aa0110ccd92a059c7d7c9cc47f3bccdc4e3111c208c1a6ed66da149627bf8db80b6a7c3e867a3677add45d8843b0044e6b246853e623014c87d28c99a6b4a34fa43f607a21add90d033b18dc0f0f415b93ec74c119317501ec686a157a367c1410239f96b964a6a972123be75b9ef5c82405edf74b5b6b8b28327fb08e13dde89c8d564e7c2f05050172d3c0dd8fb6b719468ab10623b37c1d31bb2647af6ef3e7215b2791ad4197b76495609f339eddd348b1c6aa943795796079119ae000b3de644650aa55b2ecccad7666bfc4bc25ff28be6cbbf163c844f647047a95ca5b3f7e0d51cd0fcc4b963b05da696b329823c22a3d808f26d587cbaf7963dedbcca78a45ff5c9c6fcecdbd3024afc3728e61c6a57286368aa6bd269f03116031f576c2164a8b181817b8bd42d3f8952635324abb46028ecc55bc681dabcc39a4e6579c0ac5cd177531a02a8722281989ff584007da0ada364c5ec931b370f126b74b897f61d8c42a841184260e3ff4bd9097971742829c84a96118376ac846bec1b2fa674a87206ca16acf4a4d8d1878add33e6ad7e7981bff33b584a4a7c61a5f3e13a4fecb8a6f61dad71021e027e403ece2557a8848a658084fc00b7f30b7cad5fffbc8ca9df9076fce5702a7da90bf19ff24064292715001b6dd8ef06cfa5e5a3d011bc8ba9d8173faaaad92d517157e19b8c762cc4a42c1801f8e52f76fc6468151aa170a34755d3941f030c41b6ac5e58a61b7b39ac4215e515aa3deaf9bd26fe7072b400a6736e544e35c397d9f5ec44606c7a993f3c5c46035fd3c57a74f59250e4fff3c10beeb4a592752fd1860a6e841316b773ef417db9780712c58632289e3f3d41a447130fdb4f28a47aacfa5b52bb79852d89e417bb78bc63e6e161d8b1e2bfe5d54866c692bf7a3266225b9da32508e4710d588c83bf3c14ff3dc0f2ee3aa061c97f857b7a18363898da7b30bb190bc094c335637a033b794d54212d292591a54662d594ecb2ae986e38e41d28973a8572fc49f7a49ffb76ded59d9cfc0aa5901cc8b6841482b0cbe9d1b033e1634699da78291a743b672bc62e484997df6915b56cf774e76b7e9c42292410d9051b8cec1b522c68412861ba49ad58e765f5ba7d2e86144f1e03d2c17b1105d17d2987ae752e7a76ea10d6ef91111f278733bb3b3f2d7b826ede1a35d98d9dfb9182b7ff8d305b77ce4694f4fff1c483b077140097a8a78fa04d8ca38c7b56d03f4cf611e08711d94f50027ef1cbd3ab4f0855272578615658224d5792add937985e57759fa5d1c1429e2e933d5581dd8fc611901849bbd4631629baf384db1fa679cb3d9fc19f389e07b414ba8e742f772fd22dca1c8d9d7f505919a7e0bfeee295c47583e769e59496fae0113699b89a9b8741c56d9645439d81232459d0e2a046db3067c1fc7e8c13da5cd59e492f2bfb27d04ed8b837e9ed0e69d9268e034b9a49cfe921cf8a2131355347c763697a99c732bbe99c5d0f463d70f5dd7768f4ad1bbdc5c0f22dbe58580a7ff95256dfca9082ecbf136bef2a5d1f503c1c465616421462fb15e0ec81ca997a20467248351fc1e7a51eb1d20896b3293726959daaeba24a4bdc45886033ff5dba8c977de060e3023ea8d676a08d2c746b245440b3f63ef8a1402b175ca6d7698ff1364861dffde26e6b88b072e321467c0e1704e0ba032f50c2630daf19e427438d3eabbbd74dd51d0f4a49db2ed3e1bbfb7a451b1aaf57ca5c45ba13b47f12264be081c3f42ea905289fea0f7b622e659c8ceb32ec1d8d44ca974f1fff80a7b4850894cab73821e3091e0bdeb81f5da4a73e653f3febeebe6589c4b2789c99f0988efdbf10fd13c775cfb21e45e0155c7e950c6091af25155ac1f8e418c175859600113ed4bc08938b8fa5ce5f6f6140d47f965677a1674a65e12392529b89aa78071ea600b22e3c91b4093e205bd5b8875bf1f6fbb13127118c85dae5043d97876156f53cee6e01bf5690f044553ead529a194fe6d08aad85e1a001e7bef76242a7ebeb0f307d63c0a6467f99816d358546f764d327c21f7fc711e4443d142410c7aac97adc3475e8b082e406b912d6399d0f5170ab12afce24585fc142a352c37b00a9aff06d7cd0a6fcbe36454947c673152f24a13d01a664a9c9451b342e447daee19350aee8739a48623dec33fe7c521f805d217e4c8878d734889391fe0828bf6582f409a50b8f1b3f1d4b89a9781636504a1a612fdeda42d621890baae2403e6cda3a72e9de176b806f49b7016312b72327d0f1d0a21da796e49878897311ff52a830294a81bcac9c67c629ea1aebe03b65e6e4483630e112a0b4243af374028cea2559c7936417b99345325d77601eca28a919247b8d58b9ef2492ec7c3ea8303b3e543c12edf82716bfce646f73ec22a7ed6e664e1f7284045d6e742ae72ceeaaed97656c22b46eb079f248ffca06d1a972756bd1a7d84c3a98b9a44586fed42eb5e33257101f3400bd0e06aa364e1044373cb8c1737fd698b1271d5946fb6ca5b32004aeb73c91ab445feb33c11cfe63debdf48eb9780efbdffb5f20a6ab562cb5b81d9d5764993c0f4f4b330ff7345984d8c485f7a145cfa98cec427f92d9bb802486aaea2d19dce1406fe77d62b62456c0104e99e1f921b1931ffbe06ef8ecc90dd5e7f8784c213264203e170e1e555935bbdeaee57669c4f437bf91ac3a75518e402172fb64d7326bca6c5a45f89232a9cb63e84c0e1183ef152f216780e2c1946919407882034387b5d65c46bd8718744cafaa48e544aebe20e9ac9b0322b303a316850ab4c3892a38f99748b5b00ceea3ec73305c8a7064757e5142e18a216e3bbcb88b578994e7f1659fa49ab4ccd509441e4016cbb4e44bedb6fe974a9600a32257aeb80fc0856c8f3fd4cc2d4952cc4fc375d3891d1458749b5b319ffa2fb0b54bcbe891705e0cdd439f75b39154b949cf9bd2876abb8a0fce67c1f0547b327e288b57fe7243df6c2270f5ef6429eddee25ea9c90d9d6dae3f258c275ce20b0fbb87fb5cd89596282aaa26ce94cbb2afcae877c05f39a8a8b3e89d06028a68365ecb3addd5a9214b6647ccd25c2714bf858a46da606ac06a56ad0184cdb745315b22af88e74301b04c00127447f4cad57dfd30a8ea130b2cb08f1059044b7cbd0b5df0c6d91610e104f040099f52c53176fa17d75d3ab85297e48798bce1af1bb39aac83ccd3477637bc8d941bfddc432975e17fe7cc09442c0afcf26f077cf72ff76ca8114a38b2a7e2def59b64de2e28d95a80a58d192ba6c1a0585df96205e55e0ee248f4bc3b1c28851cc0e97b2443b4c5f1c055d20fb1beeb8b94aa4fb8a05867bda9c3639349442c16014180b4e827a79aa66a68b99e20e0a518d510a3ad177c34ac2c1d10195ba3627d1566e03cadefc49c72963c24d4a487269d8943936db3d90c3106fb655a7b53ec71cfeec1fc02c53acef9625ba1ecb2f06e508ca9f278c11320ea14b078735fc40c4739c0c951103bbaed755aae14cf64ee807c2f9eee92f645b60f3086556b5be545c039c000698d70bd27c652655aa32531697470199ce6103bbdac999238e8df720906e891f78e5cd414cd465b53499532366d614b1ce6937225d8589e58ce48b23526076b26506290fadd2d1a29d6232663847dba84048619b508c1a29006501d256abb74e4bed026ad20bee8c8f01d062658d2093dbca5215095c6525cc5e94254200a1523f826690dc7883ed1714082f02f8a10197a76003d6d4ccf1f6249408815322d452718b4cb38676902af0fe3eb13166ebf0bd48200dc3a6c8c6e4d514d6106cd7a04504a2d9962196de1658ddd655a012852950323e5db1e8b95967f4eee2348a8e37b9e14d739be16ab39ba931964ae236dc288f9ba37ddfeb9ee8c1a7369ebb6d344a156f37a1897005eb247378fb5768b216c9c6c3a3d107ba8618895ec2c595f8504fca12372ed2878ebadb0243c1ce8a9200e7ac9231ae9e89baab70fe3e73b846ef32425f4c9df4d658076642013041e7233aeff5b66d91ca68791c012f94df3dee2830855f4349e8da3605e28d3e40b85a371b7b7343e4840a538329c64cad9d0b0d1d86c43c3896bf5f9446cb24daa47525c3f1ecd93256a14f2ce31890b0bcd66ad6d47fa16a2e3caf811eb81c579cf8c6d117984f02266c888270bfeb4fe1469a8b66ace56274f4ebe7be88e32121a015237e7d49b36af4bf6269b80fbc79da47ded28b83c778009268d11b3a870dde7230a0cd8f2df6f0a567b023146f9c51dc7916214d1b4cafa46545c69c2742db48c4b821ec6a4e476354e24a5482de25b66297daa49b38891d464cf750eeafd56fba108e45f2c5d046183be5b08686e91b53a99cf848136e682f949d5c0377a05cf4ffff91be07858e452db73772a2bb3d2e7e4fb3f6066b8dd77d58cc5757900a366350ec94744a0626b43405da336d5c9670cb052c52c06af7eae3ef008eefd86603b9ce679b63c5b426ca70cafb8f2b309e77c0be6bcccfcba18786cc4b3dff21d9b05079b24f71d3b7b6d26f80d5df33efe351f65f8f4cc4055d7f9e756b7eca9118382c5b974516324a5bfcde41fa9bf97e2dc028d5b26d4e160281d7a48fd13f678ea5b00e6d0023330cb8ccee135706ecb25e248d82e8235c9cc529c31762648ddf1449f5ff4b457282eb77f2f3fe915db4ee1d40c19bbd8d728754e9aed6524e552a3b84dcb75b9b9d2eb521c1fc8b9a47e660cacb3eb8b6122073d0af7d47988a6959e8e3533051b1981aed415db892c289021826897f41a7e2360f504578f005599ac6f261573f6998534320fa25e92c6a94b24246b3e133316e54438aed96b52c7e2b912b9a6b42e14add628583d6cb769b6c00b8d066f980e4f6ba4cc78d4047563554eae9e9a6dcb444a463919b3a6fd0ac00907bf13426835cc5541b05eb8229cad6204b79f3c9feca076aaa37553064ec7018c62bcaeb59e41908df3d1a4322e16c5804a8ccba6c47bc5cbb8b0f2f0431233c71416bb88823d168ed894cb395911d639501cadd21a5aaaf3caed87f12a81b33ab5ef217a4d98a5ab2bea3d97e22c32ba2ec4a16321dc056032626c6b7c9673d47140099abcab41a8a45d76f27be009f38089bc22b7dfa49de4d2d58152fe2a80b7b1f0b2fea6dad45b6026c655a8efc5116e24396bfca2daec5212cc2b5df6259de229f13e4be88dba957c1a2f248710dde124ed54e41819d68d29cdd942e642684acbfe90480a163799ee59487d987caeb63132c25c9e0ea77b941487cd523be63ee720349f2f2a15e252b40c50582fd935ef3aad3ee967daa43d5f35c573fa813bbbcd0dd02963b7cf40a585b14fe35de4b9b430b2c584344579205b2f08c3b9c7da1e6e79253f9b3020790ac4c1a211d64f07f9181ea6899b09aa20d66245816fd56c31224cb59be17c51879d157ff8f8d57856e4edab5840cb8fad61a4a3572fce01d1a9d8d681a165c6bdd5d7ce31704bc775feec81fe014eef7fa7c92db651b97735e3fcc7440c11ceaf1ec2fb6974549e79456b5ee32000080fd42e5f6c00636a1fc56c4790e7c50302fee658e2aef5e63e4a4c1ca673b07fd0ac0e6a9eb9dcec6e5b652cf5482bbd76bf873da836cf9758041933dd409fdedd9396a14c24973feae8cd5de78bf0f608b9fafdc55366407b3cfaf7bf82634423e9d08ce8c4adc0e70abc78d01189f67234eec1232fb0a03585fa5466b12e1fe4280f088c8512a1f5d226fa8932ad3f3abbd9f28ad7242709f164c880e6c303aeefc5a6664b14ba367774f9df42d49f8316b820a94ce1ede382f7a1fd053af467087dbe64335830014aec5b5c1936ab96bace6f6fa740c6eb75f1af398a69ece6aed4b5328fd76ac5e7dfe0332369f00faf1e841c402c71cc1f963835e89257f5453188921fc6a05bfda2ebfe2d997da065dd1009ef703107f66b2052edd8e4307015c362188e40b2ad2e1ccf3249354a0bb054fd912043b16e9266d387715bf340a3dd58ad0511b5e5e717c7694fc62853134230ea42fbd2611fd107cda7154469f9300263fcdf5a5cb45df0914871ec0564e6431802803eb5c59fd38b4a32d93f5187dea7624a31e161b3cced89ed17d903876f63f7bdacc9efc1e8bc0946a478400500f9013d44a96625ff820a8c98d847f978c4f02b3cb4037b02839791ec6210be106f050265a30483311aacec04236a3c7268621fc8636f27e12eb27920d47545902185665011d3976b8fc02c60e29317220708f6fbcca015a90eecf1c21c0cd0deba1f296f88803371879d022fd5b99a1fb85da5bb9bfc035f786b5e1300f721b64dc1e68be7480b8928b1e082c664d6da157f77c5b00584680884af2d3d4e92ac41c9297059eef738f4d4d85c47e329fecc0132a49ffe5ac2dada7ee0cd9aeefde27694d38096aa593e2463c15567c5d6c8fd10d84a246fc288ab8b38d095165c680b5f95b15ca3d252ee6eadc9ffd8e8aae95e2689e35f6c443ebe5df85f09d454c441801b261af16b44881563e0f3c6aed55ea3321b8f39c1651da7ebc110da3005c6500a9108921b6e85e2157911ad15b67832f9856864a2be992d429734890952ad51d733f4b60f58f6dee1510c4c10ce10eff98bf5a317ab5d887d74a0b2e61431f785d64d4da76a069e4e9ab083851694cb63d59db21f7abd82a0a16c3bda8455c40a852287117c37d41be0d7df7d5023212f3e8438a3883b8c19312cad49fc68afe127090866bccfe9dba296221ca02367f5a5eadd01df5fab92136f3734ce5dbd3e8a8f5bb26297e7e1960b878f7dccc74f115c9d8b4ee2a99903946de1383e7466aa5e7f2ae3c5fe267c4ae21f5324795e94dd1c1bdbcee44f9560c820f88ae86588635c6c33d2cd143c15b0513fa3ad2a10f5703a262c2864d5da961d23f478a42bd2b2fac9aacd5c6b36ce7387ca5f010972c3f0e7054f3cdf67d41ce233b2cf9ceab3186233f5256adc943673775af6fc0a84e1acda1401062d702f7c656426c9157cd4428d8861818780910575d7ce98a89366476759b124e03785d54ed7c4034092783f1d812cf1aee66da55e8e449be9d92bdf19ec77531bcd54010ad9404778cd44ce63fd007e311395e788fa3f82a78149d264a776c7f0538e8a4ccaa0ddea5883377ac275d52fee81143705c02b32dd3c5e573bc5d8876554de9414e3755f248ae44f6b5b14e153db61ca220b24afb8fccb34ae29b9dba16fd4c5577b30631e423076d5468685a2c0492ad09af5e5dafbd2a47e8dd1a20b07e5264829e7f21b242de5f980297ffff6b2eb828537593ad77a83d0b7ac6cd5bccba1c3129273a3978f8f91628fb5692904eb24a7d225fa5cbb8b98773f25cf8f0e49c0b5b94107c6b279a99bd44157acc89632d067454bc1cd3c3bb8be248b05a5960583d50832cbb4db58f88db4b2955167ba68df7d0ab8d070956a574ff8f3c67ccc8b2cd6fd5a43e4a0ec4193f8ed378e34563cb735dae8769f8f379e11d3e225e639be6a9a88ddb1763e24da4d1f7ba1c4810baca3b8bc993d77af3a435e5b018bb6a7a0952287a292566db66c4d40d4f528825a788858256c4851f5036c2f0cb8ae9d0ffe9bc80a0f45bd025aedbacdff7cfed68d2279449b38b0f87a3f7921240a4962bb909db469296fa2e457e34328732d5264aa8c46f3499d222020bcec18543659fd823ab5735c4b166fea2ca90cc16a4b2808df2faa933f29e165079b7c350588c05a58332053b504364400e548f8d3c1a1432e8a0f45ecf9dee2d50aeb7c217582fd17552c7f1f33d7b0b3deb34b1b3b0291863577be5af9581308b408efb55ab91f8b81ac493cf8a1b261edf9020f9080aa37b4c00c429a5716f9207ec3b829a3fe97f07a8b99d6a8a7dc93841436d141b2507d3ba446fa74f20918309ae27427fde01dc573768d0f2b88ac536ae5b588d22bfbc0798afa5ffa5d796d5522bf14c9644c6a7cf3676ea0dfa367f3e890768ce73712cded9a3fc56bf5bedb3729c9e848c239e50bd904e7b48078e9dba3954a4305043bdd4c544009ddb990679b19475e91840eaeba043653370a9604a98b3a334484af196656ac6c91093a3f780a23600cdb2735a1d98f1e1182e5207b59735d24b296bfde5e4a5d608d380b53f7885490ece48d7161cc8633785d7a63131928fcb4b8519741a2bc44d5a30290db871bbe98749efb1f0bf293fc652b84ed1c866f2ca8a89a303f3b5542048d60f8cd21ddacc314efd76f9efb13b6e438ac46f279139216777cc2561f9c185295aa5a16ea3a9ccb93edb7cbd0f4f11825f64406331005aa8afd96e80a55a2ae3761c588ce49a3e38862f6b20e9a6ed097ee1cd44a2e08ec2d0aaf6f8e816077a467cb624cf1be6343aad5fb93f93b0444bbd71112cb06111f50d66a3d3ba27fa54f4f41761a3675ce54f0a1c18c512e04f246722f59a5b5f0ee37c545e63d1b6c33fb9f7b6d415fccd713926fbd792aaa4960f0f4cfc7d4da34b8dd4034ac1fda13b417483028ad7282753779e701ece1c82d373a0a10c1bbef3f4b5efc2c068a1636a7a1aea159df22f895465b547e33777c309a32e4f54102c6369633ca279e81bafa56f5be3f0228392306949256290c3052140e5d496fc21d4f9e837d4cdac56e2f573b152820ebb8c1c9916ba4100c797fb708889a9133ba3334d3bca23aacbfd0200ae6de732a57bb5d7e15ce4dd80700bd3e50ad37b40c82cc8cddd6f0ab1b178534fd9ed3a14c8e80e6e3b163107cfac36dc1610a5b427211794ecfb79e2f0f79ce1eea6423d8739b787b4e2cea4b54c4085ba852255c0e559aad6abb687ec52c416136c2da69ba6fc3db4820429d6708f39f8d8c3316af2854238863c98fdb90b2c937891acc2f6a1300aeed7c4ee4778089d66fd011577b4254f7210d37196b3939b31cc746b7363473c01779a764e42983ed1fefefcfad7d9b1dcd55b6bde1b2827998b7ce8b72d143b3e0ba8462c4577589fba546ba7336e94e4740696e9fd419b8decb693037634db96b9554df510b0a657ac38d4c34406512883bfb1b0804fa007257b3a4c36b9a98cc5b33b1c02bbcc67d410c7f77b395668cc841bc99b0e26f665af7abbf7c6f7ed734ef2faedbdb5d4f5cb9a15b218a27a5e8d7961d1d052afaead79bbe3074a7de9f561fe046a780cdd6932eac0b2050541272908add42f63d9e7fc8c1bc58229fbb9dc71313e0542eb721133dd29ad9ba64ccd2b504ad0667fe5666e7b88f0397e1f37dd2c85b49d34e280026b8f3bb98fe8393a9cf09aa1db1fbf9d7dc312a76eb3e730c8fce52787567a8faf96a9401e86d4585994bc0641be2337c0282ed51055e17e4e9e6c8a66b475c1fd082e365f8fe97a9a387f0068882625b019523fa9aee4a75360f43699d1eabdff67ae92381ce88bbe6725aed697a19aa5fe1a5be4775989f7bca74226225b35d77ce59c536a799cdd080833e919310fcde0d13c87c9e3ba5c41a827e298afb8cabeb916e141b7afbc7316c2601e18d7089401a32f55de6a07c8febe0813a4f8de99fd1419c54599f31b91b598b694169f53d80a21d302c25eb12bca616e7d0c92800b81d8ab30c00fddccf11cb2fb111e72359665da741f91fd264e231828b7ea44b8a2088677c02b53b11ff299daf2cd5d3d8b017aeb25f39b17511b808ee20db33c7d1f6f778274cd88cafacf92df39089dcebc6ae07587008411157bf93cb1402328cf4924993160cd0f9f617940f4e0b00c4fe49c547bfc45850c09753548716c97af252e81a14afe89c3dd564b398c21bb3f763ef6c7625c5744def6df13d373f518a417d74bd05c7a07bf76354b2c126f07e9d3e412bdd3a4835f317f113ad940d0dcb8914b3efdd8deecc3ff5e9c976954a7f739e7a179f705401598798f597c9eb0f5cd2c0446ec0ffca295ecb4011af3be6fa35912376addc4caeaa3ac76598029dfb2cea6743d0f51bb378bba5b416875edcff7b661c11190c047160bd1fd62c1f54e579e84648c880a138a727583caadc2c7845bbaef3bb4c213bf69aba7af8c1a63dd8a7b26ab0aeeadad5280aa79e5dd082e5277612a819d5167bc0a0517d378a2bf897d610437f6e70a734a0c71a10e6a9e9a0f5fad59c137d56df644c302c268a74e6ecafe21c1eecfe9ac6f936fe569c787985aa6155a4af4342b1427494e4f5f322c175ffff3ab1428eac3d0d85639517077d44ff2d72c021c3788ee9b1cf596e5873d7a4e093e0c442b527776a9b72740e765dd938d2ef8e4a7bb0316c39f604a12735c7878707289754ce2e9cb9d34acd6e8ee6be19b013240456af0a698a9c169cd8c49da4209e5ee661c031f073700a84076ad2242c1a26b0610b1b6cab596a1827251c1af197d3afc495d9ea53a83b4317ca69fc3f2ade6672457c8f05a2bf31e9490ea11269e37145b0d9d02332166adc696a15ec5fa09d41c53095bc59b18cdcb75732c258be9db0eb50de2d30288016c321238fd6f111baede2196494f6751a01fadfd390f1a93eedcdb9912411e86621ee9565742556a0cf0c05a432c33ee5359da16bd5b3f4c250558ff923cbd09154af427884d7c5cb5388b62291541a2258a61cb1b7375e83bbba9dcb6685e09b884f2bffbec92c2ac218a42f4a3bc7d539a950d0743514290491cb243a00b9e51d2cc7bf85888e67bbaa353002aba47c31e2ddc8b0db900b471e299d218194a77aa8695dc3a3c6dcf483f5277d5c84aa717a8d63f0d1a1153ca59107ebc8ba173286a38b3f80f742c9684a77e18d8317dc0d272ca08bd9d8d12963d6843fc1394dec8cc15ff6c018a46f4e59fb3d65dac42d9f2669d14ddb2af64ce2bf2f2229b57d5d415c3eb16e8e850fac773124bbe00cdad426dd763098d84d55550b8e090c06cda1ee99d5799cdd0fd8e7b63badcd09e53f9a657f4eb506cdf589cc3b500c2c3729a7612e49011bd47cf30e6b0d23b92a6546eacd18a8122a97dd877645746d1d383242e2f1536f6a925cbb5fdf37a9fc62d5ee75480fcec8c0225f2fe17a7b45ce1cce182901d99ceecb982f317c34829496ec359fb8c7495553983e4e05c9408601a013743276abd38bd84ce6716abed7b89fde55fda3cc5d875d5a4a8ba0b9663f2af710e7f3ecd2e1227c8b93c84416d1ca743f29116c9ab8026a9da0a09398a9e92689d543469df4cad028a6a4cd5079040ef9e26cc405efda0c10afd3166a732151fe872b799687cf0e49b4a10f0ea7eb9379955f61c134994187700428976407965dab4cf493f1b1db9dc7f9f836b64ec2bc5686b9bc92879b586a25180014ff2685ff28e51239ee78dd0da38f7e7070b8f7735f82d422ed7f1eedd920211b9656770ca21777d318cf39eb1197ebf989755fc7c16c5ceda1be8ea3a8f851a84cb59c6493504a39fb095bbeab27442a3073cab9e4d23b01930cae09f8e081c23045feadd4249adb33b9faa99e0d1c23d5950be4f5c6b2faa0313cf2d99fc0ce56cbcab5408eaf19a1814dcc1ac096be6dee09a03132db5eecbd09c6d608a5d29cad4c46510f71c8b2234a9a0f1460e23d994114bece576b02a7e2c087397608dd515b1ec14015e835ace94f414b7bc5e7aa600c7b4a34b432c312a0ac49017345468394fbc82939f44b71bfd7f27d9ca4021594d4ea8d54d51650b22b0547654906ac9d345170e0001c374bdb9809d3f39a9d05be33c901dc5ca5857e0d827daf388458349362e7e9d4cbadbad284d880f971dcfff19580fe218f6ef5e1949b09602fd374d570d6c4382dfdc0528f0e400739d3886a91e348836df34db22797575299947144d8fba30d41596b793f8a4327eec8ef49dad2ad2e92a0e483267cf314922e8b26a8350cc364aea6d478406a28bb35ece23cdef67e29313df42b2f76f65d4462e1a08d10995579f50845329456feb22cdb90d9b88d7509ae63a767983c1409af0b4593de8b984baa8ea1ae48cd1bcccd2e5d2a33346e9b1f611895a5eaf4d8eaa0400b6349be2e87f841872edb24cb0538aab87b162b571eeceb95c926eaa56c5ec70cc12f15084e5fa02cc5e98e320dbbaa82a67d1e6f117309d6bf7a8fce9c3fa2946990db68a295528b3fadfcaf9ac3044511f575bd0df1ef5a949be9a4924421ed4355a7a9b63031aae4d399e86c011d4c995690baefb61f83005f075f6668073ac483159a33cf4806b8e39ffd38372823c94ddbec8714f497321c85ee254882787b8133c2c0b37e784ecac9b9f147fdfcb8f84c453a06687112e503b4093e4c85caf83fb7c1c2098ffe6772baa9ec8cf0e00ec5cc5376b0c0abda07bc3aa4979ff6c87b86bea8ba768895b962ed4773dcaa65811334e4f7076156c32dd794acd5d10defd84901b24dafdba683d8a2830be60cdc004d0e56532dd73cc49104bd34a96cbe70bf1b6a042ef8c08e6ac93a2db67b2642b32edd730742421da253d2bd796a12f8c7609944b592d0548249415cf93e6fb511ea565db2066bc984287c42f8cb917ce5952da2bc8e826457ab50f104b0ab284c259b2cffca3bb1bbee4f72ce74d1ec8b1c862b7a2865e6747a3ae1879799d076ea0e21a07e966c10fabafb496bf1bff3440e6949da3e1f010bfbfeada3ae1069998fe0f53aa2172de9d8823af8c2adf2e52862f30bc8bb553e22c574a282c8cab70e395fed646ba9d3f798ebd5c1764c309922d3fba97978f18c764e2316c223df860b91d8aa8d34a44209a3707be2788d98aa8036f9952dedd0140b0db2bb38fe20302ca63376bc62ec3f1a5a0d11614fcfffd714f6d870e629e3473db95c2cb3217727faa65e59a81e1605da0ba2cfa85b0e4231edfdd62166434968b289707ec79a0d934951309e12611aaf490ecfa6c8b6214477692b826c05b52cf18d29808bc4fef3182b3d2ee510798a414344127add43cc5ffbc9757ea5213b7ac8864029c94d9252e5db1a8a6a8ddbf6de5a081ff58912bf6607a776a261ba35ac21c589cc9369acdd18155ac5ac299fa0060608b242f2497a6cf069b9443e6369a2093e1b42b2a4004ee6be4c02dcb3fdb9ad8d3b54cabaae7a18970163db0ba9991e9969de62f79c2123872003aec518f5652b1c8103b704fd36f00b430d4dfde3ab4e82096f027aa1348257f465372aa1d636b1f0021fb77089506378d6f2911f42648557beb48f0ba8a1225d537f449296f8b06ae3a84d7d47fcbd1b5d1b3ba3ca375d9d5df27c998cb40c164b3226345dd733655b20bf5fe3d61f60f4aa6a42167e870c0115f45c2901a4837059e9dd0437b46e9a3b988490dc3681691096ce2da9906c6e7fe97d5eb8a30487cb0893f29f37a547a9ea2c42f1d9b43137ed01c36acc2ac82e827e444b6be873b963efe1df5be7a9013230c5116800c1e39d0907e08d3c8f26c7e0327381b6e2846f3f70cd799fe3cc3ce887a86af17a5e9e2f2a5171899ee660b71440e5ef3ae2b3b4a5e692f24946880eab3f0e73b64ba4442bae6a9135790f2b12a735ff09d1457ceb2c6d5508dcf36a561ee558ff9d16b1b9af872333a1b8ecf2a4daa0cad6ced2f877041644341e5cf5f75dca5eb3eed8ddb57eca319b2236a9e1e1d7c578a5b30ef4fd35d26de11b80a1ac2f7b30bf4d8c66c34f95f7478034faf1f046050f85814d5414a8773a90680df5518f6a56bd59b6666bdc0a3304719156e87015e0cb5928614715352c1855de2f4c33342fc4ac3505903d6371710fef27f7295263805da14a36e10e5a435057e11bd5f1784d226d405da83173a6cfad28c8909d179a2b6d61cfb91b9d5e3d497135366cb78a53f5f5ceeb26291c6926f81e5b52c4c27611d87064054c5dc62754b6a6b05088285eba6213d2be26ba8660b06ba604b79d816d37d582e8306bec873dea2baaf1c82e368a6528f2e74f0214205bc83243947ce0be18f70326fbf676891a82482d7f7bd957e3951cb0ed4920ebf9c1fe1b4442c8391bc418f417293daed24975d6a1ff8ccc4e4b2c63871e36a559f777fdf58c766d8e7bbbba635a24206260a8ed14a06c2a7b33488e5c4bf3edb028193fcfb299ceda507ef218eaa5b7f09247c6aafb6f7e84493b659f83c3b5a17729a611f299a1327bb0967aae7dd0b4f3a823d353e70cd65d9c3f213a0f5ba756fff42edc698afe851f0a3a8825adcdb6a06576e3b3779c483b9d39c0dc6e816e19c1640f5f2b1c5ceac5d77d806f931446c0e709a28bfebfea1528cea91b020df82aed1f83a0e8132079787be484008efb4aa04cca4b52318a5a08c646e4103fb4c04e905806df82bc5efcc0509d9992d5f63f70cfbd4d37ad139945412c8b628acb9f6fc09225eb3647e146231fcd99757922faa436cec7955b1ba551fd8a6aa74b20ff0dd27e78bcfda320b76ab007f32f91d3cde6ef3a3a4d25e8adf0c1c2285f24a3ba14c1b18c22e6c1b524a0ddf1df965dbb7cc6e3992b9d46f8cf292ef37d206731469904cb3cd68872aa474a024ccd956ec8fe325df1d6d0494bc8d6c709fbfd812613391dccc6937d120c2eb0c8f64a510399ac2580e16afd3edfa3986784b883e1aa2c2ef6c6ddb3bed5407afa8f0afcbc44d9ee7642374f714c768f5da6821f69212abdae1ab6454661f56cbbddd7194cad5b845ac8d7c5d1606649a7190d4357df5f5372400b0bf3fe7d1af7beff1ae3105954c131f49f81c2431b9ffd16c39ff24a094d2a572ff443a28e12bef4b37cb80448ee53207f65219f712858978c7b62537b6c464a2d156c97af461a0fcba2c35d9e1813fcfb834e4660d294a5f280fa2d04cc79123394c96e326c694eb2745b0851763ba56f13f668a5a882ca6b0888a2302f4536989a60c13fb6144ddf7d0f8dffe5c37b6b13d86e30c647951e7395b7735caf71f0df5ff0bccbedb22a9e9ab31c1cc571e1a304cde95cb8899ffa232879bfdddc5043c3447d4bbb573465d8c079977ec1e98cb4e2c7e579844cd1914d119f13322dd584fad164b63423b0468bc58836f35526c5aeae792be6ffd842cf9c85a35688fa55fb2168f022610417c689279e55b3a7cdd8108ee626e28d4f8a07f13a9ba20be9a749c1406724214b067190791031be04e71ddbb825ab51a21d03fb2bc230ab8b4d30d0ef9b71c125600d178ca04246152266415dd94846ef6d51cd9c8f0d04b85762a16138e396c542632b8eeba024a669c4f98c7413fb43ce32251ccc499b3328252b531d6028437bfaf9a951ea41cef6449f324b30b0d300c83f2906cf7e5d9fbc86ea8f043ee18f2bcc423d58ba5a4a68c955f208fa6d642a05afbd3c9fcddf4a94d4fc508fc3c869a1141b7695ef92aa3768d5f32c0cd306eee567fd1d2bdb4804057be035b9ed94b713bae0a9e04986cdb12ee13484bcd0da6b6a244dc5c72440606a7ee905373eae8834f70651ca05cc5c5f8b5f8dae35439301d7ef9bba80d5023c8aea9ba632bf44be6c31c30610a455e7d6679fdb3485d3799bfbc926f5a671da9eec8c103f6b4d4905e9353b4d9adc7dbdd8f9f6303c095008155d81eb84d801672dafb98b9ead6b5cd7c06f8c0ec37865773dd041169b0730edc18b3ba0f99c134716397b66e4d02bd8ed424176260dd1fe638636ee9dea3c3a538aa0d99fd5cab8e762666ccc0ea169216992c90b08298e86e4fa9b56807ea40093847666c35c3183005d0221cdc24b67f610adffac78345a7e5a16e09f389244f84d757675a493796e38d7bb8eee2043d302da64da1d07a960155981973d5f9330a0fde4eb13575cb07664a6511ec6caa0a311a8ecd21f283c29bdf7014ddb776ef9667da5e1d765fbdae5e40f41a4aa243a42f22d2f87076754e6771bfe0d7ac29d7bc1aa51ba1dadd800861c6d72a62b0cbcff6d6c3f59a9ea48e354c0980cd57467abd6450e7587586874837f0b673e5a8edd5fae657e20c81990c2b34a57d45fa36cd39015817e71af7c97e324a17a67c444083c47d31742cae24158285e08287971d9778e421a3a71526e132f2dd81b87e2b8505f132096764b97b015aa1de4260f46facad9b6c8a62050bbe7cf850624bf935d957a958e2a2ff8b12ea62f414e1d5ccd28df87e7834fa38459498675d7cd6a70707c3d09dd24702b482526147e166be6d2947915ca61948c43595762a308e70180268bf31e2e8112bc1aceeb38a7d81b1f5902d79e0f97e220bf158f493102963ff67fd48c773b478f2f78a295acdd57964242b12bcca05e7272e8c22cb3840d852b78ec562dbf4a40f6e3e2a7e0fffd1b9f65ba0bde9cad678a96727fc0497ee8d694c03a5fac1107d8f3917a31a41dda3bb5eca1ee1c26a8a253bc5c613864d8a15629c364f91170dcd81495d7dff3a7b833b3ed3ad53d86d8cb4fbc954680cdd9486e5760233a488567d2cc83de7c9d583a3b31a3bc543585a7df6478bceee09e6f9842618e08fde6ec8e44e6c7487d9f1dab99a376a15af03e09cfa563da848cbb173377019aeb03d2109c5c38ca1d79dbcaac19506204a0d1910c34030ab64dc538c8a8d7b85ea0fbb4e910b746abd32f3ff0fd454e0be4bd2c9dd9ec0952056a69bc7ef36a92237b494b469a76e578177c1c9a2f68c81f40d7caee4b8aa2e285ee270a95ed4aff487c99e54ab44d6f7235914402f2eb5b114c6ddab2ddbb94379fac1411261ecd50b8986d80449045f3830addea1c2d54e7568b3cf36c9f8a7ec005d457f788604badd4dede5290ebb91937073f53770b858a3bf9926507297c35504f5c5a2f98a71ef349fc0743cfb96478687f63db737041f7c86b90cf299aabe0cca31c1e6ac196f7b994003f2909dac48bab51678ffefc16988d8d5efef739dc6a3b87f9846d57d9aa4d2d56eaa5c4b06846c59ace98df405f2d6a62d4c92a6c55eb57c133319d4d48da406c579e3599ea5faaca2659b9e7c1da254051d3b7624af54a305448c7ce56cb9fb9bd803f08ddaa67f94f2d1aa44e0109f4e689358560541d5112896fd83d3e62d7146a9079e274593e5cfdc94f861c87234d96b4f774cf1e2a2411fce397f522a3b607ad9d36b7bcf5ad7514a71d9b892103bb0f63ff01b15d6da5dff864a23575da16d0905bb9b171536e8c5f14ea22ebf13b4f7f8f94401f0c99de17bc8d4095be295d456e65c9cf49d359eeaefe1bd84cd95820201145fd991bee3350a1e0ebad45915538e9f24435c4e8b9128de1fa7c9c18f98aca89f7a50de5edece8e6457ed53168b0d3006000e2b245dea07b41f38290ae7dea7b907c4a24145de03a00b3e151980be1d50fc9c00b7b854ac367af96bc816b0d4a1ed41549bafc3a0dbdcbfad1d64abca8e8293b4c25d2ada6ae3ae30525bde8c9ed82b7c27cbeff2a5e602f845e9347df1d27c797e707fdea146602a6b6aa574a1a6becc81caa767a3369c2e65c13c2f4027fc8995aa3b2150357d08f20e7fce67340277e136c2aefa8418e1abfd7be7b169c59ec7ed094cb463a90e4a44c4b9ce37369f3dc762d6e9ce941e1a4a2300dae4c81124b456244bf4e2a05f50e40fc922fc625271a6a9a0ba045870c790f258fb131ab77c98a9d0e425bb57e42dd66433e62f8a5dd9d2539fdce770f134c1d93793806e0c582c91bcddfc1387415bc2708ba27584330ba8d7426ebe2b8a579d783a56d145e5c6c8b1cc748bcb01d0a91e6c281883a6fb8c4d3af6b3985f977a5f79d55ba1584683887bc70b2564e559a63f7b1c3869dd6ff6bc91bd8912a58ec103f8b63e8641f7f3dd79bb4c7011688b9b41ef35edd8c747db8799d32f19b113b146156270dbf08c4810a822c01986fb3ce5f64b1efdf44d32f0a2252ff0435c68f92d133b241ad28a48c3699198bf5224b9c2c97dcc0b117960bcbc52b4c0d52f05422ecae201d5bcbc6b7f4ae543d4db6d9758b63e39162b632b31693774d8dbd3c0a7ed22db4d73371f2a6e7661581b695454164c6f26bcad2486dc10f1f4c057b5ca85ab4dfd5a0f33beadd60a639a94944239c4bdda03469fabaf1739daf46be4a97ad0f50c158b0a041e081037b57c8fec5663a2da1a229d6e3e92c06143124b223f8945d974dfc2369208062d0db8f264341dc0b8f58e044b5c54cface5b0d3f138b9b3f141a2dc68bdfcefef1d23e8f77da425a388551951eeb72d7217097a4768652f683ef55a39839c00d6716ad04c7d37c05ab9ba8f0398dc1817ab98e654786368f926401e67900d18aed0f80e82a897daff83d22e27f3c569404503d2300ed3986ec414ffdf42dca44454cd0fc884d930dd6b7504919e8a0292fee1cd69e7c1c75e8aeadeefebae9bb28bfff197b156fca2ec83f10f6fc18e8a20af89ffe6102445692e3ea5016a33f11047210cc21f8dc5d4182942a1ec762b1489e13a92feff61e90041ca66ca20ee8ab4ee274f4691c3b2b1a201b7442002e4ef0c0bb1f162b190f482ab27d8a8dcc156ea723b839332bf7e7c57de4a4a76af66157b9a13d571129b667a6f5afb286a224f289301b77a728d99b9f7ebf9495413f51be515c5550aaa217a4deba5ca77561c0544a2fc7280bdfb24d46e9d02e94f47cb4a13842e9ccc8202815393e354bd03437c75ff9e6ba11df9e7df2e4801aeea09570de20793fa0e75cfc86d31f4c3263c3d7ec453a6562d19d99e074ca4a2571fa697097c5419087069002a9db4ded22c5f3ad7ca6f9ca7ffc80ff33abafeb7258e029d69a16645d848629da4b7cf0353c8698bd172052595748f698a4e5b4ce973dc618095a305551486c0edf015deaf82b3fc88821541d92db9eb430074ef5a1fecfc3b53bb73a8de031cce572dcb4612cd15b7a4b526b7244e02c70bc5686abe8f55ea92683a2fd02fd71bbab1bcbe1685c8a4198ee9418d9895d721e99d257cc1f29d7ae0ad43dd68fa28387a00e3e6645d1246fea2b7419b35b36600081fee20799f43530f287b884167b3531faac68fbe63bc0eba8f10320188514e61536795b6561135476e02e84764ef3390d9401b30eea38ad4c8f1cd58035d9a463480190a178669ec0241496e34d0cb68f108e901cd07262f253fe4582ec39ae2c576854a215c6863943fd06580f138c5309d11e4d89f7added7e4d838fa649dc96823f90fb52277aa97577d386032822313de0d746157aa311d68e528b87b0c5202632d335d0a0fdd7ef26020480c07a8c6596d062b14ae6f330fd08280d87b909fa5e4a87d39181d4d3c5252fc77b43d903834b2320243e2ddbaed40a73d3407743399dc379ec9fe79d27ada09973dfa1544337c735af6d526d82f6f2ee79338389a7e18dbee98082ed2754fa17c6bd1ee6938a9e3325789a33bf4c1ef98d8954f1f35937afd21347ba453d57c7f518b86a4045386e43450cbc00fb7a717cb8b55872e0badcd6f63f0d8827fb92a8c649994cfa7cd225d5e8e4a75eed82a0ff20c7d2aa5f5b2c5bf8fd15cfc5faa847dc28ff31fcec5dcb8d1a6be1253315000920597a53870823d0ed036e970caa130347759f2f21289ebacb113acbee8b0a885b8646b6f73f8b8e22eaa18536745a28e475019449f0fa333ec45473ba89a4fce6b1da903e42ab8e27b666d72a45c412129c331a9e80747267819550a2d453a628e1148eed7ec866d64aa189e32b8494c68080d843542a4d7fb2976aa8879fb39b0bf5fc449ded3d2276fcefcbfe5f57710c7d0ce98085735907ce818fba32aaa73c0c93b76510d568e078c180e9317a42d6e6cb95dd52306c26402df5fc98b4988a6e9c4775abca7b069e57bd76d340729ccedd89d1ba0e993a95781e80477b8c6185e2fc5d263cb7df9c5027c8ac40d26035a91f3301d3357db47468b1d9cb22bc488b36f5036b8f71f6b6bff50589150212d60b7e1f98ce800e63087c17fb489c32b9093d2fcd8c22504ce56db5fe1572774209c43e8aeefeb0fbb06a2168740b27906ef968ee139ba4b0c157749522747c7769e7748d9eeec65a21d5f3150fe48be0f60518ba3b88a1a2d51cefe95f75831c64fd98c1c27f7c21e51b0821285a4d49739db786d9389987d44229422c85e816501c3e6ea34645b2a0a9e9957cce304d4a5ddf4474f94ddb98ba803ba0d2e4f9e38e8bd700d68df117016c3f0c0c45a20d484680f342df9e7740bd2adf048a8458876b2eb69b1b55d7dc64fea214c537c57f7313792e08c894e48f22c96a7077fd24dd11bbed8923aa64dd3426e292232ab6709316bff3777e374aee6d2213863569c936a5a2ee4489aa430972b7e1db596f78e6a7c3bd6193bd0d810ed5cf21571bd9a177ba1dc661436e0f25b3e29e3ea023e639abe1144221506d8fa379f65709d88bf072f3f70581e043de3d84873bdcca7feef62b734cc5935bb4c1352f171368932d4e68f32471b338fff40607bd7dbbb064a66d591462bd8a5092798083adf46da0db6b052355185bb8b0dea531e8cecd8c39693284e0617058abab71abcd0f84ba91881d90322d1ba78cbd4f353d0f4cb7fc678d6d3a4649828d91cfddec26c3f649303d90bc10e6c27914d341418f9c525de2860cfc42270787cec9587a8ceba2277d446f4f80a74eca2e48a2ad85fbcc39a202087c474c5ae2273b35e08624e4ebabdeafcd3dc0e0337ddad44e130a88554ae5ac8f434a07904f4c515ec4deb16cbb5b31155e820e705ddae293b81fcf82d3eb80de1e5670ec79d80c5d5f782fa5ee6f9d1ed07f65fe6c43f8466609aa71a821b357cb312b4149a6fc683b52ee07a90c92c2d8d0a13c968e5fe475bba72910f497c1e9d3eb2377cbeed90d8787e20cd07ae1246e1ec5440ec7d098736e2e410bf3e6fee0a04248e719c88c2a0153ed2dcce2cd1362b79ece26fbef19dc5907cc89fc6994e023d38027334c98331ee50957b500b2e58e85428a9a0738f9a6e888413d420845722c0f1c3a32894e53873ff69e78094805e05818bc50bf4b60bb9812d2a7904148433b4c02fff0cdfdeb02a74629c8f9cc9c0bb89498f5b1cf99437f890ecff98ab6dfcf32390e2c70de138453884f5e93a4a48db74780fec8c661cff48e535c77718edd7bef6cca425a86e522a6841547e778fcd92666d3df74797976c388d1c5bc4439955192a540183986522a0ed231ff823a79a26c552e1a239cf6e2c1687ee66723a17e7f10d3e4704ab8ebfb16d617db213f563f48774ecc96ba4ff9d0b06c6be7d6efe68e54422b13d9c7f10a19376ac33032af4b92d7588d09f340e86f1e1acbeff0adc5a62bde01c2a6512ed5fda4faca9ad89d3476402230e0bda24fb1d3964dac2d32cead12a09a9343669519701aa201a1c49885e81efa83f701317571d2e979b7ee745f8418ec37eb129a3902d3ee717b75cd61ab3a9cd177029a103374067a3bba13c1bcd77513d64d56135b221264c5e56262656f83b71a11fcec4e1e909dbf2b4e6d0dfc286746848a27355a0c941269417c28ac1aef36df421ea7a0ddf10db04f74bec23eeca249d245a6009098a0f77c2308f288b06e2bad6c67550a6163d680ba061525599d80fa510e65430feeb0e20a0497de3b21050820786f192027a20c055a8bfdb5982782b691c94efb25fc699e93503ae4c79bc450eda78ea3d521ee9cbdb24c425afdfce4b529d91d24d956b312008e2e95495e4567abd386af2718c4449dea8a175a49f976af4155cfefaf42a85b36bc4c7e4cb3e5424725f51e9d9e19a3f48e09a1130a49569bb8979c2b39af6bd041ce7ca5a7fc009c9548a1bd77b0b85b075e9b516c99a5e4c88ea07b4f6e99cdd8c57b8690a03d0b4da1ae2db1cb8824759793b7ba4d63f0829c38e840c21cf869ad3733c1b67d7ed32c92fdf272bb9f13fa8dc104658be57e68d43389b1e02961f503598cd27ddbd478e03d2023bbc3ba51a5b45cd4141e6dba73d2a5eacd37a58fb9b3a0762054b1ad0e6e1fb3e64fc1ea82b15d8b2c389dd2d047ddba151983cb8830ef1b619db4dd2d1d8d157b91eed38d2e2cd7d114e44a445ddb989909175f318819ad09a3a606f25cd91ae6be84fe7908d727d987a68d1f1d275eda710922cc023410851b9b76e2c87266ac80d96ca6b39008d965b3e415709dff73a89982d39dc6d618d4789126a9c71c8ed01b161f9b5ca252da693bf26b0296273f69de3204d9687ad33ec16306079405a08920ff5247e820cb9aab8795a4ad08cb105ad50c88a759e3d7973b26a1601fd34a51f04c9e47c6d5a067e286f3ac78e9412709c16a255edc5f11fe1d4d2571c328a6e95a0e9d862563ca264dd71e5bb55eb59b87835d77138e13d6d2f0a953b8ce4ab61ad55d4a919eeff6a224a96fd5417d3e559da1992ee69d61e942d85e7a0f1af0ecf6ece180d499b1efb45db80a43217f280845d2fe8d434c20dc48a9900463dbc3d6dacc35a58c2319023b9ab3156eb15945f298a92dc9add00f6e506559edff3cfa40c09d58489570edeef0e5965756fd7e2a45d0d947126d1d2e406a81063d8d9ae79d16d2af88efb688a719c75c86fdf2262dc86fd7ce1b67f6caeef443a1a0d8a6891afd18bc28a675bce4aeffe224dfba5b12f08a1ff6e0c3d1801f513027ee1e8da1ee9030a2b8602f84080eb4c917890464f0873109da737623f89e2306279421d02a185fc2659bd63695aad5c6e2bd30cb7d25421409fb342e482f9abb5b82e876dd96725bcc9d1e7a5d04b18b5f8863f14f5171fa74e4696b178680e9623c5e3667e9315143a6a8f4fe1e7b0f1c7a6aa044b5c211ebddf625620d5f5dced49f5ce2e57f5a804ad0dc905741c683ef796e551bc9232c38d3c30608c28ef1bb53d644ecb25550466f609305c751ab6a68fc1102b9f515c3a1730da999a357082aaeb79c7ec228f28c445c869721f2b4d677f86e399cd1d5b29678af6bc21552196cd77e239cc6da19d228e41a73b47ee72f021683e2a78389f98594ab440933e81971636a0656ea30af659437435db0f960ab4f97639fa2c619e37c6213d142d7cd78acf206ed6f067feac4bf6bc6fd0dfc6a7d84a63e92e6dafbff9883ab04f92407d122b37d159561ea01fc82e42a6651c3b107af5167db042dee1cc9b756c6b235ce2d98e4fce20e4c8f8752f899127ea574c04d290636d9e3229e41baa2ca52104e885a472ce14c59dcc1f0f6ad813ac1e735aa3c4e35ecb43dc7577e1ddd71eac771df2e1b49f23c4eb1bd3033bd326babc2a7bff2ead79cde7e372f38670297638dea722d6d60838d8b1acbf8810e71b47ba28bfe0bd6e940975d7ddad5754635c47d12599096c1c905e17ba5649eafb467a1fa7ed02938908e9b7c0f46454b94e3c22a02e79319fb9995c27702a5b6be8272247881b5eac7478aa8558f9c1be71f14cd73a0ea996d50e30af079ccf87b07d5e1b20d52eee78af8bef6e9da53451a1d9a7cc73a5772e12e902546892ce2133bac2c30a301b3009cde4998a538393107dbf1d7502e6d41e9b53b262bc9578778215d206240b361d097e45747fe8e5dcab5deed02697bd8c38849e2e8c6689a9657f52c75b0b14e8ef4ff3b9661b868c3684cd8d7f12107c1b1a32a1c6b0f322f1732b1a2287b468085ae22195ae5c68ea7ddef9bef8d888f78ec6ebe5cf0cd15191d09136d244c8ec4e3fdbabcc51fe17e0f531f31f45be2a53afbcda34a6ab29d20f8bbce2d4c3d8131ea43a9b8df25431c7b871dceb21261f03a50821eab73c4fcba38f34197eb0352fcc61d1bbb819ee1eb09cb05b84336f55fc8b83ac8402fb824526bc47f6164857ff25bca114dc9a37f71839fd405029da52c1197e85e1a2cdf11cfd35af1877f0b9204d15749ddc7deefcb0d0e09b15fbb47928dd72824edd2628e98fd7d39bad62155c46853b274ff15561455b71f38daa0ad7d0cf1af18a32f82b158294195cb8ca55aff1c86303d5c7b81ccad98831740f85f415416351c8ebb4f761bc66cf359b4b89d1f2fe76e08db8890e568a3b2224dcac0b53c2455ed48736fc243a924ff4461016d9e428e266332421c7778a24233b4c6db6bef9c2db8b33e93efef01d02697bd01789adbc271cbdfa6c9e7fe2ff243e22fc082f01c0535bbdf3d3fa5a34ccbc6632227217a6ace7a387d76477fd52751995d651d7d3040f4f38693888301093753273b92e85433b7346010160bb18cb2bfcd49eeaaefa00d748baa734cd03ca096d25202514325fdf9927014b8f9399a333819970783a5277565736355dfa86d1cc838501b62f4eefa06388a6c5e6e5204df05306b7816c57cf64f2c466335b0cc4744edfd2c222c450c483b45cdf84aefbdc2065515df6d7a41c0f3b39d50c5b9c6e7147825d3e4f724bc3f09287a95b02570908768e29372d85a41a3bdfbe437f2c96f8f30b018b3297d3262c240d6c402694083274fc389e91b982cdba27e8a236ce63751ee33e47646bfeb76e86a73a17bf34d98b6e9389c39ef0904406d188fca0ce71c5760b7c4b745590eb39ad82aa596b6e77ad2fab41e1b0ea76098a9cb968a63007d82f7d3f98553d3f1a9fca550d93a28d2712a7b229df02bce32be7eac71e6bd81f74d5cd7b50688d41d30e4ce6394be1762959abd084c640a4a7a80eee42d0a74d7551810e6fa90ad268909173ca4adac8f9a49a7a4a5c7ae29a373bd48ad4127144a9b07b4604c102f7d276e13c2db3cdf95bac9f45629be333737e91d7b0de05e446f841ae844bd6e1b0be3e2f184150336ba7ac9668a8f1610136c892435b4b4283b3f0dc17bb45497e006b047419417ab82a0e3acb02f12be1959bd3b6c810d653bdd6ef942a911cf662da83838279b4d136ad8303a0c945be4eed5cbd03aa60ccc2de14079bcee9f91aebadc73584e212d583802754ec91346e6baa26dc7c6e3ccb7cdab1a389873a4a40902276342070cd180f96033812e3672509741d98dfc9e05fc35162af2e531d84558b048689f37262d7c944aabd06d86fb833b9378c0ec9e1613b0d6379266dd1047a52834228106564fb19b612bc6c396373ff772a212513b1c4d4b9b7d060358e17fca97212d8a7b39c6707baade48fa02edeef85004d3437c7078ef88bd222dc282d5a4de2479f919f3a2f06c3e22897f89e5403a403950dba8287043832cfa01a211205f0cf857e17bb07c7b7898554459a6b7a2281bb787e3cbe50c82790395daf42b9c26c1480ad632ea1b4fbe4f3d4cca89ece71a4220fa4339aff964bf39ddb133c63fa85b068a2dfcc4c0cd1092b2d7e9d88d9f4a4de93faaa044c0534db611ed65c179d8f284815c9625542866e84c7f931d8b682bd4647bc9e9611594dfbda553f651533256d16d67b8e6ab0fd9dbbf41e2c455643a2341f2d849b1d7656f519b29011d34715cfdcba21a37bb726c29f3a801940e07ef4970f44fd040f0b29ee526c1061a4d580da7899bd4b59e4e7a16a22b0b268ce169409585c1b9746f7284eeba835ea5c2e67de6dcf1935be701ad48e8798044fa8c83e08c26a6c9f8facd5695ea0055e7e81fdaea3f7b9713c8d6c9c948212e5e7eeaa8db15c8876dc1ce063d925bb084a62461fdf3476634c67614efd79790fe9f8710ce6f2d23f15c5ab53d7fe6bf33f91886ba3577d7b1c63a694da13a8c0cd6a3f8571ffcd02ccd6822a9caf8162e95915d8ca259300666dde408985e4f7a2a13614ecc7bd22f8aa0173790a855bd4e541970c1f5ba813acc529487ce5d07ea87c33b0351ef73ea3857ce0834ce064fb0b71818de12b7f9854667ffdf7dd67ba3bdeec777a8ef37d22f36faf1614c58abcb2c4d9a6c010de2dfd9ba864bacedfa239bb16fbb577fc8fecbff769dc5bd2d9731909b0da80cf08c8bd41d8cf0bb30a37872550d3d667d5ab1f22c94eb70518d33fa9337380d596718896a504e1699982c218145980f7db2ff45286edee28c43966540fa0c305efd339e7b0aaa808ee21d3e3a58a9d6c74849f736cd6c456b9054bf8cac36642da3dcbf5f028398ca18f8e76d7775b7ae3ae6960eafaeb6770b5380e585887a626d6fd4f517ab0508ef5bc78e2ac6560cd3e469be21f3390df609bbe350aab25c374a446ab03d0f14e4dff1d45e2cc2aa216848e2e98b47e922595b3f8820c0b8d939b19cef34fd94c3b685fb78bac96e91011378e0c590ba1b9f38e3ed95c5b3949188d9359b60103d3a5ae45b021a89597add3daf2a2d0411c7f8dde40de877aab20a805b12e7fbd7655bd4043367d028b2b68fde69e0300f9e78bdb8534756950116ab3a9e1df2a178183b305eb4a49626e7c862282227d49774efc8c8e7e4669f77518d29caea6594ec01d6e09f71da39538c6c3b8384ddf33af75bef8f98c116cb274b8b209cf493ca1ab23a769588ab602c2cede4e9d69e95bafc6caef82afff15e52b001ab9d2c9bbfff43e85341000a0b877235065eefcaf4199c6db1b51bce5e546c0292dc905fb8bd008f9e94310e2af77955b01f1c5588d825795458d0d746d56ff6b2e9b54f7b10e8cb31c123041dbb38197883817deb4c8792bdd1fb6b9e6357d2ad8c2eb41b10120257081b8e3f18e78972afe1383adcaf6504b80f329295886bdcdc03a7e8a888c609c9c1f677b283bff4afc2cfb05632e8e70bcaca83f97e9f425586ce5946bda0e20dfe5b5f211bc695d514152372e9db15eadc101943a97058becea6c292e0ee0dda94b3fa178df454e00344fbbe70ae5e1bb2ce61c58af2e64e3e2997d2c4aa9cac1b925b16a821689794d6f8baf4946e506f06a371b54f067b1dd2fb4cd80bffba2826b00bd9dd337a191eecd73147da86d428d055f2db6479e53fbfc622ca0bdd5e168de3bce8f75f3a9362ab7473de532e201aa4cc46126963dd87372dbeee2d2b3755b410dfddf2f2927c04e8ac54f8a3d91ad75faefa1b70efd69573ef73c28024acbfb8828c0ce6beb06e247090032349401cfc40362e8d7e316bcf09dbfdc06ba95ab266b36fbcbe5a11433970672b01667d044175f5334587e9c61ed2a7d89ef467fdc912d95eb3af55d1e2a276a6f5a117f2a5fa21a6f7ef4b88768487a8ae44d5c6268a3c41f96b31f29f62130af6222db667de75e8d32c9926ba6e1b0830fb659af4a7c1b3f5bc3da16bec6f86ed0b422e94031e8611dd3dbb815e4f383fd3899a9cfd0cd7ff2af583bda5e4cb283a821549227a1bb59592a30bf8598861895f757d3a161e556360a07d66eb52a0c1293d4bfca3e525031da1895dab3934685d0bf1c05551a0e2fae766863df9c9f90867dc7d8ca55f9aefbcd56577a416fce11580e8257ed63b53bd4651e4439c3092e1ff395283f0b2300d578e051901ab0b3a921dd2a681b3c038e071e4ecedb496874e557e9cb28fbd3dadb8bda31a1b950750f34defed96b943bf8e10c0f33e829bef11fc4a4fca128057db7b342c85a4513bb7272ad4d79c1b3dd7718abaa27692307b8a73c8804212f85fe289a5c29dc681bb607cc4b8ba710dfcc13ae000c8d6988a83c77994b4cd14a22909639ca010ffb6953bdf9ee0d6986f1328ba2901b2b03aec8d4b458f98a9309fb3fd790d93827a1c7afe86afe61d11deb43a5ace3c8d35b38252771ea5791277ca577dd5e22f23507f499ee29551e39badee37d1b90745972bc9ae979b13cc80644d3e028b5f8c80167a7926e255e27dedd384af9b636ef234dae44b4a203d93c3a6109f984a5eee8ab0f4d379437e8f268df876876910fcabd9e2b1ba9adc67d27b6fb09269b04957d44a3ca5de8f00ab1ceae7746040b0e6b713e73af183a9a07f4fe17d3619542c957c6ac9aa417f3be2b4c23349dd70624df85cf5687717136ce5d36ee174aec0970f4203ca3bb574c8f6e5495aec6160e1f1b6f82d7a5f2acffac64145d5f85d194e1507f8db41913d21bdc616b6b9812aef78e1bce76f6e73a3ed546b9ac9a43c55f2f83a8c83d22fbfdc3fb74b2e6716c0c7479568e56ecbb985dff7a762ca31d64ee1025b813244342bd13bd9cd90954763befd8fc28990a147a6b0cce7c72c825c85dc71d64672f9def6988b06735777a800e83a01c4fd81df4ff26225fe3f6e07852d66c96881841e54a14e78a2647d3400cd802aa65e81aedff9136af629fbca6726e5eb858a7a421360fc408a9647ffffde9a128d58ba3870510940f483083478781e385235d06abb2c9b9e714391de7b347edd9ec8e67020e532eb0d2a65b25997e7eb3ee9400a564cabe448df7f939f60ead42c7447b16f3d77647ccaedc5263ef7c2be4946a9f1f010738d9830d9c3ad284ba7b1a88e6251f7387a630636c7c6c6bd2c1ac0a016e7843ebb40225acef6b531ee8f6f37fab231edc3f9a5a7f6faa0145e6e0a2f259424441e928f6849155b57a42ee64a4852a5e5f52130e4d185b2d1a77c95f4b80f4e918d2d8a02e6f64d0612dde194de5c3601f5812019f389ff069bd99167a9721b204acc4d4c43447628f118695973839cc3e5ddcad7a1713697852a86c2cb9e7f264079416a305d00cdb6ea10d5be247930c832ede71ff9b78a119824026e0d6157c709259344077f4b69fa5e47ab06e46ec130c60cdc99270e26abe5d6bc95f1a987d6d44fecbfd3bd16ecafb9ce1722a92614fbbd0433ecb099aed121637ec83f862d035ef474465b78a0cc3725662538a4d45d1afae07a984451973445c16b616e4e4fffea218aebbeb504ebf63614926afd63b4b097788fa41f06c51627b04558acebfafe7b533ac4acf11a7178abf88a0e8df34a971ca654dc5e33939cb245a344a548a0bf18bbaefaf21d4b61ef9bfc544656f650343c4cf5ad4f4c789af231db90b6eff3095ff59dbaed6123dccdb4d5355bea23db371aba2f39f2ee888fd65e1ca8d618aaef0f53d54723bedbbf674a056e07c491b89740754360f06c132e23dcf73ff171f3bafa4fa2e3499208ea3be8f3bc67850e271763496b936f44388464148508041570ab17b81df93ce0d434818e7ed55de09fd48a89e6597adbeda5480bb2c26582c3262dda4b023abca21de6a84d9b188ee8ff87f281eaef55453b6fad603a8ab21f527f0a1f4868dd7cbacf186b7be0d1a8c31db6f4687c9417fd0c9d7cb8d56eccc0920135bc42aab44730265139361a01b9e026501f243133ce80a24312dbf586dc0ee0e350af365ffb91af4eb5f0d0a165f13db12cae5d09bd8bb0f22ff6741fd099a6bc06424325e12369c4cb56b289c94842e37a53b49e311d652c5a3fe93b520099169b297046d638afaf66152a96e0f63405a830600e1b2003bab415b2099f421a912f3c054fed214f3e08ff584b65e6288f9fb07e4d3c622ea10b9fcfd4621c2ae229ad5fc7ddabcbefc4078ff4c80c05b2c0dce1c8da587ffb067d4fed18ce21d5afc6757f30204bc50293791918e2e4bd1d9c2e476b2cc98fce34d11d2f2aecf0cc4ee97d15f72679045bac9b57d46ee17bbd2fc4e4c920a86a2eefb0073587df69a1939fcbbf48d1ffe87161e805a729fc18c03f3f7e1f1f0feebbb6f51b6ddd2c03e8c8550bf6b3e828bbd7f2fb6cd76c07c97cef8d366fde25bc0f816dd330a9d31e02c883276ecfee036074e7cd0032f2b1c755949def37aec803030409ee36e454bb0c4f7ad244ef33878ac1dca642c86474d7185301912eac587bce5b01bff00c08ee51342d05d93e92846e94e29abf676dc16bcc7c48cc0736a7a4353bea2bc4466afaa8ef2586ff447f405aa6f1ca42a37a0a5cb03025317f746365935c811eb08f826ed5d897350aa4b9afcdce9d87688fdb2d5c41335da256285e27119aa810efcc2b18a98c26bb523994d83c1b6a07debec4763b6abcbf3892cf0826b11f3de753d473ab27e69522208ce8918c861ca5758615c0e17182b1f7c4a4e650ab787bd933fda03fe35defb6c0bb6831df265b130dba4f555e10763b7683b703d89dce590f49827cdb722a31bce6b223f6fc69ad2fa5ee70b180bc4073dd7889913fd87709c7498afe9886ce32dd0b1e1b3e04c88dab83414013785b93b25920313b2ec49bdfe5e4e9661c62557ff3861ae6187646495afb477aa46edcee942287e4235b827c8295b5ed84d76ad1a7937e641417fa41ff096d31b26c452bfed238dbdcd7d8f7052ef45c593c76b58105c1c2404ceedda6112f824e365e935097fbb839e735aab79c3bdbfff7d846c01d78ccf270f4c0489069cce5c13750e6f4ddd885537c24e0a7a34cc008540f62c98df9152b9958636a9757145111e1c261e835000106fc7deb36a08b436a85d03c88c0fa587682410812494d9d2160baed8bb85307a60f5dd1b893005a258e2744e0757bef6f3bec7ced30f48f3f54bc8f6ca0f33fc689192eccda90438e4253958abd9d07d1b28f7f8e393ef6ed81fc5bbc492d315178b61087c4c8a609726a2b14aa649c8b3df1ce033a2a4ac00067218f31b8c15198266fcdc58a8891aa40cac7e044b7ad34fcf7b99161438e98714e61d2f4656bfafb59cfaf03b9e3c7fb633005ef73f481af91e290709a4be3116b8978b97b5da5f1aa756a0c2c54488bf67f1b2b30a949348a5cfcdc49156664bea771f9d81f6bbfea220d46c14d8053470104d3e9704b8f58431f3b494afb533a54dd03d44a03d2e0a44bb10efa676555df52d146793304471431ef5f83a3bd48174c292ae70fccc5f14b50f05d40794f340dd8de54d916366fc61c526b9d897037b2296c58f04310e3eef3e1abd1f8574d4066cd3430d91d276f03cfa094de5fd487dcc90e531cf0afe10d09b1f984d256c12b7bdf765be3fe46b7e8b387265290ece4e210c38e35b631024a1503a128dd8abfd69ac669cf785a29a304bfd1e92005a615d021e041defca7d2f325920a32af7287597f9d2da5d584ade5d9e3135c26991e67a74d235054272cfc3196cdd42d4266661deec72772a827ffadffea8275ede3c99b811703391477b5015fd587a4cedae77a7866a4a9c1eac27b0a7db23f44b354971677b4b997abb433f01ab981db516cfb8cccdd1bc5f5dd250fa4304239bb28928085b5ce5a448cf47df00552d654ae4779b3a68208b2fe5603040c94a4f0ef5f1d29efd70d868e3033704fcfc585a0a1f814680b7e1e148658077ad13b5e6d13e985d015a29c43c12174a90c459cf58c87e3a47a2e229033dd59d24cb29e971d0ea36ead6f83d886ef260403718a9129633256d36f6c52b99079b63e5ae1670d7a7bec1b2fa65e36915d04934e401c553b60073e3fc6f54577e12b1b470571c9970a1569e3ef432a267c7f7a034c7ccb80f113b01717337f5a2ff71b2f7963fbcf3645fc7fbbe14b2df515246bba8d6eb3cd558ab14fbe567ce97771928ddecb18a277009e4b75a7bbfa559c97bb09a8a4afd3542437dc3133512529696acaa383a887fd48f0ccbe77b2e283b835b84157f850dfcd683909de3da2469a818202754c6ede629e8e11d6cd87c212fd06fcb98cdc19ed409a2bb18642e9d818332ac1764cd1b6242529fea8696ab19c23a528d2c544cae0a1fe4504af37c623ad2574c143c2fc29d6d66c048f83aebf23d67cee69163457e2d83a8632b16ab2f0687ef2bde50b2ab1386bc18035edf325420d1db8ea7e0dc9f2b4c2658de319efd9557c830531cdb9a92231c3e1f672a4df91051c6dfe20ade0a5511ebc8b52af2e5faa32d2e2eac697007618999b223a6c14b09e4d8e6d328a9cf667e10f38b339fde1d1e59b83eea0231227e9696daf8d5be7edcc29582b3a5764d764d3e07105304e474a0a566ccc35b2d2bbd514669de613a1abe234f1819aedc670f3c2435441ca38edbb6a7eeb632683681e661b7cb79ebb2bc7b6521dbdb76ab9093825e23cd82f3e97e36087642cce2eb2b2841e81eb86755d3f803425ff9c754d0ce1df3f59659aa36768656e54327bdc0f0001d2f98fe1baa76431bb15c357b48fd32519e6f72af385672d630d040618cc436925f40a1d55f1d10337a7a26868e4769fc2a47576d157bbd88e984665acf87cc52f8dc2b2a680dfb8aeadf7c3ad73f205ac699b2e24de04d58104e74fc21664ce7f1192b6a29d2645ee2fae08bf2e04eecada7ddad1556d798ba58746c51732b2d2cb815873a236ef58c07e6071c7e8b12b1a577f301cf782ad757ac4577a10562433edf9006bf4988444eadd4d6ba832538d6c7c4d37879b28cdbba8c4eff7381ed4a6baddb901c0e0e9ee4879e180050e1af3283829b98d21426a33568a9386673e7c8c3771b03cc9e79ea2aaa59c69947f6db7b11409a31e872eb4d5323781a18a1b0869b88ae82b90658850182b6ec8f7cdee8fc3405af5d01696b09cdcea328bf503a5a71f901324522cd9cf98ec024497ed8ace5638fa26634e33c7afe37e260f07077ec7a974fa609dfd9bb36991d6a15795a90a88e1cf9bc1f0fec18008ca17559351a915fedc4eee6643b1a2d3b469e44ca480182876e4c21e57c11117e9af463ea3cb69f60c53b79b255de727bf6075d891f1fb308f933b12e3cb5a9a8161b56d2cbdc6674f287f3d0c8dd4c8c8cff744ffd74b3738a5d1934b800b06f2d38508c86e6f852754a33c7006842710f5bd53b1a831574fbb119158a3eb3a1cce1a7d8738051bcc00daa65f53e450bd6c9f1e677a20d9b1f7052e1893d12f92adca8ece7793ad7e928bf773774c2841f2805187053df8db52ce18e086dce0db4f89b494b9270d72fb86968dc0a7532b05d1260701b99dbf58e744bef37408b3f8492c0280d52834469ffe4ee6a49d8fd25f05aeb61f1e52d5408f10b371cd8567b6655cf566c2ef55dd6f85c0ff4bd5eed017dd1882fa30f33f6d293ee9947f161cebaf592463b8be7f64c7f2dca5a134ab2f7bbdd754a67459adf686e01fd12ad1edac65017a7819a20f0dcbc8d1ef28e8a662b93d7a25f10a8551997ee4c0a2fb259e29a1f94388f8db8868f4f3c905df1de9d2abc73463120d4b1914a6992994fb4c237b07fa47702a8f2492dba4a685cf7e982a3ad48b3d30255047fd2c764e8af0291272dccedf2e976a5f2cf0c5a467739868aceec8453ce70189342fbfea9e98400f653ff37044ff3749fc865607215aefb52a22e84213557846f9153b4b7bc1d9066e476aaac80628919500f9bf8be1abe592e98a122def05c542450e357769f6e4ab448b8bd21eca6566528ef2f36f40d1edfd227d7e195d26014b2643c697a69c702894d5455898e73eaa6cd92a4445e9bcb55b7e05b8e8d5ae382370dc76a46744536426c36e34d65176546c823d2aaab5f9b2a42ac1788fef3bf330b316e56d8d9998d89751c20c85e7f41fdf45179db632d4e57a90e06a2987a3aa2093bc84ec0c40bfe9d96465223cc972beea711e8bacc4a823942d754602737728cd62cd643a1fd66690db302438b150abd43a0e902d432a40c78d60846f1852c878a8c0f6333ee3b8b58469c5427f607f9826bb199070ec6fd481a367b3bd6c6b6d676cb8bd9b3c50fd94454035a60784ac7da985b33b0fe14ebd788d620193b1e7994a1fe78584dfc71ab741d803fca023bc9463ce96ae276856327ea34b04fb7c1b636ee916fb4643731b6d1355c181583ae059f81638c9ac46ed10c9650d04bd971926cb7528a1df20931f68d1b9dd859deaed96fe87f8e513ff76a2988aa5c706380744db56650b0e80dd2ed95611b8aea9c6f2e13a390c8779b06006771d4c13cd360d1c893576f770b7e2e138d8c38b932a918a0dccdedabf366e1b5b838c1fd6fedcae8d5e53fe0a9960657495d34916ab4268e6c0a42dea28673e35fafa57593ca448b9f4d3ce6f7ab305f6670addb9553eeb35f46ad1077a13c1f06ef815e36b582d0d33b2561b5f4d3c3286ee251453460c0f73894c841d073bfdb54ee8d59cfc8865db0eab9a8d04e2cb781463fb299283a6abab933ff24c658e011fc6fd52c03ff647361ff71684036344fc90ccdf74153c9861d3f87e490d098ac5b4dc15bd7ea7b5b5e18df1d66857fd15fa4141baf7b5f44254c09de4b7d708b25d024f7d34a246c647de06df4248dbcb81e474c99bd96fb95776f06f832681a562fda973e0058cf676d1e3286cdcdaf30669e0f3002b9df0c9566d1aa39bf5deb98ea19c7335e3032923ee162bdc8171409507483f16acd9f4f81b2b689f610df5a73bc4bd1cd8f178c226936e1210229e54dcbaa7d82f2126076c491e8d121526253096c46414f4c09bfb1c0ad0746b4d846561feb31eb155b396a8fcf4e0bb32f7d8ae3eec08b41b82ed563c0cd6491d3ddcc722a62250ed6a985c5295224e9510580a89306321eebb90b30631487949e50eb899c3f2e7c9f70e7c6982500505ff1e62fd6eb9db85420278724ed763bab8930c0de6361c9ce8d5e1eb9c2c13703aa3f4f2758fb922754027893deb897839917d3040cd448ee9493a4c655ab41c8346ae00932cf2e4c6e8e290d638f0845c446ad29c141819610e2202d219f5cbb5dad264ca62df6132c49a6eebe2a67081377647868acc6d7a870f9dd81c82b9b08b99ef4ca0d65ab17c1ac3381d6ae42b53362799e7b47e1fb63aa41cabd8f208939bfb50bb49c6c90c3e9306c813b4ca4bd18bc89bb541ba19268e12c4392918a3e22fce9cd8df24fdee1e23d4997fe024524ea5a3925d9d8d79c0a5b9b98220fb88ad6c2335b897d50d1a55e1548304017ac4faac746c4782f1cd997f144cd31043b66394b6f1c7021060fe7c4a8a87d84b71074006291e312f2cf1661b8a320796391c75aedc36be0ccd68bae4be0ec6dbc8cc0a963e1f81cc507047d96f3b5e5dfc5ca6d05e32ed4ec3a325e8230887529943428f10b97b94d8080cd28c9205298a585f841c9037d31c7c289f8a05d61175aa9b8f71e63f0736fccde1658f21a0c7d145486034bcc1a375fc67f06dc18f96b6e9628eb2501a56bf166f3c9f2ceffedec43d0949430fa77006650a6095173f7cb1268c0a6685fd1974c178b90364556c63413677be1219c5e99bd9b1340be6d8ca4cd277ca2ceb0bdc39484e3192add0adc920684c78397b70227c2d7fb80d562696714a9e4d9f6129504dfffd638b35c67795e24e6572f5beb0ab84420d6a32b6d545cbc070b2f774b907adf12fc28f9f8bd9e49581f336c97afa20399607f9f8c220990d5938af8cb54c0a151c85e8034ff1c9ebf2a4c8b5c894eea40650a414f2a1279f51213a5c86173904d89fed64bde2a4043341236bb4b7184ad45642e6977bcd961348ffdbed73fcd3a26ad902f01e7a79c019171a9d282bb0eba0a03beec01c62ee64564dfeced4e0894438e691a64bcf7c786b42649b5a6bf143d3d11dbed1f3413edc9c47faa129d7becab464abb4c76fd1cff8d5f474cd5f6578f08de9083c7d4a7cd0007bd8b168876214167ccc3aca6bd85fd23eb9966fc37c893bb3583566d2f65bdff1cd9fb2d880feb19d2af3e26eca700d173616aac59f102f044a735b5697cedf25b2dbcbaba128d8fc55ef0d015592c52d20ff884069e0bdff1770ac9790f10341858fdce59895f73eb4bb581afa1dd9d10d4e93fabff99f02f465b7248c89ebc317dcd59c8e08c1639b087ff98ed618e1afcb31dec86d510b04a1d3bb600b0350ff98e2dfe03d7604498a3b85679fff9f126e6da4c3c5ef6e591983f63715af78c3f04ddb235914f7862cfafc8f3c2530cf71de6aae5e125ab34f9d412f682214b007f8aa2067ef943d902ea475f966eb6934c512d1485e29317618347592fbc7cf1b47af3f068f2c18fbaf4aa31b7562b8fe606dde939c3cff4e06c97e0b0b14bebc840259d6b0b5abd4e8967c75ad0e0c1fa770808cad9d62cfec3896cf2191bc829248642c0e06692dd9c38c927ff4f3a6eb16d14fee074228fe759cf7b68a532a186b9e170c661bfd7a7ae5a950463d8df7d877552f044a55fe320410b3d54f2d4788f4070463e92fb1f53a2ada7dc31d3e49277a104208e5482aeee416f07feeda69f509966b7b13af053b53689dbce8ba5336302cd4e501c2ffaa88a6a3d4b6ba14c067f5cb8d739279843950ae3c749ffa7ef2ffa0c8500c449464079ec1ef4458b7f97822ea615f328f90a5a789f3d392c2ac106fa60f86294025f092f1b1fe73ff9417bbb98c265c97777af37bc3fdb08bb0001b14c446c40c4b84da5364d58df481cb48b944c1328bc4a5b3f74175ce5b48448c3a1bad5ff1466dd139fdd75767df445411be62a09b8e1a7b8ebadf0b296495de97fe5499762d105c9dc3fba024c8c1276807c72042c1835d9e72d8dfe6a05e8cf751fa7e87eff03b8273bb4755ac75eaaf90664f2fdcd9f598076f84c3a203ab53f8e0f31ec28b2fea57f59920663599b99e115677d95bd2c76311bf10c58534051c4697bb127dc223d33918baa5ee9fbac6f42547ec3719c3fa6c39e54a632e7e43bec46a2685fe07b884e135c42a5f4a0aaee858f2456d57a84176207c1316d00aefa4c018568f4323ae081f8b62c28a22369b9e0ba1350a08b332c645812115b19109f1583ca6e9b60c65160c34df32900d7df7e92321ae3a3a9a3a2784232bac554b0731a0be147bbf073e5bd322534bd9bb3353c36506c8c99a110263997f91a188b9ae54b21672916327a96149e373e1363257c3a7ef627923a229c501089aa3c700d4fb06439e03171c432cbe479497f6821f5dc587e982e32be28c4fa7318ab70c24798e0b9589058415713087985d689a14f4f6433ce0e2b8b5e489f59c0f36f372002e5b27bf50b09bd40614430bdf584e7d8f1f64b7a6b0d693ef14cd7654cb199d693444b0542df0961b51d08f60db8af74da152e4fe5da75ea09b77232d3676f9108bc56ca68e5e5e996ac36a1166418f798085f16306578067d75ccf759dc17745bc40e9f76622670ec7591d8563e769a74055fdd6b70b6bf026d7d2e0e03c9b18b53c02d7bba000d8453774c7eec6769c0cc8965afdb9b658930de48338e24026f7d390feb59de8ddbcf98c2a916038a3ce566132fe82e09edcf4ab1ebded14811c80576a332ab63c552f0675380e9750b4ddbb33360c98189aa8a29ad9df941d337f3e8c34764ca108d713dad3a418ffcb88a6ee44ec082d4b5e2cf5b38226cd9113f1ca611cc6bf01e666d47e3fd09e5e679f6c6dcbb3e90edce1bd648ebcf07fd8d29e4ff7dabd71743c63e17c98b03ae7d4e41928367ae7ac69b0ce345c85776bda54a288a8e28a3d389bdb6cef84e539dde8d9577c198aef4483114e6f744060b89cef7771e2ac5df56016c90a93770199a2a56b0c1c6e6814b37ad9fccb1955382ffbd4365ff1fe0c85a630c0e2356ff1fbb24f440a5efc6e7c31c8aaddfa529c0a487b8b36b17884ff2d1a31e507d475c95504e1d58ae62c119a5f1edf99ef629bd7ec3e805b34ec7d50a788dc09197861efe8f8fb2e3c0919fc1738c42a8b169262d69557e5eb084ca6eb838c283531f2c7ead4e863aafa7d28a1370da6f80b781acd44beb8f11c96f820ab50fcae17ef245fe0d5866c80a3a234728c76576838d39608b466ec0f03aad886de91db368fb53eb561b322f76d3268d067c50e9164d340d670d6288238117abdbf3bc527989737eb5eae45326a32ba3545b40b81b2560037e9872bf8b6021382ca0aad49345473b3b669dc5b6a2fe886ec1c48a66b8ea50ed117b9364de6dd6a2016eb3eab053bebe1e6d64dcb8e0f580abf1899ae3c73385f79900462151e679fd2d2e3faeeeb8b807fe04759fb1adf6edb7b832b9597f00cd809691767de0bb9c68fc7298376c4cfa8fd34cf32459fe25f549af3c8edd1b7a0f39fd737bf8062406a868e8b27d74d3c62e8a19b6b10a6af259c99c895b3c3e3808e67c34ed71df07e66bb7ac1b284879d44c2796ba3a2dd6e1f83809747308f3f35d96585606fe6bd81efe8ae5e8eb6f4c52ed067f2b3d76a60559639f2b213667c78476afa70fc008231222a1f2247e70be8e715c6c46d9fd6f7c86753abbbba36d33265c9dda1981874249a8641c002a1be12377f46fe155a8ec8ea3054efa80482751182515134a5dbbf55a57d062d2f1b9ad7fdbeb92dc94b2b6d908c2334e1e28a02894299f68e297be553a9fe623a62f933f9f23a7de25e94be356e2b0aab088d1333d4c98b8d265f25c4ec48d6b8c03c52fa11c04bdc1d637d79adb1dc4cf7292dad9a90b310506928f663fc97ca34fb9c4aa29281fb8c6c863265813b83a76258195006c767a7e3a45f95fe3f683b89d3763614eed1d2373209337f5639eeba852561f1c3cb5a8bbf422a8662dadf483c073d49a11bf7108748115d3639625372b73a71af155e3dc57957f5d4a260e9078876a3c12b5a9d5d44822a5d4ff6b4ee6698bbd272305229fd46f354045053a51437e64a82c8fc356c43ecac1fd86e69f18b25eb6a7c0e6e88d9ed064082fef3dd6387eca5cfbd34973097ad349abd2a78f845df6dc8a04491b80328b94b99ebc4e78345e8ccaa01128eef2da256db7c4a7daeedee44767f7d7ed3712689fd029996110c8f4ccd82b61e9dcef22617fcc5219dc3236f9b2d7d50cf876cdcd56458c3e234e7f90c922effc7d44a6d5aa469697589161e9e9a589970921b80c818ad5504dfd86ddaf4a6bd2c76bf1343e9925d4e5eb917b82edc4c8bb10071fbf7331ca959ab4b2fb4ff308cfaa17bf31db08ecdc424e4d011c6099d073385597a9d4cc8d9f368ad1a5f908b04ae79a35b4217a90713246095d2d82fac887915af71609f3e7017f95e8466b449ad370f5eb5c8357d880f6211c8563b0ade769c16906705c54eff5919f613618a940f36a8f7992b8942fd5c0b1c93f5a9ed1ab865c8d88660224ff14913b51de4c3f7b3bb2da648f1c1e9c50ffbf1fe4761dc4594eee7c6ebbf8ebfdb2b983b2f528fe8531574b9a12f7d3348c545a9d9a0146d0a6a33ca2f35784710d51998c7e568c1d78c1f7eeed72fbacaef8f50590ec0fec8c7a67977573c107c661ae291908306c11a2404ff18dfde4ac59a03b9e2841b8d17f0f75ca6a87260f912ffe98d8159ef98bc2932aefff3eb29f0d9d0d47c0dc36b5111542cd0d824dc580afb513be73c048cd1f209e168fb56a1d0d56e3bcbe04c99ccf25c73ff5f6f1580349e0b4c10467768330b0a26370e72c19f708b288e6a3d5da860034546ddb4b0f17e4a4200d3e44f1e2b92d495c2d9e81d2dba195752d20f09d2af8e6195a7ee7bc4c3901870f80038f9df37e98e8d03934f302b2b578ef12fd0c18f84c85455ea0d2529302506d62945b59d3258c604a4843a04475522bc770dcfb38a74bc1b57762972b3394145e8195b8569dd32c62969fad2972f39cbad8c6ad80d3d76ae25aad763cdeff9fc7a7b9811112e8894cbcf04ddbebf194d5e96a211e9d0fa5ade36802191b773c7284b10d6d8ca5f3fe951b5770f58403aeaa2c27e8e3c5baeae4f33cfa13672c7e147ceccf2e60f19efe278fe03bb396c4390329fc9e143b9eb7727d826073a9e7b4677af2e517d18c306f04fa717b902e53be436f8d9501528c7afc83b04e4380f914157b4c4a5c41d556a66f535f07d72cc180f14c0d71668a1d7152b495790a00121a64101832d881b757ad9242e4f01a12711092852ebe5b2d6cb909b66a097655cbf1102c71ab648deac7802a84c6ff4521bc5ef1cb516fe100f253bf657ee08b8f6faedf5489e9ed83f533209a9261f9d793e32fcf1b3a097aad2ed01f7d42b190afc10ea457e2233f6744da177c170c92288467a1f80216172189f44eb523295d54a69101de4633f53da0e45e160ef0a2ccad9c9545fe84400d1d65c8298254e7ee3d98af4e43ffe11ab457ff67c6347a4c96ecf1cc2430c8626947d2c00bad4791b8b7b6387c1c34bd5c9ac1c562616dd54355a95131858e8765ddceb549ebe71dfbaa11a2759526eaa948e5f451eb40cd79bfd9ae2c5b0acfa917b169fc8f062160f279c1387f720ed95a9d53d43e537d45366233973e14af6b708ef445bef679ead460ab8ed0acc35bcf05412d4a696c1b45cc440ea316ebe9ddac32baf65bced4186ccb0343b61cff903f1a4980a12dcda940f620bc4491e42f4e07715ef76a3edbbf37441225cf07d39a9efc72efc86887735da93f5012ea727dc8cbf54e586a62f768452e4082b9c74b4cb9adb51c59222232c3a4a88f736617765906358f2603b8f31065e3c7ffb4f9cea5e1374c90c08151457875aa24424111b9493769f344f585eaf5e38819c9061079d6e5447a3e104a5d1a60d79629b26caa3c28a62cdee81be63f54fa3f1cde62fca5a625c11a348c56bae5295b770dcb4bd1d3778644e1cb9bee79c05c9b45616f6839f6bc8cfd494210e354e09b77f9b8d2cc5d62e6e230a5295fadb3cdb3cc05cf0c8e48a19a7460ca3e5aabda4460d7f47d230ee76ffc47dc92fd4377835fc2e2209b1a32d6c7f9c0d35ee8fe0e9beaac3fda3ce30716015943e22061471ee35210bd967b4fdc4a80eeede55bff6139a865afd6721930112afa85c04f8f9e1fb4af10d842d0bba065f941b64c6ea470afa84192147e96d0c460e2fec46f1da8804a6e9c2fdfb49a087a71b23c66413209cd1c4992b6e371f76147a7ef23de55d0cd29c11a2e1e4c9a6f30d74cab034f1131b60076eb167b615dbe175a7a880ef7ef39ff528a520f93b8df9167776479b996f635ec2cd2edfc4ababb256be40e896e35d3a6df74c8ee35665d6c62abd24cbbc53f30fbeeee994878b5f1bf25924f4f1576e923a944019168aa65e820172aa39e2fd006256a6945aeaf3aae17a4870cc2b320c22e249fb726cb53ce171b110c2bc48084fedfd35a8538491872b776eb0f6c6d3d473f20873cec1b31db7e4ad547713a4e22fa91811bafaf9250cc91513521e8cc4ff6e6373800383c665b9311d175b6792c53b09512c46b5852d204a7ba37d045418eec091b1cdae30943cb481be3904d707c8066a63afccbb30a947276e84c15e5069f91cfeece8e8efbbf54a532f65abe0eaa2aa4056ee96fb8acb8298cd6d0dda1c81696cdb3667fb604da5e3aa3942f036031e53a893ebf1661ea1f7e4cf50856735dd6dbc153d951a42184deadc64e159255545ae17d2472ca7d04aceeb2beadf0c9d04cb5da203c354a6cbe018733d9c6cd0f0c16d502d3839b8010397a57c8e6cb4dbb8038d62ed1cc2a302894cc9a9dff8794913e3ed8220a7c7f28ae4c0a25bb42f5e2a484afb35b4549f576a3cc3751de5be7db21e7d64b1e48286fde5dbc39d66048f7d9350a62fa821485357d7cfeb4124735eafd2fb056600f685f7d921a1b8e2b24954f2673110ec0182627c69842a589066e92a60224d30db6b9cc29d84358ad9b34378459be883094575e9e188eecd5ea8e565a385848b10551719d563192c864daa5acbf09fb55b7109aabcbeafb6b95de2bbd78841525272d3b511b7e0cebbb2033e7f62b2aed6b526d9ccc294a251f09be9e5fd7a7eb5432c6ba9d972444c8deafbacf7acb78d2884098726bfcfe382f384804c77aa759d8c70aacc955b38e1ea14c47d7a3d95405863a2c15cd8e52b2b5f77e2bf12cbed97e5d4bf8121a7be3b6505d3725c7b7b848d4511c79b7f08a69d17d87cb433b37884028e5153014590579e3faae82e04cd49bddb076093781d02e5128c9c3250a86979b5afda58b681a02a305ac02c07f2697b7bc865a0bc4ce5b6d6b83fccf9511d9a8ed13f2b14c7f596bc74823116e1a12b9dc84be2727c6deb984b69d97ab07b7f8eb8bb52ba3ff7f19eac4cca3377156e9fcd6e509bafad7abb340eb93f478f61f6d1475cf40d8004d840ab63f3f15308022cb3a07fd7bd3e09ac3027f9510eef87fe794f1c55f8dfae32f9b7a94709e5937db3cc8a8c9bea13c6b72d1b0b9e833efb415f11e83558c12ba1df17fb0053e8abaf4f15d82e0db708392ff8683f78cbba47a412d0fda59629392b6b66ad5b1d6ef6613220bbff1fd56fb12622666468e52905bc61d1f7a165110ea9e54bec917c800a97899a98d7303bec61778d9f24a23ce88a3db43060b2838e70480ab6dcf0e782d275d2ba35a39768d9beaf4aa9fd97ee2e963b94e98d2f3089cc5b3d0a79364aef64c92595df5f43741c320db16d1a5d698551ad236ae733fe7d0e0dde6c32761177cefa5242c5d6a0e7881f0d1a78dac845e37653351bbcd03267216d863a92facd2b437fbbd1abe6dff3d0bf14e2beb871870f25f82ba32e296e84599923954a1fece6f644a7f629d619ca159681625135c3cdb5575b79b28343d816db001837604060d736c1c9fa93c51954c038e327882f1e42ed692904d88838ea2c3ff029308a6dfd4bb151b1e91bf2a118a589e6bde2fab89ca290362e0d6ca10278e4473cc96d900226892e72a1d24340867e4f80c9183d9f6311bb42b552f6d19234644e2cfd575034d116b99a05b9cd824991a639dbed72815ba591a6db909eae75fe59dc218fc2d324856a6fe787860a90eac9aa259266e1d6a1c716694e953ec230617b40955505d15216c32fe588ac34f185415b3c1e22049ce99d9cdf2e08b0563f27ef488e9354cd451766947c1863a8d407d911bfe</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">这里需要密码。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Kalthyix 团队周报</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束</title>
    <url>/2025/07/04/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>血的教训：模拟赛出了个差分约束板子结果发现不会打。</p>
<p><a href="https://www.luogu.com.cn/problem/P5960"
title="题目链接">题目链接</a> ### 引入 我们有一些形如 <span
class="math display">\[x_c-x_{c^\prime}\le y\]</span>
的方程构成了方程组，要求出一组解。
之后进行神奇的关联，我们来看一个求最短路的代码片段： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">	dis[v]=dis[u]+e[i].w;</span><br><span class="line">	<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">		q.<span class="built_in">push</span>(v);</span><br><span class="line">		vis[v]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们发现，这里通过松弛操作维护了 <span class="math display">\[dis[v] \le
dis[u]+e[i].w\]</span> 移项，得 <span
class="math display">\[dis[v]-dis[u]\le e[i].w\]</span>
我们发现，这与题目中所给的方程形式完全一致。所以，我们可以将解方程组转化为一个图论问题，使用最短路算法求出方程的一组解，这就是差分约束系统。
###题目解法 通过观察以上两个式子，发现 <span
class="math inline">\(c\)</span> 对应一条边的 <span
class="math inline">\(v\)</span> 节点，<span
class="math inline">\(c^\prime\)</span> 对应边的 <span
class="math inline">\(u\)</span> 节点，只要建立一个权值为 <span
class="math inline">\(y\)</span> 的边就好了。
但我们发现，这样不一定能保证图的连通性，解决办法是建立一个虚拟的 <span
class="math inline">\(0\)</span> 号超级源点，与每个节点建一条权值为
<span class="math inline">\(0\)</span> 的边。
还有方程无解的问题，对应图论中的负环问题。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span><span class="number">+10</span>,M=<span class="number">1e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,head[N],tot,cnt[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	e[++tot].to=v;</span><br><span class="line">	e[tot].nxt=head[u];</span><br><span class="line">	e[tot].w=w;</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">	vis[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">				dis[v]=dis[u]+e[i].w;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">					vis[v]=<span class="number">1</span>;</span><br><span class="line">					cnt[v]++;</span><br><span class="line">					<span class="keyword">if</span>(cnt[v]==n<span class="number">+1</span>)<span class="comment">//判负环</span></span><br><span class="line">						<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">0</span>);<span class="comment">//虚拟源点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> c1,c2,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;c1,&amp;c2,&amp;y);</span><br><span class="line">		<span class="built_in">add</span>(c2,c1,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 其他形式
若有 <span class="math inline">\(x_c-x_{c^\prime}\ge
y\)</span>，可以两边同时乘 <span class="math inline">\(-1\)</span>
改变不等号方向，或者跑最长路。 若有 <span
class="math inline">\(x_c-x_{c^\prime}=y\)</span>，可以将其拆分为 <span
class="math display">\[
\begin{cases}
x_c-x_{c^\prime}\le y\\
x_c-x_{c^\prime}\ge y
\end{cases}
\]</span> <a href="https://www.luogu.com.cn/record/204400669"
title="End.">End.</a></p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串入门</title>
    <url>/2025/07/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="定义">定义</h3>
<h4 id="前缀">前缀</h4>
<p>对于字符串 <span
class="math inline">\(S\)</span>，从串首开始到某个位置 <span
class="math inline">\(i\)</span> 结束的子串，叫做 <span
class="math inline">\(S\)</span> 的一个前缀，除 <span
class="math inline">\(S\)</span> 本身外的所有前缀叫做 <span
class="math inline">\(S\)</span> 的真前缀。 #### 后缀
与前缀类似，从某位置 <span class="math inline">\(i\)</span>
到串尾的一个字串叫做后缀，同样有真后缀。 ### 字典树/Trie
结构为一棵树，从根节点到树上某一结点的一条路径就是一个字符串。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> c-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> c-<span class="string">&#x27;a&#x27;</span><span class="number">+26</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> c-<span class="string">&#x27;0&#x27;</span><span class="number">+52</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">	<span class="type">int</span> nxt[N][<span class="number">65</span>],tot,cnt[N];</span><br><span class="line">	<span class="type">bool</span> end[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">64</span>;j++)</span><br><span class="line">				nxt[i][j]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">			cnt[i]=<span class="number">0</span>,end[i]=<span class="number">0</span>;</span><br><span class="line">		tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> p=<span class="number">0</span>,len=<span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="type">int</span> c=<span class="built_in">id</span>(s[i]);</span><br><span class="line">			<span class="keyword">if</span>(!nxt[p][c])</span><br><span class="line">				nxt[p][c]=++tot;</span><br><span class="line">			p=nxt[p][c];</span><br><span class="line">			cnt[p]++;</span><br><span class="line">		&#125;</span><br><span class="line">		end[p]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> p=<span class="number">0</span>,len=<span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="type">int</span> c=<span class="built_in">id</span>(s[i]);</span><br><span class="line">			<span class="keyword">if</span>(!nxt[p][c])</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			p=nxt[p][c];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cnt[p];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> #### 应用 字符串查找，前缀统计等。
一些关于后缀的操作可以反转字符串变为前缀操作。 ### KMP 算法 进行 KMP
算法的过程其实就是在求一个叫做<strong>最长公共前后缀</strong>的东西。
定义一个字符串 <span class="math inline">\(S\)</span> 的 border 为 <span
class="math inline">\(S\)</span> 的一个非 <span
class="math inline">\(S\)</span> 本身的子串 <span
class="math inline">\(T\)</span>，满足 <span
class="math inline">\(T\)</span> 既是 <span
class="math inline">\(S\)</span> 的前缀，又是 <span
class="math inline">\(S\)</span> 的后缀。求解最大 border。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">nxt[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//nxt[i]表示字串S[1...i]的最大border的长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(j&amp;&amp;s[j<span class="number">+1</span>]!=s[i])</span><br><span class="line">		j=nxt[j];</span><br><span class="line">	<span class="keyword">if</span>(s[j<span class="number">+1</span>]==s[i])</span><br><span class="line">		j++;</span><br><span class="line">	nxt[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
#### 应用 查找 <span class="math inline">\(S_2\)</span> 串在 <span
class="math inline">\(S_1\)</span> 串的位置。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len2;i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(j&amp;&amp;s2[j<span class="number">+1</span>]!=s2[i])</span><br><span class="line">		j=nxt[j];</span><br><span class="line">	<span class="keyword">if</span>(s2[j<span class="number">+1</span>]==s2[i])</span><br><span class="line">		j++;</span><br><span class="line">	nxt[i]=j;</span><br><span class="line">&#125;</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(j&amp;&amp;s2[j<span class="number">+1</span>]!=s1[i])</span><br><span class="line">		j=nxt[j];</span><br><span class="line">	<span class="keyword">if</span>(s2[j<span class="number">+1</span>]==s1[i])</span><br><span class="line">		j++;</span><br><span class="line">	<span class="keyword">if</span>(j==len2)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i-j<span class="number">+1</span>);</span><br><span class="line">		j=nxt[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
另一种方法是，构建一个新字符串 <span
class="math inline">\(S=S_2+a+S_1\)</span>，进行一次 KMP，若某点 <span
class="math inline">\(nxt\)</span> 值等于 <span
class="math inline">\(S_2\)</span> 的长度则找到了一个解。<span
class="math inline">\(a\)</span> 为字符集以外的任意字符，如
<code>#</code>。</p>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>暑假集训题目合集-2</title>
    <url>/2025/07/13/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86-2/</url>
    <content><![CDATA[<h1 id="day7">Day7</h1>
<h2 id="扫描线">扫描线</h2>
一般使用线段树维护，具体地，维护区间和及区间非零个数。 ### <a
href="https://www.luogu.com.cn/problem/P9478">[NOI2023] 方格染色</a>
横竖线就是扫描线板题。斜线最多只有 <span
class="math inline">\(5\)</span>
个，暴力将能够合并的斜线合并，然后遍历所有横竖线判断是否有交。懒得写离散化了，直接动态开点线段树也能过。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> tot,n,m,q,C,cnt,type3cnt,cnt1,cnt2;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">114</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">    <span class="type">int</span> t,x1,y1,x2,y2;</span><br><span class="line">&#125;a[N],b[<span class="number">114</span>],c[<span class="number">114</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">change</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y1,y2,k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> change &amp;temp)<span class="type">const</span>&#123;<span class="keyword">return</span> x&lt;temp.x;&#125;</span><br><span class="line">&#125;p[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    Node *ls,*rs;</span><br><span class="line">    <span class="type">int</span> val,tag;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line">Node *root;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node *<span class="title">new_node</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> &amp;tree[++tot];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(Node *u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u-&gt;tag) u-&gt;val=r-l<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r) u-&gt;val=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        u-&gt;val=<span class="number">0</span>;</span><br><span class="line">        u-&gt;val+=u-&gt;ls?u-&gt;ls-&gt;val:<span class="number">0</span>;</span><br><span class="line">        u-&gt;val+=u-&gt;rs?u-&gt;rs-&gt;val:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(Node*&amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="literal">nullptr</span>) u=<span class="built_in">new_node</span>();</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">        u-&gt;tag+=k;</span><br><span class="line">        <span class="built_in">push_up</span>(u,l,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(u-&gt;ls,l,mid,x,y,k);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">modify</span>(u-&gt;rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">    <span class="built_in">push_up</span>(u,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(C,n,m,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,t,x1,y1,x2,y2;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(t,x1,y1,x2,y2);</span><br><span class="line">        <span class="keyword">if</span>(t!=<span class="number">3</span>)&#123;</span><br><span class="line">            p[++cnt]=&#123;x1<span class="number">-1</span>,y1,y2,<span class="number">1</span>&#125;;</span><br><span class="line">            p[++cnt]=&#123;x2,y1,y2,<span class="number">-1</span>&#125;;</span><br><span class="line">            a[++cnt1]=&#123;t,x1,y1,x2,y2&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> b[++type3cnt]=&#123;<span class="number">3</span>,x1,y1,x2,y2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p<span class="number">+1</span>,p<span class="number">+1</span>+cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="built_in">modify</span>(root,<span class="number">1</span>,<span class="number">1e9</span>,p[i].y1,p[i].y2,p[i].k);</span><br><span class="line">        ans+=root-&gt;val*(p[i<span class="number">+1</span>].x-p[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=type3cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=type3cnt;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j||vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(b[j].x2-b[i].x1==b[j].y2-b[i].y1&amp;&amp;b[j].x1&lt;=b[i].x2&amp;&amp;b[j].x2&gt;=b[i].x2)&#123;</span><br><span class="line">                    b[i].x1=<span class="built_in">min</span>(b[i].x1,b[j].x1);</span><br><span class="line">                    b[i].y1=<span class="built_in">min</span>(b[i].y1,b[j].y1);</span><br><span class="line">                    b[i].x2=<span class="built_in">max</span>(b[i].x2,b[j].x2);</span><br><span class="line">                    b[i].y2=<span class="built_in">max</span>(b[i].y2,b[j].y2);</span><br><span class="line">                    vis[j]=<span class="number">1</span>;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=type3cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        c[++cnt2]=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt2;i++)&#123;</span><br><span class="line">        set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt1;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j].t==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> tx=c[i].x1+a[j].y1-c[i].y1;</span><br><span class="line">                <span class="keyword">if</span>(tx&lt;c[i].x1||tx&gt;c[i].x2||tx&lt;<span class="number">1</span>||tx&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(tx&lt;a[j].x1||tx&gt;a[j].x2) <span class="keyword">continue</span>;</span><br><span class="line">                pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; temp=&#123;tx,a[j].y1&#125;;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">find</span>(temp)==st.<span class="built_in">end</span>())</span><br><span class="line">                    --ans,st.<span class="built_in">insert</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[j].t==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">int</span> ty=c[i].y1+a[j].x1-c[i].x1;</span><br><span class="line">                <span class="keyword">if</span>(ty&lt;c[i].y1||ty&gt;c[i].y2||ty&lt;<span class="number">1</span>||ty&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(ty&lt;a[j].y1||ty&gt;a[j].y2) <span class="keyword">continue</span>;</span><br><span class="line">                pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; temp=&#123;a[j].x1,ty&#125;;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">find</span>(temp)==st.<span class="built_in">end</span>())</span><br><span class="line">                    --ans,st.<span class="built_in">insert</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=c[i].x2-c[i].x1<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day8">Day8</h1>
<h2 id="树上技巧">树上技巧</h2>
<p>树的直径的求法：<br />
- 两遍 dfs/bfs（无法处理负边权） - 树形 DP（可以处理负边权）</p>
这两种方法的时间复杂度均为 <span
class="math inline">\(O(n)\)</span>。<br />
树形 DP 具体求法：<br />
设 <span class="math inline">\(dp_{u,0/1}\)</span> 表示以 <span
class="math inline">\(u\)</span>
为根的子树中从根向下能延伸的最长/非严格次长路径。则答案为 <span
class="math inline">\(dp_{u,0}+dp_{u,1}\)</span> 的最大值。 ### <a
href="https://www.luogu.com.cn/problem/P3629">[APIO2010] 巡逻</a>
老题了。考虑贪心，<span class="math inline">\(k=1\)</span>
时连接直径两端是显然的。设直径为 <span
class="math inline">\((u_1,v_1)\)</span>，加入的第二条边为 <span
class="math inline">\((u_2,v_2)\)</span>，二者不交时答案显然为 <span
class="math inline">\(dis(u_1,v_1)+dis(u_2,v_2)\)</span>，若两路径有交，形如<br />
<img
src="https://github.com/headless-piston/blog_images/blob/main/P3629.png?raw=true" />
则答案为 <span
class="math inline">\(dis(u_1,v_2)+dis(u_2,v_1)\)</span>。由此可以看出，若仍要选在直径上的边，代价会更大。则我们将直径的边权全部设为
<span class="math inline">\(-1\)</span>，再找一个新的直径。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,k,ans,dis[N],a,b,pre[N],head[N],dp[N][<span class="number">2</span>],maxn;</span><br><span class="line"><span class="type">bool</span> vis[N],tag[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">bool</span> flag,<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v]=dis[u]<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag) pre[v]=u;</span><br><span class="line">        <span class="keyword">if</span>(dis[v]&gt;dis[x]) x=v;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,flag,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,u);</span><br><span class="line">        <span class="type">int</span> w=tag[u]&amp;&amp;tag[v]?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> temp=dp[v][<span class="number">0</span>]+w;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;dp[u][<span class="number">0</span>])</span><br><span class="line">            dp[u][<span class="number">1</span>]=dp[u][<span class="number">0</span>],dp[u][<span class="number">0</span>]=temp;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;dp[u][<span class="number">1</span>])</span><br><span class="line">            dp[u][<span class="number">1</span>]=temp;</span><br><span class="line">        maxn=<span class="built_in">max</span>(maxn,dp[u][<span class="number">0</span>]+dp[u][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a,b);</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>,a);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">dfs1</span>(a,<span class="number">1</span>,b);</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        ans=(n<span class="number">-1</span>)*<span class="number">2</span>-dis[b]<span class="number">+1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b;i;i=pre[i]) tag[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ans=n*<span class="number">2</span>-dis[b]-maxn;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="noi2021-轻重边"><a
href="https://www.luogu.com.cn/problem/P7735">[NOI2021] 轻重边</a></h3>
结论：每次修改操作染不同颜色，重边数等于区间内相邻两点颜色相同的点对数。树剖+线段树维护即可。精细处理树剖的查询部分。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> t,n,m,siz[N],son[N],dep[N],fa[N],dfn[N],dfncnt,top[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    son[u]=<span class="number">0</span>;</span><br><span class="line">    dep[u]=dep[f]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]])</span><br><span class="line">            son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">    dfn[u]=++dfncnt;</span><br><span class="line">    top[u]=topf;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) <span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc,cnt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">friend</span> node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.lc==<span class="number">-1</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(b.lc==<span class="number">-1</span>) <span class="keyword">return</span> a;</span><br><span class="line">        node res;</span><br><span class="line">        res.lc=a.lc,res.rc=b.rc;</span><br><span class="line">        res.cnt=a.cnt+b.cnt;</span><br><span class="line">        <span class="keyword">if</span>(a.rc==b.lc&amp;&amp;a.rc) ++res.cnt;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> tag[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> P,DEP;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) (x&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> siz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tag[u]) <span class="keyword">return</span>;</span><br><span class="line">    tree[<span class="built_in">ls</span>(u)]=tree[<span class="built_in">rs</span>(u)]=&#123;tag[u],tag[u],(siz&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>&#125;;</span><br><span class="line">    tag[<span class="built_in">ls</span>(u)]=tag[<span class="built_in">rs</span>(u)]=tag[u];</span><br><span class="line">    tag[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    l+=P<span class="number">-1</span>,r+=P<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=DEP;i;i--) <span class="built_in">push_down</span>(l&gt;&gt;i,<span class="number">1</span>&lt;&lt;i),<span class="built_in">push_down</span>(r&gt;&gt;i,<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    <span class="type">int</span> siz=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l^<span class="number">1</span>^r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~l&amp;<span class="number">1</span>) tree[l^<span class="number">1</span>]=&#123;k,k,siz<span class="number">-1</span>&#125;,tag[l^<span class="number">1</span>]=k;</span><br><span class="line">        <span class="keyword">if</span>(r&amp;<span class="number">1</span>) tree[r^<span class="number">1</span>]=&#123;k,k,siz<span class="number">-1</span>&#125;,tag[r^<span class="number">1</span>]=k;</span><br><span class="line">        l&gt;&gt;=<span class="number">1</span>,r&gt;&gt;=<span class="number">1</span>,siz&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        tree[l]=tree[<span class="built_in">ls</span>(l)]+tree[<span class="built_in">rs</span>(l)];</span><br><span class="line">        tree[r]=tree[<span class="built_in">ls</span>(r)]+tree[<span class="built_in">rs</span>(r)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(l&gt;&gt;=<span class="number">1</span>;l;l&gt;&gt;=<span class="number">1</span>) tree[l]=tree[<span class="built_in">ls</span>(l)]+tree[<span class="built_in">rs</span>(l)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    node resl=&#123;<span class="number">-1</span>&#125;,resr=&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">    l+=P<span class="number">-1</span>,r+=P<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=DEP;i;i--) <span class="built_in">push_down</span>(l&gt;&gt;i,<span class="number">1</span>&lt;&lt;i),<span class="built_in">push_down</span>(r&gt;&gt;i,<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    <span class="keyword">while</span>(l^<span class="number">1</span>^r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~l&amp;<span class="number">1</span>) resl=resl+tree[l^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(r&amp;<span class="number">1</span>) resr=tree[r^<span class="number">1</span>]+resr;</span><br><span class="line">        l&gt;&gt;=<span class="number">1</span>,r&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resl+resr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">modify</span>(dfn[top[x]],dfn[x],k);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">modify</span>(dfn[x],dfn[y],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,c1=<span class="number">0</span>,c2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">            <span class="built_in">swap</span>(c1,c2);</span><br><span class="line">        &#125;</span><br><span class="line">        node res=<span class="built_in">query</span>(dfn[top[x]],dfn[x]);</span><br><span class="line">        ans+=res.cnt;</span><br><span class="line">        <span class="keyword">if</span>(res.rc==c1&amp;&amp;c1) ++ans;</span><br><span class="line">        c1=res.lc;</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">swap</span>(c1,c2);</span><br><span class="line">    &#125;</span><br><span class="line">    node res=<span class="built_in">query</span>(dfn[x],dfn[y]);</span><br><span class="line">    ans+=res.cnt;</span><br><span class="line">    <span class="keyword">if</span>(res.rc==c2&amp;&amp;c2) ++ans;</span><br><span class="line">    <span class="keyword">if</span>(res.lc==c1&amp;&amp;c1) ++ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,op,a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        dfncnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) e[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">read</span>(n,m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">read</span>(u,v);</span><br><span class="line">            e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in">sizeof</span>(node)*(n*<span class="number">4</span><span class="number">+10</span>));</span><br><span class="line">        <span class="built_in">memset</span>(tag,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(n*<span class="number">4</span><span class="number">+10</span>));</span><br><span class="line">        P=<span class="number">1</span>,DEP=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(P&lt;=n<span class="number">+1</span>) P&lt;&lt;=<span class="number">1</span>,++DEP;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">read</span>(op,a,b);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">change</span>(a,b,++cnt);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ask</span>(a,b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="十二省联考-2019-春节十二响"><a
href="https://www.luogu.com.cn/problem/P5290">[十二省联考 2019]
春节十二响</a></h3>
贪心策略：令两条链上各自权值最大的比较，次大的比较……则可以在每个节点开一个堆，启发式合并。不同于可并堆，节点
<span class="math inline">\(u\)</span>，<span
class="math inline">\(v\)</span> 的堆合并后的大小为 <span
class="math inline">\(\max(size_u,size_v)\)</span> 而非 <span
class="math inline">\(size_u+size_v\)</span>，时间复杂度为 <span
class="math inline">\(O(n\log n)\)</span>。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m[N];</span><br><span class="line">ll ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">if</span>(q[x].<span class="built_in">size</span>()&lt;q[y].<span class="built_in">size</span>()) <span class="built_in">swap</span>(q[x],q[y]);</span><br><span class="line">    <span class="keyword">while</span>(q[y].<span class="built_in">size</span>())&#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(<span class="built_in">max</span>(q[x].<span class="built_in">top</span>(),q[y].<span class="built_in">top</span>()));</span><br><span class="line">        q[x].<span class="built_in">pop</span>(),q[y].<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k:temp) q[x].<span class="built_in">push</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="built_in">merge</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    q[u].<span class="built_in">push</span>(m[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(m[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,f;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(f),e[f].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q[<span class="number">1</span>].<span class="built_in">empty</span>()) ans+=q[<span class="number">1</span>].<span class="built_in">top</span>(),q[<span class="number">1</span>].<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day9">Day9</h1>
<h2 id="数论">数论</h2>
<h3 id="taoi-2喵了个喵-ⅳ"><a
href="https://www.luogu.com.cn/problem/P9575">「TAOI-2」喵了个喵
Ⅳ</a></h3>
神秘题。<span class="math inline">\(n\)</span> 为偶数时显然。<span
class="math inline">\(n\)</span> 为奇数时先求出所有数的最大公约数 <span
class="math inline">\(d\)</span>，此时取 <span
class="math inline">\(x=2\)</span>，将所有数都约去 <span
class="math inline">\(d\)</span>，此时若有奇数个奇数，则会有偶数个偶数，必然无解，反之则可以按照奇偶容易地构造一组解。最后答案为
<span class="math inline">\(2d\)</span>。<br />

<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],d,cntodd,cnteven;</span><br><span class="line"><span class="type">bool</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">read</span>(a[i]);</span><br><span class="line">            d=__gcd(d,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            a[i]/=d;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>) ++cntodd;</span><br><span class="line">            <span class="keyword">else</span> ++cnteven;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cntodd&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,cnt=<span class="number">0</span>;i&lt;=n&amp;&amp;cnt&lt;cntodd/<span class="number">2</span><span class="number">-1</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>) ans[i]=<span class="number">1</span>,++cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,cnt=<span class="number">0</span>;i&lt;=n&amp;&amp;cnt&lt;(cnteven<span class="number">+1</span>)/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(~a[i]&amp;<span class="number">1</span>) ans[i]=<span class="number">1</span>,++cnt;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">2</span>*d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ctsc2017-吉夫特"><a
href="https://www.luogu.com.cn/problem/P3773">[CTSC2017] 吉夫特</a></h3>
这题的转化真是神了。发现题目中 <span class="math inline">\(\bmod
2\)</span> 很特殊，<span class="math inline">\(\dbinom{a_{b_1}}{a_{b_2}}
\times \dbinom{a_{b_2}}{a_{b_3}} \times \cdots \times
\dbinom{a_{b_{k-1}}}{a_{b_k}} \bmod 2 &gt;0\)</span>
成立当且仅当对于任意 <span class="math inline">\(k&gt;1\)</span>，<span
class="math inline">\(\dbinom{a_{b_{k-1}}}{a_{b_k}}\bmod
2=1\)</span>，我们尝试使用 Lucas 定理展开<br />
<span class="math display">\[\binom{a_{b_{k-1}}}{a_{b_k}}\equiv
\binom{\lfloor a_{b_{k-1}}/2\rfloor}{\lfloor
a_{b_k}/2\rfloor}\binom{a_{b_{k-1}}\bmod 2}{a_{b_k}\bmod 2}\pmod
2\]</span>
持续展开，不难发现其等于两数二进制拆分后每一位的组合数相乘，又因为<br />
<span
class="math display">\[\binom{1}{1}=\binom{1}{0}=\binom{0}{0}=1\]</span>
<span class="math display">\[\binom{0}{1}=0\]</span> 所以 <span
class="math inline">\(\dbinom{a_{b_{k-1}}}{a_{b_k}}\bmod 2=1\)</span>
当且仅当 <span class="math inline">\(a_{b_k}\)</span> 在二进制下是 <span
class="math inline">\(a_{b_{k-1}}\)</span> 的子集，即 <span
class="math inline">\(a_{b_{k-1}} \operatorname{bitand}
a_{b_k}=a_{b_k}\)</span>。则我们可以推出 DP 方程，设 <span
class="math inline">\(dp_{i}\)</span> 表示以 <span
class="math inline">\(i\)</span> 为结尾的子序列方案数：<br />
<span class="math display">\[dp_{a_i}=\sum_{a_i\in a_j\land
j&lt;i}(dp_{a_j}+1)\]</span> <span
class="math inline">\(O(3^{\log{\max(a_i)}})\)</span>
子集枚举即可。<br />

<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1000000007</span>,N=<span class="number">233350</span>;</span><br><span class="line"><span class="type">int</span> n,a,dp[N],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s=(a<span class="number">-1</span>)&amp;a;s;s=(s<span class="number">-1</span>)&amp;a)</span><br><span class="line">            dp[s]=(dp[s]+dp[a]<span class="number">+1</span>)%mod;</span><br><span class="line">        ans=(ans+dp[a])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day10">Day10</h1>
<h2 id="线性代数">线性代数</h2>
<h3 id="usaco07nov-cow-relays-g"><a
href="https://www.luogu.com.cn/problem/P2886">[USACO07NOV] Cow Relays
G</a></h3>
我们使用 <span class="math inline">\(\min\)</span> 和 <span
class="math inline">\(+\)</span> 代替原矩阵乘法中的 <span
class="math inline">\(+\)</span> 和 <span
class="math inline">\(\times\)</span>，也就是<br />
<span class="math display">\[C_{i,j}=\min(A_{i,k}+B_{k,j})\]</span> 设
<span class="math inline">\(A_{i,j}\)</span> 表示 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j\)</span> 的最短路，则走 <span
class="math inline">\(n\)</span> 步后的最短路即为 <span
class="math inline">\(A_{i,j}^n\)</span>。<br />
设离散化后点有 <span class="math inline">\(m\)</span> 个，时间复杂度
<span class="math inline">\(O(m^3\log n)\)</span>。<br />

<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1010</span>,M=<span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> n,t,s,e,a[N],cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> u,v,w;&#125;edge[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> x[M][M];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(x,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(x));&#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        Matrix res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=cnt;k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">                    res.x[i][j]=<span class="built_in">min</span>(res.x[i][j],x[i][k]+a.x[k][j]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;b;</span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    Matrix res=a;</span><br><span class="line">    --b;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,t,s,e);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=t;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(w,u,v);</span><br><span class="line">        <span class="keyword">if</span>(!a[u]) a[u]=++cnt;</span><br><span class="line">        <span class="keyword">if</span>(!a[v]) a[v]=++cnt;</span><br><span class="line">        b.x[a[u]][a[v]]=b.x[a[v]][a[u]]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    b=<span class="built_in">qpow</span>(b,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b.x[a[s]][a[e]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="模板矩阵求逆"><a
href="https://www.luogu.com.cn/problem/P4783">【模板】矩阵求逆</a></h3>
本题中的矩阵均为方阵。<br />
矩阵的逆：在模 <span class="math inline">\(p\)</span> 意义下，若 <span
class="math inline">\(B\times A=A\times B=I\)</span>，则 <span
class="math inline">\(B\)</span> 称为模 <span
class="math inline">\(p\)</span> 意义下 <span
class="math inline">\(A\)</span> 的逆矩阵，记作 <span
class="math inline">\(A^{-1}\)</span>。模 <span
class="math inline">\(p\)</span>
意义下,一个矩阵若有逆矩阵，则必然只有一个逆矩阵。<br />
矩阵的逆可以用高斯-约旦消元求出。原理：使用初等行变换将矩阵 <span
class="math inline">\(A\)</span> 转化为单位矩阵 <span
class="math inline">\(I\)</span>，同时对一个初始的单位矩阵 <span
class="math inline">\(I\)</span>
进行相同的初等行变换，最终得到的就是逆矩阵 <span
class="math inline">\(A^{-1}\)</span>。<br />
例如，我们构造原矩阵 <span class="math inline">\([A\mid
I]\)</span>，进行一系列初等行变换后，得到 <span
class="math inline">\([I\mid
A^{-1}]\)</span>。我们发现，高斯-约旦消元的过程就是将矩阵的左半部分变为单位矩阵的过程，非常适合求解矩阵的逆。<br />
无解判断：若消元过程中，主元与 <span class="math inline">\(p\)</span>
不互质则无解。<br />

<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>,N=<span class="number">410</span>;</span><br><span class="line"><span class="type">int</span> n,a[N][N*<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">read</span>(a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i][i+n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,cur,line=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cur=line;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=line<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j][i]&gt;a[cur][i])</span><br><span class="line">                cur=j;</span><br><span class="line">        <span class="keyword">if</span>(__gcd(a[cur][i],mod)!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll inv=<span class="built_in">qpow</span>(a[cur][i],mod<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=(n&lt;&lt;<span class="number">1</span>);j++)</span><br><span class="line">            <span class="built_in">swap</span>(a[cur][j],a[line][j]),a[line][j]=a[line][j]*inv%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(j!=line)&#123;</span><br><span class="line">                ll temp=a[j][i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=(n&lt;&lt;<span class="number">1</span>);k++)</span><br><span class="line">                    a[j][k]=((a[j][k]-a[line][k]*temp)%mod+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        ++line;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j+n]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <tags>
        <tag>题目合集</tag>
      </tags>
  </entry>
  <entry>
    <title>海盗分金问题</title>
    <url>/2025/06/25/%E6%B5%B7%E7%9B%97%E5%88%86%E9%87%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>很抽象的问题，记录一下思路免得自己忘掉。 ### 题意简述 现有 <span
class="math inline">\(5\)</span> 个海盗，编号 <span
class="math inline">\(1\sim
5\)</span>，每个海盗都绝顶聪明且理性。他们要分配 <span
class="math inline">\(100\)</span> 个金币。规则如下：</p>
<ul>
<li><p>按照 <span class="math inline">\(1\sim 5\)</span>
的方式给出分配方案；</p></li>
<li><p>所有人都对分配方案进行投票；</p></li>
<li><p>若赞成人数过半，则按此方案分配，反之，提出方案者被丢到海里喂鲨鱼，由下一个人给出方案；</p></li>
<li><p>在金币数量相同的情况下，海盗会更倾向于让尽可能多的人喂鲨鱼，即更倾向于投反对票。</p></li>
</ul>
<p>问：<span class="math inline">\(1\)</span> 号海盗最多分得多少金币？
### 推导过程 考虑倒推。 若 <span class="math inline">\(1\sim 3\)</span>
均已喂了鲨鱼，现在场上剩 <span class="math inline">\(4\)</span> 和 <span
class="math inline">\(5\)</span>，<span class="math inline">\(5\)</span>
号一定投反对票让 <span class="math inline">\(4\)</span>
号喂鲨鱼，独吞金币。所以，在场上有 <span class="math inline">\(3\sim
5\)</span> 时，<span class="math inline">\(4\)</span>
号为了保命一定投赞成票。 由于 <span class="math inline">\(4\)</span>
号一定投赞成，<span class="math inline">\(3\)</span> 号可以给出方案
<span class="math inline">\((100,0,0)\)</span>，得到全部金币。 <span
class="math inline">\(2\)</span> 号可以依据 <span
class="math inline">\(3\)</span> 号的方案，给出 <span
class="math inline">\((98,0,1,1)\)</span>。由于 <span
class="math inline">\(4,5\)</span> 赞成 <span
class="math inline">\(2\)</span> 号能获得比 <span
class="math inline">\(3\)</span> 号更大的利益，所以一定赞成 <span
class="math inline">\(2\)</span> 号。 <span
class="math inline">\(1\)</span> 号拿出更大的诚意，给出 <span
class="math inline">\((97,0,1,2,0)\)</span> 或 <span
class="math inline">\((97,0,1,0,2)\)</span>，对于 <span
class="math inline">\(3\)</span> 号和 <span
class="math inline">\(4/5\)</span> 号来说，这比 <span
class="math inline">\(2\)</span> 号更优。</p>
]]></content>
  </entry>
  <entry>
    <title>暑假集训题目合集-1</title>
    <url>/2025/07/11/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86-1/</url>
    <content><![CDATA[Day <span class="math inline">\(n\)</span> 指第 <span
class="math inline">\(n\)</span> 个讲课日，模拟赛过屎，不放了。 # Day1
## 单调队列优化 DP 一般形如 <span
class="math inline">\(dp_i=\max_{j\in[l_i,r_i]}(f(j))+g(j)\)</span>
的形式可以进行单调队列优化，其中 <span
class="math inline">\(f(i)\)</span> 是一个关于 <span
class="math inline">\(j\)</span> 的函数，<span
class="math inline">\([l_i,r_i]\)</span> 是滑动窗口。 ### <a
href="https://www.luogu.com.cn/problem/P1776">宝物筛选</a>
多重背包优化。<span class="math inline">\(O(nW\log m)\)</span>
的二进制拆分优化就不讲了。<br />
考虑朴素的 <span class="math inline">\(O(nWm)\)</span> 转移： <span
class="math display">\[dp_{j}=\max_{k=0}^{m_i}(dp_{j-k\times
w_i}+k\times v_i)\]</span><br />
尝试改写成适合单调队列优化的形式，按余数分组：<br />
设当前 <span class="math inline">\(r=j\bmod w_i\)</span>，<span
class="math inline">\(t=\lfloor
j/w_i\rfloor\)</span>，状态转移方程改写为： <span
class="math display">\[dp_j=\max_{k=0}^{\min(m_i,t)}(dp_{r+(t-k)\cdot
w_i}+k\cdot v_i)\]</span> 令 <span
class="math inline">\(t&#39;=t-k\)</span>，则 <span
class="math inline">\(k=t-t&#39;\)</span>： <span
class="math display">\[\begin{aligned}
dp_j&amp;=\max(dp_{r+t&#39;\cdot w_i}+(t-t&#39;)\cdot v_i)\\
&amp;=\max(dp_{r+t&#39;\cdot w_i}+t&#39;\cdot v_i)+t\cdot v_i
\end{aligned}\]</span> <span
class="math inline">\(t&#39;\in[\max(0,t-m_i),t]\)</span>，构成一个滑动窗口。<br />
时间复杂度 <span class="math inline">\(O(nW)\)</span>。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">4e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    <span class="type">int</span> val,t;</span><br><span class="line">    <span class="built_in">Queue</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">int</span> val,<span class="type">int</span> t):<span class="built_in">val</span>(val),<span class="built_in">t</span>(t)&#123;&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="type">int</span> n,W,v,w,m,dp[N],l,r,tag,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,W);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(v,w,m);</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">0</span>)&#123;</span><br><span class="line">            tag+=v*m;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;w;d++)&#123;</span><br><span class="line">            l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;d+t*w&lt;=W;t++)&#123;</span><br><span class="line">                <span class="type">int</span> j=t*w+d,val=dp[j]-t*v;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[r].val&lt;=val) --r;</span><br><span class="line">                q[++r]=<span class="built_in">Queue</span>(val,t);</span><br><span class="line">                <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l].t&lt;t-m) ++l;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(q[l].val+t*v,dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=W;i++) ans=<span class="built_in">max</span>(ans,dp[i]+tag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="noi2005-瑰丽华尔兹"><a
href="https://www.luogu.com.cn/problem/P2254">[NOI2005]
瑰丽华尔兹</a></h3>
单调队列优化 DP。<br />
容易想到 <span class="math inline">\(O(nmT)\)</span> 的方程：设 <span
class="math inline">\(dp_{t,i,j}\)</span> 表示在 <span
class="math inline">\((i,j)\)</span> 位置经过 <span
class="math inline">\(t\)</span> 时间的答案，容易写出转移： <span
class="math display">\[dp_{t,i,j}=\max(dp_{t-1,i,j},dp_{t-1,i&#39;,j&#39;}+1)\]</span>
考虑优化成 <span
class="math inline">\(O(nmk)\)</span>，则我们首先将状态优化为 <span
class="math inline">\(dp_{k,i,j}\)</span> 表示第 <span
class="math inline">\(k\)</span> 个区间，在 <span
class="math inline">\((i,j)\)</span> 位置的答案。转移变为 <span
class="math display">\[dp_{k,i,j}=\max(dp_{k-1,i&#39;,j&#39;}+dis)\]</span>
具体地，假设当前在向 <span class="math inline">\(i\)</span>
的正方向滑行，我们可以写出： <span
class="math display">\[dp_{k,i,j}=\max_{pos=i-len_k}^i(dp_{k-1,pos,j}-pos)+i\]</span>
其余三个方向同理，这就可以单调队列优化了。<br />
可以滚动数组去掉 <span class="math inline">\(k\)</span> 这一维。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Abs</span><span class="params">(<span class="type">const</span> T &amp;x)</span></span>&#123;<span class="keyword">return</span> x&lt;<span class="number">0</span>?~x<span class="number">+1</span>:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?b:a;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">210</span>,fx[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,fy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    <span class="type">int</span> val,x,y;</span><br><span class="line">    <span class="built_in">Queue</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">int</span> val,<span class="type">int</span> x,<span class="type">int</span> y):<span class="built_in">val</span>(val),<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;ax,<span class="type">const</span> <span class="type">int</span> &amp;ay,<span class="type">const</span> <span class="type">int</span> &amp;bx,<span class="type">const</span> <span class="type">int</span> &amp;by)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Abs</span>(ax-bx)+<span class="built_in">Abs</span>(ay-by);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,sx,sy,k,dp[N][N],op,l,r,ans;</span><br><span class="line"><span class="type">char</span> s[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">1</span>&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&lt;=m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[x][y]==<span class="string">&#x27;x&#x27;</span>)&#123;</span><br><span class="line">            l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">            x+=fx[op],y+=fy[op];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r&amp;&amp;dp[x][y]&gt;q[r].val+<span class="built_in">dis</span>(x,y,q[r].x,q[r].y)) --r;</span><br><span class="line">        q[++r]=<span class="built_in">Queue</span>(dp[x][y],x,y);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r&amp;&amp;(<span class="built_in">Abs</span>(x-q[l].x)&gt;len||<span class="built_in">Abs</span>(y-q[l].y)&gt;len)) ++l;</span><br><span class="line">        dp[x][y]=<span class="built_in">Max</span>(dp[x][y],q[l].val+<span class="built_in">dis</span>(x,y,q[l].x,q[l].y));</span><br><span class="line">        ans=<span class="built_in">Max</span>(ans,dp[x][y]);</span><br><span class="line">        x+=fx[op],y+=fy[op];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,sx,sy,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>,&amp;s[i][j]);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[sx][sy]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,s,t;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(s,t,op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">dfs</span>(n,j,t-s<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">dfs</span>(<span class="number">1</span>,j,t-s<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">dfs</span>(j,m,t-s<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">dfs</span>(j,<span class="number">1</span>,t-s<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>闲话：《海上钢琴师》真的非常好看！ ### <a
href="https://www.luogu.com.cn/problem/P2569">[SCOI2010] 股票交易</a> 设
<span class="math inline">\(dp_{i,j}\)</span> 表示 <span
class="math inline">\(i\)</span> 天结束时手上有 <span
class="math inline">\(j\)</span> 个股票时的最大收益。转移： -
什么也不做： <span class="math display">\[dp_{i,j}=dp_{i-1,j}\]</span> -
买入： <span class="math display">\[dp_{i,j}=\max(dp_{i-W-1,j-k}-k\times
AP_i)\]</span> - 卖出： <span
class="math display">\[dp_{i,j}=\max(dp_{i-W-1,j+k}+k\times
BP_i)\]</span></p>
第一个式子没有研究价值，我们看后两个。将式子转化，用 <span
class="math inline">\(k&#39;\)</span> 分别代替 <span
class="math inline">\(j-k\)</span> 和 <span
class="math inline">\(j+k\)</span>： <span
class="math display">\[dp_{i,j}=\max(dp_{i-W-1,k&#39;}+k&#39;\times
AP_i)-j\times AP_i\quad j-k&#39;\le AS_i\]</span> <span
class="math display">\[dp_{i,j}=\max(dp_{i-W-1,k&#39;}+k&#39;\times
BP_i)-j\times BP_i\quad k&#39;-j\le BS_i\]</span> 显然可以单调队列。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> t,maxp,w,l,r,ap[N],dp[N][N],bp[N],as[N],bs[N],ans; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ll k;</span><br><span class="line">    <span class="built_in">Queue</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">int</span> val,<span class="type">int</span> k):<span class="built_in">val</span>(val),<span class="built_in">k</span>(k)&#123;&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(t,maxp,w);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">read</span>(ap[i],bp[i],as[i],bs[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=as[i];j++) dp[i][j]=-ap[i]*j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=maxp;j++)</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pre=i-w<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre&lt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=maxp;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[r].val&lt;=dp[pre][j]+j*ap[i]) --r;</span><br><span class="line">            q[++r]=<span class="built_in">Queue</span>(dp[pre][j]+j*ap[i],j);</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;j-q[l].k&gt;as[i]) ++l;</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j],q[l].val-j*ap[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=maxp;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[r].val&lt;=dp[pre][j]+j*bp[i]) --r;</span><br><span class="line">            q[++r]=<span class="built_in">Queue</span>(dp[pre][j]+j*bp[i],j);</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l].k-j&gt;bs[i]) ++l;</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j],q[l].val-j*bp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=maxp;i++) ans=<span class="built_in">max</span>(ans,dp[t][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="玉蟾宫"><a
href="https://www.luogu.com.cn/problem/P4147">玉蟾宫</a></h3>
插一个单调栈典题。<br />
我们考虑枚举行数，对于一行内，维护每一列向上延伸最多的 <code>F</code>
数量（类似直方图）。例如，对于样例<br />
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">R F F F F F </span><br><span class="line">F F F F F F </span><br><span class="line">R R R F F F </span><br><span class="line">F F F F F F </span><br><span class="line">F F F F F F</span><br></pre></td></tr></table></figure> 假设我们枚举到最后一行，那么应该向上延伸最多的
<code>F</code> 数量应当是： <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">      F F F</span><br><span class="line">      F F F</span><br><span class="line">      F F F</span><br><span class="line">F F F F F F</span><br><span class="line">F F F F F F</span><br><span class="line">2 2 2 5 5 5</span><br></pre></td></tr></table></figure> 此时枚举列，同时对向上延伸最多
<code>F</code> 数量维护单调栈。<br />
时间复杂度 <span class="math inline">\(O(nm)\)</span>。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">    <span class="type">int</span> h,len;</span><br><span class="line">    <span class="built_in">Stack</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Stack</span>(<span class="type">int</span> h,<span class="type">int</span> len):<span class="built_in">h</span>(h),<span class="built_in">len</span>(len)&#123;&#125;</span><br><span class="line">&#125;st[N];</span><br><span class="line"><span class="type">int</span> n,m,top,h[N][N],ans;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            h[i][j]=(c==<span class="string">&#x27;F&#x27;</span>)?h[i<span class="number">-1</span>][j]<span class="number">+1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(top&amp;&amp;st[top].h&gt;h[i][j])&#123;</span><br><span class="line">                temp+=st[top].len;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,st[top].h*temp);</span><br><span class="line">                --top;</span><br><span class="line">            &#125;</span><br><span class="line">            st[++top]=<span class="built_in">Stack</span>(h[i][j],temp<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top)&#123;</span><br><span class="line">            temp+=st[top].len;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,st[top].h*temp);</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans*<span class="number">3</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="并查集">并查集</h2>
<h3 id="apio2008-免费道路"><a
href="https://www.luogu.com.cn/problem/P3623">[APIO2008]
免费道路</a></h3>
题意：一个边权为 <span class="math inline">\(0\)</span> 或 <span
class="math inline">\(1\)</span> 的图，求边权和为 <span
class="math inline">\(n-k\)</span> 的生成树。 首先 Kruskal
求最大生成树，求得必须要加入的 <span class="math inline">\(0\)</span>
边。 再 Kruskal 一遍，先将 <span class="math inline">\(0\)</span> 边加至
<span class="math inline">\(k\)</span> 条，然后一直加 <span
class="math inline">\(1\)</span> 边直到求出生成树。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e4</span><span class="number">+10</span>,M=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,fa[N],tot,cnt,ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v,w;&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">l</span><span class="params">(<span class="type">const</span> edge &amp;x,<span class="type">const</span> edge &amp;y)</span></span>&#123;<span class="keyword">return</span> x.w&lt;y.w;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">g</span><span class="params">(<span class="type">const</span> edge &amp;x,<span class="type">const</span> edge &amp;y)</span></span>&#123;<span class="keyword">return</span> x.w&gt;y.w;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">read</span>(e[i].u,e[i].v,e[i].w);</span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+m,g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">find</span>(e[i].u),v=<span class="built_in">find</span>(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        fa[u]=v;</span><br><span class="line">        ++tot;</span><br><span class="line">        <span class="keyword">if</span>(e[i].w==<span class="number">0</span>) ++cnt,e[i].w=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tot==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;k)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no solution\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+m,l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">find</span>(e[i].u),v=<span class="built_in">find</span>(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(e[i].w==<span class="number">-1</span>)&#123;</span><br><span class="line">            fa[u]=v;</span><br><span class="line">            e[i].w=<span class="number">0</span>;</span><br><span class="line">            ans[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot&lt;k&amp;&amp;e[i].w==<span class="number">0</span>)&#123;</span><br><span class="line">            fa[u]=v;</span><br><span class="line">            ans[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot&gt;=k&amp;&amp;e[i].w==<span class="number">1</span>)&#123;</span><br><span class="line">            fa[u]=v;</span><br><span class="line">            ans[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot!=n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no solution\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=ans[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,e[j].u,e[j].v,e[j].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ahoi2013-连通图"><a
href="https://www.luogu.com.cn/problem/P5227">[AHOI2013] 连通图</a></h3>
线段树分治+可撤销并查集。 在时间轴上开线段树，每个节点维护
<code>std::vector</code>
表示当前区间需要加的边，使用可撤销并查集在回溯时撤销当前节点添加的边。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>,M=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,fa[N],siz[N],k,last[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="built_in">Edge</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> u,<span class="type">int</span> v):<span class="built_in">u</span>(u),<span class="built_in">v</span>(v)&#123;&#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line">vector&lt;Edge&gt; tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,Edge t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">        tree[u].<span class="built_in">push_back</span>(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(ls,l,mid,x,y,t);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line">stack&lt;Edge&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(siz[x]&gt;siz[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    fa[x]=y;</span><br><span class="line">    siz[y]+=siz[x];</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="built_in">Edge</span>(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_ans</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=st.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(Edge x:tree[u]) <span class="built_in">merge</span>(x.u,x.v);</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(siz[<span class="built_in">find</span>(<span class="number">1</span>)]==n) <span class="built_in">printf</span>(<span class="string">&quot;Connected\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Disconnected\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">get_ans</span>(ls,l,mid);</span><br><span class="line">        <span class="built_in">get_ans</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((<span class="type">int</span>)st.<span class="built_in">size</span>()&gt;temp)&#123;</span><br><span class="line">        Edge x=st.<span class="built_in">top</span>();</span><br><span class="line">        <span class="type">int</span> u=x.u,v=x.v;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        siz[v]-=siz[u];</span><br><span class="line">        fa[u]=u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(edge[i].u,edge[i].v);</span><br><span class="line">    <span class="built_in">read</span>(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,c,x;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(c);</span><br><span class="line">        <span class="keyword">while</span>(c--)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            <span class="keyword">if</span>(last[x]<span class="number">+1</span>&lt;=i<span class="number">-1</span>) <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,k,last[x]<span class="number">+1</span>,i<span class="number">-1</span>,edge[x]);</span><br><span class="line">            last[x]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,k,last[i]<span class="number">+1</span>,k,edge[i]);</span><br><span class="line">    <span class="built_in">get_ans</span>(<span class="number">1</span>,<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day2">Day2</h1>
<h2 id="trie">Trie</h2>
<h3 id="jsoi2009-电子字典"><a
href="https://www.luogu.com.cn/problem/P4407">[JSOI2009]
电子字典</a></h3>
<p>Trie 题怎么能用 Trie 做呢？<br />
由于串长极小，直接字符串哈希，实现时需要注意以下几个点： -
使用自然溢出哈希； - 记得去重，去重一定不要用 <code>std::set</code>，会
T 飞。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/pb_ds/hash_policy.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ull base[<span class="number">25</span>],h[<span class="number">25</span>];</span><br><span class="line">gp_hash_table&lt;ull,<span class="type">int</span>&gt; word;</span><br><span class="line"><span class="type">char</span> s[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    base[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">22</span>;i++) base[i]=base[i<span class="number">-1</span>]*<span class="number">131</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s));</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s<span class="number">+1</span>);</span><br><span class="line">        h[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len=<span class="built_in">strlen</span>(s<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">            h[i]=h[i<span class="number">-1</span>]*<span class="number">131</span>+s[i];</span><br><span class="line">        word[h[len]]=m<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s));</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">        h[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s<span class="number">+1</span>);</span><br><span class="line">        <span class="type">int</span> len=<span class="built_in">strlen</span>(s<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">            h[i]=h[i<span class="number">-1</span>]*<span class="number">131</span>+s[i];</span><br><span class="line">        <span class="keyword">if</span>(word.<span class="built_in">find</span>(h[len])!=word.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            ull hash1=h[i<span class="number">-1</span>]*base[len-i]+(h[len]-h[i]*base[len-i]);</span><br><span class="line">            <span class="keyword">auto</span> it=word.<span class="built_in">find</span>(hash1);</span><br><span class="line">            <span class="keyword">if</span>(it!=word.<span class="built_in">end</span>()&amp;&amp;it-&gt;second!=m)</span><br><span class="line">                it-&gt;second=m,++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> j=<span class="string">&#x27;a&#x27;</span>;j&lt;=<span class="string">&#x27;z&#x27;</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==s[i]) <span class="keyword">continue</span>;</span><br><span class="line">                ull hash1=h[len]-s[i]*base[len-i]+j*base[len-i];</span><br><span class="line">                <span class="keyword">auto</span> it=word.<span class="built_in">find</span>(hash1);</span><br><span class="line">                <span class="keyword">if</span>(it!=word.<span class="built_in">end</span>()&amp;&amp;it-&gt;second!=m)</span><br><span class="line">                    it-&gt;second=m,++res;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> j=<span class="string">&#x27;a&#x27;</span>;j&lt;=<span class="string">&#x27;z&#x27;</span>;j++)&#123;</span><br><span class="line">                ull hash1=h[i]*base[len-i<span class="number">+1</span>]+j*base[len-i]+(h[len]-h[i]*base[len-i]);</span><br><span class="line">                <span class="keyword">auto</span> it=word.<span class="built_in">find</span>(hash1);</span><br><span class="line">                <span class="keyword">if</span>(it!=word.<span class="built_in">end</span>()&amp;&amp;it-&gt;second!=m)</span><br><span class="line">                    it-&gt;second=m,++res;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="usaco12dec-first-g"><a
href="https://www.luogu.com.cn/problem/P3065">[USACO12DEC] First!
G</a></h3>
建 Trie，在 Trie 上查找时对字母连边，拓扑排序判环。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">3e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,nxt[N][<span class="number">26</span>],tot,e[<span class="number">26</span>][<span class="number">26</span>],indegree[<span class="number">26</span>],cnt,ans[N];</span><br><span class="line"><span class="type">bool</span> ed[N];</span><br><span class="line">string s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="type">int</span> k=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[p][k]) nxt[p][k]=++tot;</span><br><span class="line">        p=nxt[p][k];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[p]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="built_in">sizeof</span>(e));</span><br><span class="line">    <span class="built_in">memset</span>(indegree,<span class="number">0</span>,<span class="built_in">sizeof</span>(indegree));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ed[p]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> k=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(k!=i&amp;&amp;nxt[p][i]&amp;&amp;!e[k][i])&#123;</span><br><span class="line">                e[k][i]=<span class="number">1</span>;</span><br><span class="line">                ++indegree[i];</span><br><span class="line">            &#125;</span><br><span class="line">        p=nxt[p][k];</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(!indegree[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;<span class="number">26</span>;v++)</span><br><span class="line">            <span class="keyword">if</span>(e[u][v]&amp;&amp;!--indegree[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(indegree[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="built_in">insert</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(s[i]))</span><br><span class="line">            ans[++cnt]=i;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        cout&lt;&lt;s[ans[i]]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ioi-2008-type-printer"><a
href="https://www.luogu.com.cn/problem/P4683">[IOI 2008] Type
Printer</a></h3>
显然先建出 Trie，考虑怎样的遍历顺序更优。<br />
发现这不是<a
href="https://www.luogu.com.cn/problem/P3698">老熟人</a>吗？
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">25010</span>;</span><br><span class="line"><span class="type">int</span> n,nxt[N*<span class="number">20</span>][<span class="number">26</span>],tot;</span><br><span class="line"><span class="type">bool</span> ed[N*<span class="number">20</span>],flag[N*<span class="number">20</span>],f;</span><br><span class="line">string maxlen,ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="type">int</span> k=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[p][k]) nxt[p][k]=++tot;</span><br><span class="line">        p=nxt[p][k];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[p]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="type">int</span> k=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        p=nxt[p][k];</span><br><span class="line">        flag[p]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ed[u]) ans.<span class="built_in">push_back</span>(<span class="string">&#x27;P&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> maxk=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> v=nxt[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag[v]) maxk=i;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(~maxk)&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(maxk+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(nxt[u][maxk]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag[u]&amp;&amp;!~maxk)&#123;</span><br><span class="line">        cout&lt;&lt;ans.<span class="built_in">length</span>()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:ans)</span><br><span class="line">            cout&lt;&lt;c&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()&gt;maxlen.<span class="built_in">length</span>()) maxlen=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">query</span>(maxlen);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="笛卡尔树">笛卡尔树</h2>
<h3 id="tjoi2011-树的序"><a
href="https://www.luogu.com.cn/problem/P1377">[TJOI2011] 树的序</a></h3>
考虑 BST 每个节点记录权值 <span class="math inline">\(k\)</span>
和插入的时间 <span class="math inline">\(t\)</span>，则 <span
class="math inline">\(k\)</span> 满足 BST 的性质，<span
class="math inline">\(t\)</span> 满足小根堆的性质，这样构建的 BST 是一棵
Treap。<br />
题意转化为：重新分配 <span
class="math inline">\(t\)</span>，使得生成序列最小。<br />
既然 <span class="math inline">\(t\)</span>
维度是小根堆，那么满足父亲小于后代。贪心地想，较小的 <span
class="math inline">\(t\)</span> 分配顺序为：父亲 <span
class="math inline">\(&gt;\)</span> 左子树 <span
class="math inline">\(&gt;\)</span> 右子树，也就是 BST 的前序遍历。
笛卡尔树同样满足 Treap 的性质。它的 <span
class="math inline">\(k\)</span> 与 <span
class="math inline">\(t\)</span> 正好与本题的 BST 相反。则我们只需交换
<span class="math inline">\(k\)</span> 和 <span
class="math inline">\(t\)</span> 并 <span
class="math inline">\(O(n)\)</span> 构建笛卡尔树即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],st[N],top,son[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,u);</span><br><span class="line">    <span class="keyword">if</span>(son[u][<span class="number">0</span>]) <span class="built_in">dfs</span>(son[u][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(son[u][<span class="number">1</span>]) <span class="built_in">dfs</span>(son[u][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++) <span class="built_in">read</span>(x),a[x]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> last=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;a[st[top]]&gt;a[i]) last=st[top--];</span><br><span class="line">        <span class="keyword">if</span>(top) son[st[top]][<span class="number">1</span>]=i;</span><br><span class="line">        son[i][<span class="number">0</span>]=last;</span><br><span class="line">        st[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        vis[son[i][<span class="number">0</span>]]=vis[son[i][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="数据结构">数据结构</h2>
<h3 id="最大异或和"><a
href="https://www.luogu.com.cn/problem/P4735">最大异或和</a></h3>
可持久化 01 trie 模板题。<br />
操作与主席树类似，对于查询，设我们已经维护了所有的前缀异或和 <span
class="math inline">\(sum_i=\oplus_{j=1}^ia_j\)</span>，则只需最大化
<span class="math inline">\(sum_{p-1}\oplus sum_n\oplus
x\)</span>。后两项是给定的，则我们只需贪心求出答案即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::max;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">6e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,nxt[N*<span class="number">25</span>][<span class="number">2</span>],siz[N*<span class="number">25</span>],tot,root[N],sum;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> old,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    root[u]=++tot;</span><br><span class="line">    <span class="type">int</span> p=root[u],q=root[old];</span><br><span class="line">    siz[p]=siz[q]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">24</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        nxt[p][<span class="number">0</span>]=nxt[q][<span class="number">0</span>],nxt[p][<span class="number">1</span>]=nxt[q][<span class="number">1</span>];</span><br><span class="line">        nxt[p][c]=++tot;</span><br><span class="line">        p=nxt[p][c],q=nxt[q][c];</span><br><span class="line">        siz[p]=siz[q]<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=root[a],q=root[b],res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">24</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(siz[nxt[q][c^<span class="number">1</span>]]&gt;siz[nxt[p][c^<span class="number">1</span>]])&#123;</span><br><span class="line">            res|=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">            p=nxt[p][c^<span class="number">1</span>];</span><br><span class="line">            q=nxt[q][c^<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p=nxt[p][c];</span><br><span class="line">            q=nxt[q][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a);</span><br><span class="line">        <span class="built_in">insert</span>(i,i<span class="number">-1</span>,sum^=a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> x,l,r;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        op=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(op!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;op!=<span class="string">&#x27;Q&#x27;</span>) op=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            ++n;</span><br><span class="line">            <span class="built_in">insert</span>(n,n<span class="number">-1</span>,sum^=x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">read</span>(l,r,x);</span><br><span class="line">            <span class="type">int</span> ans;</span><br><span class="line">            <span class="keyword">if</span>(l==<span class="number">1</span>) ans=<span class="built_in">max</span>(<span class="built_in">query</span>(sum^x,<span class="number">0</span>,r<span class="number">-1</span>),sum^x);</span><br><span class="line">            <span class="keyword">else</span> ans=<span class="built_in">query</span>(sum^x,l<span class="number">-2</span>,r<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="十二省联考-2019-异或粽子"><a
href="https://www.luogu.com.cn/problem/P5283">[十二省联考 2019]
异或粽子</a></h3>
类似<a href="https://www.luogu.com.cn/problem/P2048">[NOI2010]
超级钢琴</a>的贪心，由于 <span class="math inline">\(a_i\oplus
a_j=a_j\oplus a_i\)</span>，只需使用堆查询最大的 <span
class="math inline">\(2k\)</span> 个，再令答案除以 <span
class="math inline">\(2\)</span>。可以用 Trie 查询全局第 <span
class="math inline">\(k\)</span> 大，方法类似线段树上二分。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,k,nxt[N&lt;&lt;<span class="number">5</span>][<span class="number">2</span>],siz[N&lt;&lt;<span class="number">5</span>],tot=<span class="number">1</span>;</span><br><span class="line">ll a[N],ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">    ++siz[p];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">32</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[p][c]) nxt[p][c]=++tot;</span><br><span class="line">        p=nxt[p][c];</span><br><span class="line">        ++siz[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x,<span class="type">int</span> rnk)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">32</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(siz[nxt[p][c]]&gt;=rnk) p=nxt[p][c];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rnk-=siz[nxt[p][c]];</span><br><span class="line">            p=nxt[p][c^<span class="number">1</span>];</span><br><span class="line">            res|=<span class="number">1ll</span>&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id,rnk;</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> id,<span class="type">int</span> rnk,ll val):<span class="built_in">id</span>(id),<span class="built_in">rnk</span>(rnk),<span class="built_in">val</span>(val)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> val&lt;x.val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        a[i]^=a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">node</span>(i,n<span class="number">+1</span>,<span class="built_in">query</span>(a[i],n<span class="number">+1</span>)));</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        node u=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=u.val;</span><br><span class="line">        <span class="keyword">if</span>(u.rnk) q.<span class="built_in">push</span>(<span class="built_in">node</span>(u.id,u.rnk<span class="number">-1</span>,<span class="built_in">query</span>(a[u.id],u.rnk<span class="number">-1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day3">Day3</h1>
<h2 id="字符串哈希">字符串哈希</h2>
<h3 id="poi-2006-pal-palindromes"><a
href="https://www.luogu.com.cn/problem/P3449">[POI 2006]
PAL-Palindromes</a></h3>
容易发现，两个回文串 <span class="math inline">\(A\)</span>，<span
class="math inline">\(B\)</span> 组合成新回文串当且仅当 <span
class="math inline">\(AB\)</span> 等于 <span
class="math inline">\(BA\)</span>。设 <span
class="math inline">\(A\)</span> 的哈希值为 <span
class="math inline">\(a\)</span>，<span class="math inline">\(B\)</span>
的哈希值为 <span class="math inline">\(b\)</span>，有 <span
class="math display">\[a\times base^{|B|}+b=b\times
base^{|A|}+a\]</span> 简单移项 <span
class="math display">\[\frac{a}{base^{|A|}-1}=\frac{b}{base^{|B|}-1}\]</span>
开哈希桶维护即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/pb_ds/hash_policy.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod1=<span class="number">998244353</span>,mod2=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    a%=p;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair_hash</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;x)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="type">size_t</span> seed=<span class="number">0</span>;</span><br><span class="line">        seed^=hash&lt;<span class="type">int</span>&gt;&#123;&#125;(x.first)<span class="number">+0x9e3779b9</span>+(seed&lt;&lt;<span class="number">6</span>)+(seed&gt;&gt;<span class="number">2</span>);</span><br><span class="line">        seed^=hash&lt;<span class="type">int</span>&gt;&#123;&#125;(x.second)<span class="number">+0x9e3779b9</span>+(seed&lt;&lt;<span class="number">6</span>)+(seed&gt;&gt;<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> seed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">gp_hash_table&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>,pair_hash&gt; cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,temp;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;temp&gt;&gt;s;</span><br><span class="line">        ll h1=<span class="number">0</span>,h2=<span class="number">0</span>,base1=<span class="number">1</span>,base2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            h1=(h1*<span class="number">131</span>+c)%mod1;</span><br><span class="line">            base1=base1*<span class="number">131</span>%mod1;</span><br><span class="line">            h2=(h2*<span class="number">131</span>+c)%mod2;</span><br><span class="line">            base2=base2*<span class="number">131</span>%mod2;</span><br><span class="line">        &#125;</span><br><span class="line">        ll x=h1*<span class="built_in">qpow</span>(base1<span class="number">-1</span>,mod1<span class="number">-2</span>,mod1)%mod1;</span><br><span class="line">        ll y=h2*<span class="built_in">qpow</span>(base2<span class="number">-1</span>,mod2<span class="number">-2</span>,mod2)%mod2;</span><br><span class="line">        ans+=cnt[<span class="built_in">make_pair</span>(x,y)];</span><br><span class="line">        ++cnt[<span class="built_in">make_pair</span>(x,y)];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans*<span class="number">2</span>+n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="poi-2012-okr-a-horrible-poem"><a
href="https://www.luogu.com.cn/problem/P3538">[POI 2012] OKR-A Horrible
Poem</a></h3>
<span class="math inline">\(A\)</span> 的一个子串 <span
class="math inline">\(B\)</span> 能成为 <span
class="math inline">\(A\)</span> 的一个完整周期，当且仅当其长度为 <span
class="math inline">\(A\)</span>
长度的因数。直接枚举因数。判断是否是完整周期的方法：设 <span
class="math inline">\(h_{l,r}\)</span> 表示 <span
class="math inline">\([l,r]\)</span> 的哈希值，则当一个长为 <span
class="math inline">\(len\)</span> 的子串满足 <span
class="math inline">\(h_{l,r-len}=h_{l+len,r}\)</span>
时，其为一个完整周期。先跑一遍线性筛降低枚举因数的时间复杂度。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,q,e[N],p[N],tot;</span><br><span class="line">ull h[N],base[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function">ull <span class="title">gethash</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*base[r-l<span class="number">+1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %s %d&quot;</span>,&amp;n,s<span class="number">+1</span>,&amp;q);</span><br><span class="line">    base[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        base[i]=base[i<span class="number">-1</span>]*<span class="number">131</span>;</span><br><span class="line">        h[i]=h[i<span class="number">-1</span>]*<span class="number">131</span>+s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!e[i]) p[e[i]=++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=e[i]&amp;&amp;p[j]&lt;=n/i;j++)</span><br><span class="line">            e[p[j]*i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a,b,len,ans;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        len=ans=b-a<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> prime=p[e[len]];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">gethash</span>(a+ans/prime,b)==<span class="built_in">gethash</span>(a,b-ans/prime))</span><br><span class="line">                ans/=prime;</span><br><span class="line">            len/=prime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ontak2015-tasowanie"><a
href="https://www.luogu.com.cn/problem/P8023">[ONTAK2015]
Tasowanie</a></h3>
双指针+二分+哈希。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],b[N],len,p1,p2;</span><br><span class="line">ull h1[N],h2[N],base[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">gethash1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> h1[r]-h1[l<span class="number">-1</span>]*base[r-l<span class="number">+1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">gethash2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> h2[r]-h2[l<span class="number">-1</span>]*base[r-l<span class="number">+1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">gethash1</span>(p1,p1+x<span class="number">-1</span>)==<span class="built_in">gethash2</span>(p2,p2+x<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(b[i]);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">+1</span>;i&lt;=m;i++) a[i]=<span class="number">1e3</span><span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">+1</span>;i&lt;=n;i++) b[i]=<span class="number">1e3</span><span class="number">+1</span>;</span><br><span class="line">    base[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    len=<span class="built_in">max</span>(n,m);</span><br><span class="line">    a[len<span class="number">+1</span>]=b[len<span class="number">+1</span>]=<span class="number">1e3</span><span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++) base[i]=base[i<span class="number">-1</span>]*<span class="number">13331</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        h1[i]=h1[i<span class="number">-1</span>]*<span class="number">13331</span>+a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        h2[i]=h2[i<span class="number">-1</span>]*<span class="number">13331</span>+b[i];</span><br><span class="line">    p1=<span class="number">1</span>,p2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[p1]&lt;b[p2]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[p1++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[p1]&gt;b[p2]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[p2++]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=<span class="built_in">min</span>(len-p1<span class="number">+1</span>,len-p2<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[p1+r]&lt;b[p2+r]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[p1++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[p2++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="kmp">KMP</h2>
<h3 id="hnoi2008-gt考试"><a
href="https://www.luogu.com.cn/problem/P3193">[HNOI2008] GT考试</a></h3>
设 <span class="math inline">\(f_{i,j}\)</span> 表示长串匹配前 <span
class="math inline">\(i\)</span> 个字符，短串匹配前 <span
class="math inline">\(j\)</span> 个字符的方案数。答案为： <span
class="math display">\[ans=\sum_{i=0}^{m-1} f_{n,i}\]</span> 设 <span
class="math inline">\(g_{i,j}\)</span> 表示匹配到第 <span
class="math inline">\(i\)</span> 位时加入一个数字后匹配到第 <span
class="math inline">\(j\)</span> 位的方案数，可以用 KMP 求出。 <span
class="math display">\[f_{i,j}=\sum_{k=0}^{m-1}f_{i-1,k}\times
g_{k,j}\]</span> 注意到这是矩阵乘法的形式，矩阵快速幂 <span
class="math inline">\(O(m^3\log n)\)</span>。<br />
在转化成矩阵的过程中，<span class="math inline">\(f_{i,j}\)</span>
被转化为一个一行 <span class="math inline">\(m-1\)</span> 列的矩阵。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="type">int</span> n,m,mod,nxt[<span class="number">25</span>],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        Matrix res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                    res.a[i][j]=(res.a[i][j]+a[i][k]*x.a[k][j]%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;base,f,g;</span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    Matrix res=base;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) base.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s<span class="number">+1</span>);</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[j<span class="number">+1</span>]!=s[i]) j=nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(s[j<span class="number">+1</span>]==s[i]) j++;</span><br><span class="line">        nxt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c=<span class="string">&#x27;0&#x27;</span>;c&lt;=<span class="string">&#x27;9&#x27;</span>;c++)&#123;</span><br><span class="line">            j=i;</span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;s[j<span class="number">+1</span>]!=c) j=nxt[j];</span><br><span class="line">            <span class="keyword">if</span>(s[j<span class="number">+1</span>]==c) j++;</span><br><span class="line">            g.a[i][j]=(g.a[i][j]<span class="number">+1</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    f.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    f=f*<span class="built_in">qpow</span>(g,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) ans=(ans+f.a[<span class="number">0</span>][i])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="manacher">Manacher</h2>
感觉自己没理解 Manacher 啊，改天<a
href="https://headless-piston.github.io/2025/07/05/Manacher/">重学一次</a>。
### <a href="https://www.luogu.com.cn/problem/P1659">[国家集训队]
拉拉队排练</a> 由于只需要找长度为奇数的回文串，无需在字符间插入
<code>#</code>，直接跑 Manacher，开差分数组 <span
class="math inline">\(sum\)</span>，表示当前长度的回文串数量。当位置
<span class="math inline">\(i\)</span> 的最长回文半径为 <span
class="math inline">\(p_i\)</span> 时，容易想到半径长度小于等于 <span
class="math inline">\(p_i\)</span> 的都是回文串，则我们只需在差分数组
<span class="math inline">\(sum_1\)</span> 处加 <span
class="math inline">\(1\)</span>，<span
class="math inline">\(sum_{p_i\times 2}\)</span> 处减 <span
class="math inline">\(1\)</span> 就行了。最后统计答案时要用快速幂。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>,mod=<span class="number">19930726</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    a%=mod;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,p[N];</span><br><span class="line">ll k,sum[N],ans;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s<span class="number">+1</span>);</span><br><span class="line">    s[<span class="number">0</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,r=<span class="number">0</span>,mid=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r) p[i]=<span class="built_in">min</span>(p[mid*<span class="number">2</span>-i],r-i<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">while</span>(s[i-p[i]]==s[i+p[i]]) ++p[i];</span><br><span class="line">        <span class="keyword">if</span>(p[i]+i&gt;r) r=p[i]+i<span class="number">-1</span>,mid=i;</span><br><span class="line">        ++sum[<span class="number">1</span>],--sum[p[i]*<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> tot=n;</span><br><span class="line">    ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tot%<span class="number">2</span>==<span class="number">0</span>) --tot;</span><br><span class="line">    <span class="keyword">while</span>(k&amp;&amp;tot&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ans=ans*<span class="built_in">qpow</span>(tot,<span class="built_in">min</span>(sum[tot],k))%mod;</span><br><span class="line">        k=<span class="built_in">max</span>(k-sum[tot],<span class="number">0ll</span>);</span><br><span class="line">        tot-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="国家集训队-最长双回文串"><a
href="https://www.luogu.com.cn/problem/P4555">[国家集训队]
最长双回文串</a></h3>
在跑 Manacher 同时维护以每个点开头和结尾的最长回文串长度。仅 Manacher
求解的答案不完全，需要再递推地扫一遍，最后枚举中点即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">char</span> t[N],s[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> len0,len,p[N&lt;&lt;<span class="number">1</span>],a[N&lt;&lt;<span class="number">1</span>],b[N&lt;&lt;<span class="number">1</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t<span class="number">+1</span>);</span><br><span class="line">    len0=<span class="built_in">strlen</span>(t<span class="number">+1</span>);</span><br><span class="line">    s[<span class="number">0</span>]=s[<span class="number">1</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len0;i++)&#123;</span><br><span class="line">        s[++len]=t[i];</span><br><span class="line">        s[++len]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,r=<span class="number">0</span>,mid=<span class="number">0</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">2</span>*mid-i;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r) p[i]=<span class="built_in">min</span>(r-i<span class="number">+1</span>,p[j]);</span><br><span class="line">        <span class="keyword">else</span> p[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i-p[i]]==s[i+p[i]]) ++p[i];</span><br><span class="line">        <span class="keyword">if</span>(i+p[i]<span class="number">-1</span>&gt;r)&#123;</span><br><span class="line">            r=i+p[i]<span class="number">-1</span>;</span><br><span class="line">            mid=i;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i+p[i]<span class="number">-1</span>]=<span class="built_in">max</span>(a[i+p[i]<span class="number">-1</span>],p[i]<span class="number">-1</span>);</span><br><span class="line">        b[i-p[i]<span class="number">+1</span>]=<span class="built_in">max</span>(b[i-p[i]<span class="number">+1</span>],p[i]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">1</span>;i-=<span class="number">2</span>) a[i]=<span class="built_in">max</span>(a[i],a[i<span class="number">+2</span>]<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i+=<span class="number">2</span>) b[i]=<span class="built_in">max</span>(b[i],b[i<span class="number">-2</span>]<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i+=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&amp;&amp;b[i]) ans=<span class="built_in">max</span>(ans,a[i]+b[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day4">Day4</h1>
<h2 id="搜索">搜索</h2>
搜索题真是无聊死了，就少放几道吧…… ### <a
href="https://www.luogu.com.cn/problem/P8817">[CSP-S 2022] 假期计划</a>
<span class="math inline">\(n\)</span> 遍 BFS
求全源最短路，之后考虑枚举。将 <span class="math inline">\(5\)</span>
个点记作 <span class="math inline">\(1,2,3,4,5\)</span>，则枚举 <span
class="math inline">\(3,4\)</span> 点，判断 <span
class="math inline">\(2,5\)</span>
是否与已选的点重复。可以预处理出每个能同时到达 <span
class="math inline">\(1\)</span>
点和另一个点的前三大点，因为它最多只有可能与 <span
class="math inline">\(3,4\)</span> 中的一个和 <span
class="math inline">\(2,5\)</span> 中的一个重合。总体时间复杂度 <span
class="math inline">\(O(nm+n^2)\)</span>。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2510</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,dis[N][N];</span><br><span class="line">ll ans,val[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> id):<span class="built_in">id</span>(id)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val[id]!=val[x.id]?val[id]&lt;val[x.id]:id&lt;x.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;node&gt; st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);++k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) <span class="built_in">read</span>(val[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i][i]=<span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:e[u])</span><br><span class="line">                <span class="keyword">if</span>(dis[i][u]<span class="number">+1</span>&lt;dis[i][v]&amp;&amp;dis[i][u]<span class="number">+1</span>&lt;=k)&#123;</span><br><span class="line">                    dis[i][v]=dis[i][u]<span class="number">+1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[i][j]&lt;=k&amp;&amp;dis[<span class="number">1</span>][j]&lt;=k)</span><br><span class="line">                st[i].<span class="built_in">insert</span>(<span class="built_in">node</span>(j));</span><br><span class="line">            <span class="keyword">if</span>(st[i].<span class="built_in">size</span>()&gt;<span class="number">3</span>) st[i].<span class="built_in">erase</span>(st[i].<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">2</span>;b&lt;=n;b++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">2</span>;c&lt;=n;c++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b==c||dis[b][c]&gt;k) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> temp1:st[b])&#123;</span><br><span class="line">                <span class="type">int</span> a=temp<span class="number">1.</span>id;</span><br><span class="line">                <span class="keyword">if</span>(a==b||a==c) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> temp2:st[c])&#123;</span><br><span class="line">                    <span class="type">int</span> d=temp<span class="number">2.</span>id;</span><br><span class="line">                    <span class="keyword">if</span>(d==b||d==c||a==d) <span class="keyword">continue</span>;</span><br><span class="line">                    ans=<span class="built_in">max</span>(ans,val[a]+val[b]+val[c]+val[d]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="ahoi2012-铁盘整理"><a
href="https://www.luogu.com.cn/problem/P2534">[AHOI2012]
铁盘整理</a></h3>
IDA* 板题。先离散化，估价函数为相邻差不为 <span
class="math inline">\(1\)</span> 的个数。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],b[N],lim;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res+=(<span class="built_in">abs</span>(a[i<span class="number">+1</span>]-a[i])!=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> pre)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="built_in">h</span>();</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt+temp&gt;lim) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==pre) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+i);</span><br><span class="line">        f|=<span class="built_in">dfs</span>(cnt<span class="number">+1</span>,i);</span><br><span class="line">        <span class="built_in">reverse</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),b[i]=a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+n,a[i])-b;</span><br><span class="line">    a[n<span class="number">+1</span>]=n<span class="number">+1</span>;</span><br><span class="line">    lim=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lim);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++lim;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="prime-gift"><a
href="https://codeforces.com/problemset/problem/912/E">Prime
Gift</a></h3>
容易发现，<span class="math inline">\(p_i\)</span>
越小，方案数越多。<span class="math inline">\(n=16\)</span>
时不可接受，考虑 Meet in the middle。最坏情况下前 <span
class="math inline">\(8\)</span> 个质数 <span
class="math inline">\(2,3,5,7,11,13,17,19\)</span>，在 <span
class="math inline">\(10^{18}\)</span> 内能组成 <span
class="math inline">\(7039193\)</span>
种数字。实际实现时可以将数的分配得更加均匀以降低复杂度。之后二分答案+双指针求解即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> ll lim=<span class="number">1e18</span>,N=<span class="number">7039192</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,p[<span class="number">20</span>],k,tota,totb;</span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,ll num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(x<span class="number">+2</span>,num);</span><br><span class="line">    <span class="keyword">for</span>(ll i=p[x];;i*=p[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(lim/i&lt;num) <span class="keyword">break</span>;</span><br><span class="line">        a[++tota]=num*i;</span><br><span class="line">        <span class="built_in">dfs1</span>(x<span class="number">+2</span>,num*i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,ll num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(x<span class="number">+2</span>,num);</span><br><span class="line">    <span class="keyword">for</span>(ll i=p[x];;i*=p[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(lim/i&lt;num) <span class="keyword">break</span>;</span><br><span class="line">        b[++totb]=num*i;</span><br><span class="line">        <span class="built_in">dfs2</span>(x<span class="number">+2</span>,num*i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=totb;i&lt;=tota;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;x/a[i]&lt;b[j]) --j;</span><br><span class="line">        cnt+=j;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(p[i]);</span><br><span class="line">    <span class="built_in">sort</span>(p<span class="number">+1</span>,p<span class="number">+1</span>+n);</span><br><span class="line">    a[++tota]=b[++totb]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+tota);</span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+totb);</span><br><span class="line">    <span class="built_in">read</span>(k);</span><br><span class="line">    ll l=<span class="number">1</span>,r=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="usaco09nov-lights-g"><a
href="https://www.luogu.com.cn/problem/P2962">[USACO09NOV] Lights
G</a></h3>
Meet in the middle，开一个 <code>std::map</code>
记录状态对应的最小操作次数，按照补集相加。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">40</span>;</span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line">ll a[N];</span><br><span class="line">map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=<span class="number">1ll</span>&lt;&lt;i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        --u,--v;</span><br><span class="line">        a[u]|=<span class="number">1ll</span>&lt;&lt;v;</span><br><span class="line">        a[v]|=<span class="number">1ll</span>&lt;&lt;u;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=n<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n&gt;&gt;<span class="number">1</span>));i++)&#123;</span><br><span class="line">        ll temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(n&gt;&gt;<span class="number">1</span>);j++)</span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)</span><br><span class="line">                temp^=a[j];</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(temp)) mp[temp]=__builtin_popcount(i);</span><br><span class="line">        <span class="keyword">else</span> mp[temp]=<span class="built_in">min</span>(mp[temp],__builtin_popcount(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n-(n&gt;&gt;<span class="number">1</span>)));i++)&#123;</span><br><span class="line">        ll temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-(n&gt;&gt;<span class="number">1</span>);j++)</span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)</span><br><span class="line">                temp^=a[(n&gt;&gt;<span class="number">1</span>)+j];</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(((<span class="number">1ll</span>&lt;&lt;n)<span class="number">-1</span>)^temp))</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,__builtin_popcount(i)+mp[((<span class="number">1ll</span>&lt;&lt;n)<span class="number">-1</span>)^temp]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="机关"><a
href="https://www.luogu.com.cn/problem/P5507">机关</a></h3>
<del>坏题。</del><br />
考虑 A*。容易想到 <span class="math inline">\(4\)</span>
进制状压，则状态 <span class="math inline">\(x\)</span> 的估价 <span
class="math inline">\(h(x)\)</span> 应为当前已经旋转的次数与所有不为
<span class="math inline">\(1\)</span> 的旋钮旋到 <span
class="math inline">\(1\)</span> 所需总步数除以 <span
class="math inline">\(2\)</span>
的和。因为最好情况是旋一个按钮时另一个正好也到了 <span
class="math inline">\(1\)</span>。每个状态记录一个 <span
class="math inline">\(pre\)</span>
表示是从哪个状态转移过来的以输出方案。<br />

<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">24</span>)<span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> st,a[<span class="number">15</span>][<span class="number">4</span>],b[N],pre[N],step[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==st) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">write</span>(pre[x]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">h</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp=(x&gt;&gt;(i&lt;&lt;<span class="number">1</span>))&amp;<span class="number">3</span>;</span><br><span class="line">        res+=temp?<span class="number">4</span>-temp:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,h;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> x,<span class="type">int</span> h):<span class="built_in">x</span>(x),<span class="built_in">h</span>(h)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a)<span class="type">const</span>&#123;<span class="keyword">return</span> h&gt;a.h;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,x;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        st|=(x<span class="number">-1</span>)&lt;&lt;(i&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">            <span class="built_in">read</span>(a[i][j]),--a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(st,<span class="built_in">h</span>(st)));</span><br><span class="line">    vis[st]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().x;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> pos1=i&lt;&lt;<span class="number">1</span>,temp1=(x&gt;&gt;pos1)&amp;<span class="number">3</span>,j=a[i][temp1];</span><br><span class="line">            <span class="type">int</span> pos2=j&lt;&lt;<span class="number">1</span>,temp2=(x&gt;&gt;pos2)&amp;<span class="number">3</span>,res=x;</span><br><span class="line">            res&amp;=~(<span class="number">3</span>&lt;&lt;pos1);</span><br><span class="line">            res&amp;=~(<span class="number">3</span>&lt;&lt;pos2);</span><br><span class="line">            res|=((temp1<span class="number">+1</span>)&amp;<span class="number">3</span>)&lt;&lt;pos1;</span><br><span class="line">            res|=((temp2<span class="number">+1</span>)&amp;<span class="number">3</span>)&lt;&lt;pos2;</span><br><span class="line">            <span class="keyword">if</span>(!vis[res])&#123;</span><br><span class="line">                vis[res]=<span class="number">1</span>;</span><br><span class="line">                step[res]=step[x]<span class="number">+1</span>;</span><br><span class="line">                pre[res]=x,b[res]=i<span class="number">+1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">node</span>(res,step[res]+<span class="built_in">h</span>(res)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,step[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day5">Day5</h1>
<h2 id="最小生成树">最小生成树</h2>
<h3 id="noip-2013-提高组-货车运输"><a
href="https://www.luogu.com.cn/problem/P1967">[NOIP 2013 提高组]
货车运输</a></h3>
最优情况一定是走最大生成树上的边，所以先 Kruskal
求最大生成树，接下来求树上两点间路径权值最小值，可以边权下放点权上树剖+线段树或倍增。另外，图不保证连通，实际上要对森林做操作。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e4</span><span class="number">+10</span>,M=<span class="number">5e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,q,boss[N],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> boss[x]==x?x:boss[x]=<span class="built_in">find</span>(boss[x]);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> w&gt;x.w;&#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge1</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;Edge1&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) boss[i]=i;</span><br><span class="line">    <span class="built_in">sort</span>(edge<span class="number">+1</span>,edge<span class="number">+1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;cnt&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">find</span>(edge[i].u),v=<span class="built_in">find</span>(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        boss[u]=v;</span><br><span class="line">        ++cnt;</span><br><span class="line">        u=edge[i].u,v=edge[i].v;</span><br><span class="line">        <span class="type">int</span> w=edge[i].w;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(&#123;u,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[N],dfncnt,son[N],fa[N],siz[N],top[N],dep[N],w[N],P,tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    dep[u]=dep[f]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:e[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=t.v;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">        w[v]=t.w;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]])</span><br><span class="line">            son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">    top[u]=topf;</span><br><span class="line">    dfn[u]=++dfncnt;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) <span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:e[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=t.v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) (x&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!siz[i]) w[i]=<span class="number">2e9</span>,<span class="built_in">dfs1</span>(i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs2</span>(i,i);</span><br><span class="line">    P=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(P&lt;=n<span class="number">+1</span>) P&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(tree));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        tree[P+dfn[i]]=w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=P<span class="number">-1</span>;i;i--)</span><br><span class="line">        tree[i]=<span class="built_in">min</span>(tree[<span class="built_in">ls</span>(i)],tree[<span class="built_in">rs</span>(i)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    l+=P<span class="number">-1</span>,r+=P<span class="number">+1</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l^<span class="number">1</span>^r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~l&amp;<span class="number">1</span>) res=<span class="built_in">min</span>(tree[l^<span class="number">1</span>],res);</span><br><span class="line">        <span class="keyword">if</span>(r&amp;<span class="number">1</span>) res=<span class="built_in">min</span>(tree[r^<span class="number">1</span>],res);</span><br><span class="line">        l&gt;&gt;=<span class="number">1</span>,r&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(dfn[top[x]],dfn[x]));</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(dfn[x]<span class="number">+1</span>,dfn[y]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        edge[i]=&#123;u,v,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ask</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="bjwc2010-严格次小生成树"><a
href="https://www.luogu.com.cn/problem/P4180">[BJWC2010]
严格次小生成树</a></h3>
跟上一道题一个套路。考虑枚举替换边的过程，首先加一条边形成环，再从环上删去最大的一条小于加入边边权的边。线段树维护区间最大值和区间严格次大值即可。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>,M=<span class="number">3e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,boss[N],cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> maxn,se;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> maxn=<span class="number">-1</span>,<span class="type">int</span> se=<span class="number">-1</span>):<span class="built_in">maxn</span>(maxn),<span class="built_in">se</span>(se)&#123;&#125;</span><br><span class="line">    node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        node res;</span><br><span class="line">        res.maxn=<span class="built_in">max</span>(maxn,x.maxn);</span><br><span class="line">        res.se=<span class="built_in">max</span>(se,x.se);</span><br><span class="line">        <span class="keyword">if</span>(maxn!=x.maxn)</span><br><span class="line">            res.se=<span class="built_in">max</span>(res.se,<span class="built_in">min</span>(maxn,x.maxn));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> P;</span><br><span class="line">node tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    l+=P<span class="number">-1</span>,r+=P<span class="number">+1</span>;</span><br><span class="line">    node res;</span><br><span class="line">    <span class="keyword">while</span>(l^<span class="number">1</span>^r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~l&amp;<span class="number">1</span>) res=res+tree[l^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(r&amp;<span class="number">1</span>) res=res+tree[r^<span class="number">1</span>];</span><br><span class="line">        l&gt;&gt;=<span class="number">1</span>,r&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> w&lt;x.w;&#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge1</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;Edge1&gt; e[N];</span><br><span class="line">ll ans,minval;</span><br><span class="line"><span class="type">int</span> dfn[N],top[N],dfncnt,dep[N],fa[N],siz[N],son[N],w[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> boss[x]==x?x:boss[x]=<span class="built_in">find</span>(boss[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[f]<span class="number">+1</span>;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:e[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=t.v;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">        w[v]=t.w;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]])</span><br><span class="line">            son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">    top[u]=topf;</span><br><span class="line">    dfn[u]=++dfncnt;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) <span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:e[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=t.v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==son[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    node res;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        res=res+<span class="built_in">query</span>(dfn[top[x]],dfn[x]);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) res=res+<span class="built_in">query</span>(dfn[x]<span class="number">+1</span>,dfn[y]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        edge[i]=&#123;u,v,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edge<span class="number">+1</span>,edge<span class="number">+1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) boss[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;cnt&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">find</span>(edge[i].u),v=<span class="built_in">find</span>(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        boss[u]=v;</span><br><span class="line">        vis[i]=<span class="number">1</span>;</span><br><span class="line">        u=edge[i].u,v=edge[i].v;</span><br><span class="line">        <span class="type">int</span> w=edge[i].w;</span><br><span class="line">        minval+=w;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(&#123;u,w&#125;);</span><br><span class="line">        <span class="keyword">if</span>(++cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    P=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(P&lt;=n<span class="number">+1</span>) P&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        tree[P+dfn[i]]=w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=P<span class="number">-1</span>;i;i--)</span><br><span class="line">        tree[i]=tree[i&lt;&lt;<span class="number">1</span>]+tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    ans=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> x=edge[i].u,y=edge[i].v,w=edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;</span><br><span class="line">        node temp=<span class="built_in">ask</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(temp.maxn==w)</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,minval-temp.se+w);</span><br><span class="line">        <span class="keyword">else</span> ans=<span class="built_in">min</span>(ans,minval-temp.maxn+w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="peaks"><a
href="https://www.luogu.com.cn/problem/P4197">Peaks</a></h3>
Kruskal
重构树的在线做法还是太吃操作了，我们直接离线。容易想到将边权和询问的
<span class="math inline">\(x\)</span> 升序排序后动态加边，查询第 <span
class="math inline">\(k\)</span>
大直接线段树上二分，加边用并查集+线段树合并维护。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>,M=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,q,h[N],b[N],len,tot,root[N],fa[N],now,ans[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> w&lt;x.w;&#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,x,k,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Query &amp;a)<span class="type">const</span>&#123;<span class="keyword">return</span> x&lt;a.x;&#125;</span><br><span class="line">&#125;qu[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> ls,rs,sum;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tree[u].sum=tree[tree[u].ls].sum+tree[tree[u].rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u) u=++tot;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        ++tree[u].sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(tree[u].ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(tree[u].rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a||!b) <span class="keyword">return</span> a|b;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[a].sum+=tree[b].sum;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tree[a].ls=<span class="built_in">merge</span>(tree[a].ls,tree[b].ls,l,mid);</span><br><span class="line">    tree[a].rs=<span class="built_in">merge</span>(tree[a].rs,tree[b].rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">push_up</span>(a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=tree[tree[u].ls].sum)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[u].ls,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[u].rs,mid<span class="number">+1</span>,r,k-tree[tree[u].ls].sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(h[i]);</span><br><span class="line">        b[i]=h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+n);</span><br><span class="line">    len=<span class="built_in">unique</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+len,h[i])-b;</span><br><span class="line">        <span class="built_in">modify</span>(root[i],<span class="number">1</span>,len,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        e[i]=&#123;u,v,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,v,x,k;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(v,x,k);</span><br><span class="line">        qu[i]=&#123;v,x,k,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(qu<span class="number">+1</span>,qu<span class="number">+1</span>+q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=qu[i].x,k=qu[i].k,id=qu[i].id;</span><br><span class="line">        <span class="keyword">while</span>(e[now<span class="number">+1</span>].w&lt;=x&amp;&amp;now&lt;m)&#123;</span><br><span class="line">            ++now;</span><br><span class="line">            <span class="type">int</span> u=<span class="built_in">find</span>(e[now].u),v=<span class="built_in">find</span>(e[now].v);</span><br><span class="line">            <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">            fa[u]=v;</span><br><span class="line">            root[v]=<span class="built_in">merge</span>(root[v],root[u],<span class="number">1</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> v=<span class="built_in">find</span>(qu[i].v);</span><br><span class="line">        <span class="keyword">if</span>(tree[root[v]].sum&lt;k) ans[id]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans[id]=b[<span class="built_in">query</span>(root[v],<span class="number">1</span>,len,tree[root[v]].sum-k<span class="number">+1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="最短路">最短路</h2>
没做。 ## 拓扑排序 ### <a
href="https://www.luogu.com.cn/problem/P2272">[ZJOI2007]
最大半连通子图</a>
容易发现，半连通子图就是若干相连的强连通分量，则找最大半连通子图转化为缩点后在
DAG 上找最长链+计数。注意去重。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>,M=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,mod,head[N],tot_edge;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> to,nxt;&#125;e1[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e1[++tot_edge].to=v;</span><br><span class="line">    e1[tot_edge].nxt=head[u];</span><br><span class="line">    head[u]=tot_edge;</span><br><span class="line">&#125;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">bool</span> instack[N];</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],dfncnt,scccnt,scc[N],w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++dfncnt;</span><br><span class="line">    instack[u]=<span class="number">1</span>;</span><br><span class="line">    st.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e1[i].nxt)&#123;</span><br><span class="line">        <span class="type">int</span> v=e1[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">        ++scccnt;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> v=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            instack[v]=<span class="number">0</span>;</span><br><span class="line">            scc[v]=scccnt;</span><br><span class="line">            ++w[scccnt];</span><br><span class="line">            <span class="keyword">if</span>(u==v) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e2[N];</span><br><span class="line"><span class="type">int</span> indegree[N],dp[N],dis[N],ans1,ans2;</span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; p;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e1[i].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> v=e1[i].to;</span><br><span class="line">            <span class="keyword">if</span>(scc[u]==scc[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(p.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(scc[u],scc[v]))!=p.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            p.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(scc[u],scc[v]));</span><br><span class="line">            e2[scc[u]].<span class="built_in">push_back</span>(scc[v]);</span><br><span class="line">            ++indegree[scc[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=scccnt;i++)</span><br><span class="line">        <span class="keyword">if</span>(!indegree[i])&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            dis[i]=w[i];</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:e2[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&lt;dis[u]+w[v])&#123;</span><br><span class="line">                dis[v]=dis[u]+w[v];</span><br><span class="line">                dp[v]=dp[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dis[v]==dis[u]+w[v])</span><br><span class="line">                dp[v]=(dp[u]+dp[v])%mod;</span><br><span class="line">            <span class="keyword">if</span>(!--indegree[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=scccnt;i++) ans1=<span class="built_in">max</span>(ans1,dis[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=scccnt;i++)</span><br><span class="line">        <span class="keyword">if</span>(dis[i]==ans1) ans2=(ans2+dp[i])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>,ans1,ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h1 id="day6">Day6</h1>
<h2 id="二分图">二分图</h2>
<h3 id="machine-schedule"><a
href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=246&amp;page=show_problem&amp;problem=3635">Machine
Schedule</a></h3>
连接每个 <span class="math inline">\(a_i\)</span> 和 <span
class="math inline">\(b_i\)</span>，问题变为了二分图上找最小点覆盖。直接跑二分图最大匹配即可。<br />
Kőnig 定理：二分图中，最小点覆盖中的顶点数量等于最大匹配中的边数量。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,ans,match[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            vis[v]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[v]||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">                match[v]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) e[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(n<span class="number">+10</span>));</span><br><span class="line">        <span class="built_in">read</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">read</span>(m,k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,a;i&lt;=k;i++)&#123;</span><br><span class="line">            <span class="built_in">read</span>(a,u,v);</span><br><span class="line">            e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">bool</span>)*(n<span class="number">+10</span>));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="usaco05jan-muddy-fields-g"><a
href="https://www.luogu.com.cn/problem/P6062">[USACO05JAN] Muddy Fields
G</a></h3>
贪心地考虑，极长地放木板一定优。将所有横着的和竖着的木板编号，相交的连边，之后二分图最大匹配。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> r,c,tota,totb,a[N][N],b[N][N],match[N*N],ans;</span><br><span class="line"><span class="type">char</span> mp[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N*N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N*N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            vis[v]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[v]||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">                match[v]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            cin&gt;&gt;mp[i][j];</span><br><span class="line">            <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    a[i][j]=a[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> a[i][j]=++tota;</span><br><span class="line">                <span class="keyword">if</span>(mp[i<span class="number">-1</span>][j]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    b[i][j]=b[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> b[i][j]=++totb;</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]&amp;&amp;b[i][j])</span><br><span class="line">                    e[a[i][j]].<span class="built_in">push_back</span>(b[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tota;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="guardian-of-decency"><a
href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=242&amp;page=show_problem&amp;problem=3235">Guardian
of Decency</a></h3>
最大独立集与最小点覆盖之和为顶点数目，这个推论适用于一般图。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> t,n,match[N],ans,cnta,cntb;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    string music,sport;</span><br><span class="line">&#125;a[N],b[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            vis[v]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[v]||<span class="built_in">dfs</span>(match[v]))&#123;</span><br><span class="line">                match[v]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) e[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(n<span class="number">+10</span>));</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i].h&gt;&gt;a[i].sex&gt;&gt;a[i].music&gt;&gt;a[i].sport;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i].h-a[j].h)&gt;<span class="number">40</span>||a[i].sex==a[j].sex||</span><br><span class="line">                    a[i].music!=a[j].music||a[i].sport==a[j].sport)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[i].sex==<span class="string">&#x27;M&#x27;</span>) e[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">                <span class="keyword">else</span> e[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">bool</span>)*(n<span class="number">+10</span>));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="欧拉路径">欧拉路径</h2>
<p>没做。 ## 连通分量 没做。</p>
<p>参考资料：<br />
https://oi-wiki.org/graph/graph-matching/bigraph-match/</p>
]]></content>
      <tags>
        <tag>题目合集</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题合集</title>
    <url>/2025/07/04/%E6%9D%82%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="abc_405e"><a
href="https://atcoder.jp/contests/abc405/tasks/abc405_e"
title="abc_405e">abc_405e</a></h3>
<p>简单组合计数。形式化地说，A 必须在 C 左边，A 必须在 D 左边，B 必须在
D左边，不难发现应对 C 进行分割，左半部分与 B 重合，而右半部分与 D
重合。如图 <img
src="https://github.com/headless-piston/blog_images/blob/main/abc405e.png?raw=true"
alt="image" /> 枚举 C 中的断点 <span
class="math inline">\(i\)</span>，答案即为 <span
class="math display">\[\sum_{i=0}^{c}\binom{a+b+i}{b}\binom{c-i+d-1}{d-1}\]</span>
预处理阶乘和逆元可以做到 <span class="math inline">\(O(n)\)</span>。 ###
<a href="https://www.luogu.com.cn/problem/P12509"
title="【模板】通信题">【模板】通信题</a> 通信题真好玩。
我们只能使用不大于 <span class="math inline">\(2^{20}\)</span>
的非负整数存储状态。注意到这个数刚好比 <span
class="math inline">\(10^6\)</span>
略大。这给我们对每一位附上不同权值提供了方便。考虑利用异或运算的性质，给每一位附上当前字符下标的权值（下标从
<span class="math inline">\(1\)</span>）开始，然后求其异或和。将 <span
class="math inline">\(S\)</span> 和 <span
class="math inline">\(T\)</span> 的结果异或起来即得答案。注意下标一定从
<span class="math inline">\(1\)</span> 开始，否则第一位的值无论如何都是
<span class="math inline">\(0\)</span>。</p>
<details>
<summary>
communication.cpp
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Alice</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S.<span class="built_in">length</span>();i++)</span><br><span class="line">        res^=(i<span class="number">+1</span>)*(S[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bob</span><span class="params">(string T,<span class="type">int</span> X)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.<span class="built_in">length</span>();i++)</span><br><span class="line">        res^=(i<span class="number">+1</span>)*(T[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> X^res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="mdoi-r1group"><a href="https://www.luogu.com.cn/problem/P6069"
title="『MdOI R1』Group">『MdOI R1』Group</a></h3>
<p>二分答案。 注意到，对 <span class="math inline">\(a\)</span>
进行排序，则我们可以选中其中一段连续的区间，计算它的方差。而两侧的值直接设为区间的平均值，不产生贡献。这样是最优策略。在检查合法性时直接从
<span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span>
枚举区间就好了，预处理前缀和和前缀平方和可做到 <span
class="math inline">\(O(1)\)</span> 求方差。 二分时，<span
class="math inline">\(l\)</span> 必须从 <span
class="math inline">\(1\)</span> 开始。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],l,r;</span><br><span class="line">ll m,sum[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=l+len<span class="number">-1</span>;r&lt;=n;l++,r++)&#123;</span><br><span class="line">        ll s=sum[r][<span class="number">0</span>]-sum[l<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">double</span> p=<span class="number">1.0</span>*s/len;</span><br><span class="line">        <span class="type">double</span> res=len*p*p;</span><br><span class="line">        res-=<span class="number">2</span>*s*p;</span><br><span class="line">        res+=sum[r][<span class="number">1</span>]-sum[l<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(res&lt;=m)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    std::<span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum[i][<span class="number">0</span>]=sum[i<span class="number">-1</span>][<span class="number">0</span>]+a[i];</span><br><span class="line">        sum[i][<span class="number">1</span>]=sum[i<span class="number">-1</span>][<span class="number">1</span>]<span class="number">+1ll</span>*a[i]*a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l=<span class="number">1</span>,r=n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">            l=mid<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="noip-2014-提高组-飞扬的小鸟"><a
href="https://www.luogu.com.cn/problem/P1941"
title="[NOIP 2014 提高组] 飞扬的小鸟">[NOIP 2014 提高组]
飞扬的小鸟</a></h3>
<span class="math inline">\(dp_{i,j}\)</span> 表示在 <span
class="math inline">\((i,j)\)</span>
所用的最少点击屏幕数，显然有朴素转移方程 <span
class="math display">\[dp_{i,j}=\min(dp_{i,j},dp_{i-1,j-k\times
x_{i-1}},dp_{i-1,j+y_{i-1}})\]</span> 时间复杂度 <span
class="math inline">\(O(nm^2)\)</span>。 考虑优化，复杂度瓶颈在于 <span
class="math inline">\(k\)</span>
的枚举。我们发现，可以使用类似完全背包的处理，从 <span
class="math inline">\(dp_{i,j-(k-1)\times x_{i-1}}\)</span> 转移到 <span
class="math inline">\(dp_{i,j-k\times x_{i-1}}\)</span> 而不必从 <span
class="math inline">\(dp_{i-1}\)</span> 转移。时间复杂度 <span
class="math inline">\(O(nm)\)</span>。
注意要先处理点击屏幕的情况，否则可能出现同一横坐标既向下又向上的情况。
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b,<span class="type">const</span> Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Min</span>(<span class="built_in">Min</span>(a,b),args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>,M=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,x[N],y[N],dp[N][M],cnt,res;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,h;</span><br><span class="line">&#125;c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">read</span>(x[i],y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,p;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(p);</span><br><span class="line">        <span class="built_in">read</span>(c[p].l,c[p].h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        dp[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=x[i<span class="number">-1</span>]<span class="number">+1</span>;j&lt;=m;j++)</span><br><span class="line">            dp[i][j]=<span class="built_in">Min</span>(dp[i][j],dp[i<span class="number">-1</span>][j-x[i<span class="number">-1</span>]]<span class="number">+1</span>,dp[i][j-x[i<span class="number">-1</span>]]<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m-x[i<span class="number">-1</span>];j&lt;=m;j++)</span><br><span class="line">            dp[i][m]=<span class="built_in">Min</span>(dp[i][m],dp[i<span class="number">-1</span>][j]<span class="number">+1</span>,dp[i][j]<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j+y[i<span class="number">-1</span>]&lt;=m;j++)</span><br><span class="line">            dp[i][j]=<span class="built_in">Min</span>(dp[i][j],dp[i<span class="number">-1</span>][j+y[i<span class="number">-1</span>]]);</span><br><span class="line">        <span class="keyword">if</span>(c[i].h)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c[i].l;j++)</span><br><span class="line">                dp[i][j]=inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=c[i].h;j&lt;=m;j++)</span><br><span class="line">                dp[i][j]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]!=inf)&#123;</span><br><span class="line">                f=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(f)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n%d\n&quot;</span>,cnt<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        res=<span class="built_in">Min</span>(res,dp[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1\n%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="邦邦的大合唱站队"><a
href="https://www.luogu.com.cn/problem/P3694"
title="邦邦的大合唱站队">邦邦的大合唱站队</a></h3>
<p>状压
DP，每一位表示一种乐队。预处理前缀和计算长度。代码实现也很简单。<del>（很久没有独立想出过
DP 题了）</del></p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,dp[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],sum[N][<span class="number">30</span>],len[<span class="number">1</span>&lt;&lt;<span class="number">21</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; t[<span class="number">30</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        sum[i][a<span class="number">-1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            sum[i][j]+=sum[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,bitcnt;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)&#123;</span><br><span class="line">        bitcnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                bitcnt++;</span><br><span class="line">                len[i]+=sum[n][j];</span><br><span class="line">            &#125;</span><br><span class="line">        t[bitcnt].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p:t[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=p;j;j^=<span class="built_in">lowbit</span>(j))&#123;</span><br><span class="line">                <span class="type">int</span> k=<span class="built_in">lowbit</span>(j);</span><br><span class="line">                dp[p]=<span class="built_in">Min</span>(dp[p],dp[p^k]+len[p]-len[p^k]-(sum[len[p]][__lg(k)]-sum[len[p^k]][__lg(k)]));</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="可持久化并查集"><a href="https://www.luogu.com.cn/problem/P3402"
title="可持久化并查集">可持久化并查集</a></h3>
<p>用可持久化数组实现。使用按秩合并但不使用路径压缩。注意修改 <span
class="math inline">\(fa\)</span> 与修改 <span
class="math inline">\(dep\)</span> 都要新建版本。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        x=~x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T c=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>,M=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> ls,rs,fa,dep;</span><br><span class="line">&#125;tree[N*<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> nodetot,root[M],n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    u=++nodetot;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[u].fa=l;</span><br><span class="line">        tree[u].dep=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(tree[u].ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(tree[u].rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_fa</span><span class="params">(<span class="type">int</span> old,<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    u=++nodetot;</span><br><span class="line">    tree[u]=tree[old];</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[u].fa=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="built_in">modify_fa</span>(tree[old].ls,tree[u].ls,l,mid,x,k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">modify_fa</span>(tree[old].rs,tree[u].rs,mid<span class="number">+1</span>,r,x,k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_dep</span><span class="params">(<span class="type">int</span> old,<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    u=++nodetot;</span><br><span class="line">    tree[u]=tree[old];</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[u].dep++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="built_in">modify_dep</span>(tree[old].ls,tree[u].ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">modify_dep</span>(tree[old].rs,tree[u].rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_fa</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">        <span class="keyword">return</span> tree[u].fa;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_fa</span>(tree[u].ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_fa</span>(tree[u].rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_dep</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">        <span class="keyword">return</span> tree[u].dep;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_dep</span>(tree[u].ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_dep</span>(tree[u].rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> ver,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">query_fa</span>(root[ver],<span class="number">1</span>,n,x);</span><br><span class="line">    <span class="keyword">if</span>(fx==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(ver,fx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> ver,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(ver<span class="number">-1</span>,x);</span><br><span class="line">    y=<span class="built_in">find</span>(ver<span class="number">-1</span>,y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">        root[ver]=root[ver<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> depx=<span class="built_in">query_dep</span>(root[ver<span class="number">-1</span>],<span class="number">1</span>,n,x),depy=<span class="built_in">query_dep</span>(root[ver<span class="number">-1</span>],<span class="number">1</span>,n,y);</span><br><span class="line">    <span class="keyword">if</span>(depx&gt;depy)</span><br><span class="line">        <span class="built_in">Swap</span>(x,y);</span><br><span class="line">    <span class="built_in">modify_fa</span>(root[ver<span class="number">-1</span>],root[ver],<span class="number">1</span>,n,x,y);</span><br><span class="line">    <span class="keyword">if</span>(depx==depy)</span><br><span class="line">        <span class="built_in">modify_dep</span>(root[ver],root[ver],<span class="number">1</span>,n,y);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> opt,a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">build</span>(root[<span class="number">0</span>],<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(opt);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(a,b);</span><br><span class="line">            <span class="built_in">merge</span>(i,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">read</span>(a);</span><br><span class="line">            root[i]=root[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">read</span>(a,b);</span><br><span class="line">            root[i]=root[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i,a)==<span class="built_in">find</span>(i,b))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="pa-2024-modernizacja-bajtocji"><a
href="https://www.luogu.com.cn/problem/P10350"
title="[PA 2024] Modernizacja Bajtocji">[PA 2024] Modernizacja
Bajtocji</a></h3>
<p>挺喜欢这道题，但出在模拟赛里我就不喜欢了。
显然需要维护连通块，连通块内出现环了就说明都有电脑了，连通块是树形的就无法确定。然而这里有一个删除操作。并查集不好进行删除，我们发现被删的点留在连通块内无影响，则考虑对每个人维护
<span class="math inline">\(id\)</span>，删除即为更新 <span
class="math inline">\(id\)</span>。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T c=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.3e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> fa[N],siz[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,id[N],have[N],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        fa[i]=i,siz[i]=<span class="number">1</span>,id[i]=i;</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            a=id[a];</span><br><span class="line">            <span class="type">int</span> p=<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">if</span>(siz[p]==<span class="number">1</span>)</span><br><span class="line">                cout&lt;&lt;have[p];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(have[p])</span><br><span class="line">                cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            a=id[a],b=id[b];</span><br><span class="line">            <span class="type">int</span> p=<span class="built_in">find</span>(a),q=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(p==q)</span><br><span class="line">                have[p]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fa[q]=p;</span><br><span class="line">                siz[p]+=siz[q];</span><br><span class="line">                have[p]|=have[q];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            <span class="type">int</span> a1=a;</span><br><span class="line">            a=id[a];</span><br><span class="line">            <span class="type">int</span> p=<span class="built_in">find</span>(a);</span><br><span class="line">            siz[p]--;</span><br><span class="line">            id[a1]=++cnt;</span><br><span class="line">            fa[cnt]=cnt;</span><br><span class="line">            siz[cnt]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="模板最长公共子序列"><a
href="https://www.luogu.com.cn/problem/P1439"
title="【模板】最长公共子序列">【模板】最长公共子序列</a></h3>
<p>好早以前欠的一道题，现在补上。 朴素 DP <span
class="math inline">\(O(n^2)\)</span>，但这题可以转化为求最长上升子序列。将序列
<span class="math inline">\(P_1\)</span> 视为是“有序的”，按照 <span
class="math inline">\(P_1\)</span> 的排序规则在 <span
class="math inline">\(P_2\)</span>
中求最长上升子序列，显然这就是答案。实现方面的话开个桶就行。
最长上升子序列 <span class="math inline">\(O(n\log n)\)</span> 求法： 设
<span class="math inline">\(dp_i\)</span> 表示到第 <span
class="math inline">\(i\)</span> 个数时的答案，<span
class="math inline">\(t_i\)</span> 表示 <span
class="math inline">\(dp_i\)</span> 对应的序列最大值，显然有 <span
class="math inline">\(dp_i=\max_{j&lt;i \land t_j&lt;b_i}
dp_j\)</span>，我们可以用树状数组维护前缀 <span
class="math inline">\(\max\)</span>，实现 <span
class="math inline">\(O(n\log n)\)</span> 的时间复杂度。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(<span class="type">const</span> T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],b[N],dp[N],ans;</span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        tree[x]=<span class="built_in">Max</span>(tree[x],k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x^=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        res=<span class="built_in">Max</span>(tree[x],res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,t;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(t),a[t]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i]);</span><br><span class="line">        dp[i]=<span class="built_in">query</span>(a[b[i]])<span class="number">+1</span>;</span><br><span class="line">        <span class="built_in">modify</span>(a[b[i]],dp[i]);</span><br><span class="line">        ans=<span class="built_in">Max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="cqoi2017-小q的棋盘"><a
href="https://www.luogu.com.cn/problem/P3698"
title="[CQOI2017] 小Q的棋盘">[CQOI2017] 小Q的棋盘</a></h3>
<p>也是模拟赛的史，可以树形 DP，但我选择贪。
优先走最长链，如果还有剩余步数就需要每两步访问一个新节点。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(<span class="type">const</span> T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;y?y:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">114</span>;</span><br><span class="line"><span class="type">int</span> v,n,maxdep;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">    maxdep=<span class="built_in">Max</span>(maxdep,dep);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u,dep<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(v,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;v;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(a,b);</span><br><span class="line">        a++,b++;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=maxdep<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Min</span>(v,maxdep+(n-maxdep<span class="number">+1</span>)/<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="sza-cloakroom"><a href="https://www.luogu.com.cn/problem/P3537"
title="SZA-Cloakroom">SZA-Cloakroom</a></h3>
<p>很巧妙的一道 DP。显然可以将物品和询问离线下来分别按时间排序。设 <span
class="math inline">\(dp_k\)</span> 表示总价值为 <span
class="math inline">\(k\)</span> 的物品能拿走的最后的时间。转移 <span
class="math display">\[dp_k=\max(dp_k,\min(dp_k-c_j,b_j))\]</span>
表示新加入物品 <span class="math inline">\(j\)</span>，我们能否凑出
<span class="math inline">\(k\)</span>
决定于最早被取走的那个物品的时间，所以取 <span
class="math inline">\(\min\)</span>，而我们显然希望这个值越晚越好，所以取
<span class="math inline">\(\max\)</span>，则只要 <span
class="math inline">\(dp_k&gt;m_i+s_i\)</span> 就说明合法。 初始状态所有
<span class="math inline">\(dp\)</span> 均为 <span
class="math inline">\(-\inf\)</span>，表示均不合法。<span
class="math inline">\(dp_0\)</span> 为 <span
class="math inline">\(\inf\)</span> 表示不选任何物品总是可行的。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>,M=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> c,a,b;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&lt;x.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">    <span class="type">int</span> m,k,s,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> query &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m&lt;x.m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[M];</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="type">const</span> T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x&lt;y?y:x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="type">const</span> T &amp;x,<span class="type">const</span> T &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x&lt;y?x:y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,p,dp[<span class="number">100010</span>],ans[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;t[i].c&gt;&gt;t[i].a&gt;&gt;t[i].b;</span><br><span class="line">    <span class="built_in">sort</span>(t<span class="number">+1</span>,t<span class="number">+1</span>+n);</span><br><span class="line">    cin&gt;&gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">        cin&gt;&gt;q[i].m&gt;&gt;q[i].k&gt;&gt;q[i].s,q[i].id=i;</span><br><span class="line">    <span class="built_in">sort</span>(q<span class="number">+1</span>,q<span class="number">+1</span>+p);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;t[j].a&lt;=q[i].m&amp;&amp;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">100000</span>;k&gt;=t[j].c;k--)</span><br><span class="line">                dp[k]=<span class="built_in">Max</span>(dp[k],<span class="built_in">Min</span>(dp[k-t[j].c],t[j].b));</span><br><span class="line">        ans[q[i].id]=dp[q[i].k]&gt;(q[i].m+q[i].s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">        <span class="built_in">printf</span>(ans[i]?<span class="string">&quot;TAK\n&quot;</span>:<span class="string">&quot;NIE\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="abc_288f"><a
href="https://atcoder.jp/contests/abc288/tasks/abc288_f"
title="abc_288f">abc_288f</a></h3>
<p>设 <span class="math inline">\(dp_i\)</span> 表示前 <span
class="math inline">\(i\)</span> 位的答案，有朴素的转移 <span
class="math display">\[dp_i=\sum_{j=1}^{i-1} dp_j\times
\overline{X_{j+1}X_{j+2}\cdots X_i}\]</span> 化简： <span
class="math display">\[dp_i=10\times dp_{i-1}+X_i+X_i\times
\sum_{j=1}^{i-1}dp_j\]</span> 可以维护前缀和实现 <span
class="math inline">\(O(n)\)</span>。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,x;</span><br><span class="line">ll sum,dp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %1d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">    dp=sum=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;x);</span><br><span class="line">        dp=(dp*<span class="number">10</span>%mod+sum*x%mod+x)%mod;</span><br><span class="line">        sum=(sum+dp)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="小-a-和-uim-之大逃离"><a
href="https://www.luogu.com.cn/problem/P1373"
title="小 a 和 uim 之大逃离">小 a 和 uim 之大逃离</a></h3>
<p>我们事实上只关注二者的差，所以无需分别记录状态。<span
class="math inline">\(dp_{i,j,t,0/1}\)</span> 表示在 <span
class="math inline">\((i,j)\)</span>，二者之差为 <span
class="math inline">\(t\)</span>，当前应为小 a/uim
走。转移很朴素，看代码吧。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">810</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,a[N][N],dp[N][N][<span class="number">20</span>][<span class="number">2</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    k++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            dp[i][j][a[i][j]%k][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=k;t++)&#123;</span><br><span class="line">                dp[i][j][t][<span class="number">0</span>]=(dp[i][j][t][<span class="number">0</span>]+dp[i<span class="number">-1</span>][j][(t-a[i][j]+k)%k][<span class="number">1</span>])%mod;</span><br><span class="line">                dp[i][j][t][<span class="number">0</span>]=(dp[i][j][t][<span class="number">0</span>]+dp[i][j<span class="number">-1</span>][(t-a[i][j]+k)%k][<span class="number">1</span>])%mod;</span><br><span class="line">                dp[i][j][t][<span class="number">1</span>]=(dp[i][j][t][<span class="number">1</span>]+dp[i<span class="number">-1</span>][j][(t+a[i][j])%k][<span class="number">0</span>])%mod;</span><br><span class="line">                dp[i][j][t][<span class="number">1</span>]=(dp[i][j][t][<span class="number">1</span>]+dp[i][j<span class="number">-1</span>][(t+a[i][j])%k][<span class="number">0</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            ans=(ans+dp[i][j][<span class="number">0</span>][<span class="number">1</span>])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="sdoi2010-地精部落"><a
href="https://www.luogu.com.cn/problem/P2467"
title="[SDOI2010] 地精部落">[SDOI2010] 地精部落</a></h3>
<p><span class="math inline">\(dp_{j,0/1}\)</span> 表示前 <span
class="math inline">\(i\)</span> 个数中最后一个是第 <span
class="math inline">\(j\)</span> 大的数的升/降序方案数。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4210</span>;</span><br><span class="line"><span class="type">int</span> n,p,dp[N][<span class="number">2</span>],sum[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    sum[<span class="number">1</span>][<span class="number">0</span>]=sum[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            dp[j][<span class="number">0</span>]=sum[j<span class="number">-1</span>][<span class="number">1</span>]%p;</span><br><span class="line">            dp[j][<span class="number">1</span>]=(sum[i<span class="number">-1</span>][<span class="number">0</span>]-sum[j<span class="number">-1</span>][<span class="number">0</span>]+p)%p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            sum[j][<span class="number">0</span>]=(dp[j][<span class="number">0</span>]+sum[j<span class="number">-1</span>][<span class="number">0</span>])%p;</span><br><span class="line">            sum[j][<span class="number">1</span>]=(dp[j][<span class="number">1</span>]+sum[j<span class="number">-1</span>][<span class="number">1</span>])%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(sum[n][<span class="number">0</span>]+sum[n][<span class="number">1</span>])%p&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="scoi2009-游戏"><a href="https://www.luogu.com.cn/problem/P4161"
title="[SCOI2009] 游戏">[SCOI2009] 游戏</a></h3>
<p>神仙题，转化太难想了。观察题目给的实例，发现转化关系可分为 <span
class="math inline">\(3\)</span>
组，不难看出每组的周期应为该组内元素数量，总排数即为各组的元素数的 <span
class="math inline">\(\operatorname{lcm}\)</span> 再加 <span
class="math inline">\(1\)</span>。接下来想如何不重地枚举所有对应关系。考虑使用质因数分解。使用类似完全背包的写法，这样就保证了所有方案的枚举。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,prime[N],e[N],tot;</span><br><span class="line">ll dp[N],res;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!e[i])</span><br><span class="line">            prime[e[i]=++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=e[i]&amp;&amp;prime[j]*i&lt;=n;j++)</span><br><span class="line">            e[prime[j]*i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=prime[i];j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=prime[i];k&lt;=j;k*=prime[i])</span><br><span class="line">                dp[j]+=dp[j-k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        res+=dp[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="lnoi2019-真正的-oier-从不女装"><a
href="https://www.luogu.com.cn/problem/P5500"
title="[LnOI2019] 真正的 OIer 从不女装">[LnOI2019] 真正的 OIer
从不女装</a></h3>
<p>我们发现，女装只有零次和无数次。所以将 <span
class="math inline">\(k&gt;0\)</span> 的情况视为 <span
class="math inline">\(k=1\)</span>。线段树维护区间最长连续段、包含最左/右端最长连续段。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::max;</span><br><span class="line"><span class="keyword">using</span> std::min;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> maxn,maxl,maxr,tag,vall,valr,len;</span><br><span class="line">    <span class="built_in">Seg</span>(<span class="type">int</span> maxn=<span class="number">0</span>,<span class="type">int</span> maxl=<span class="number">0</span>,<span class="type">int</span> maxr=<span class="number">0</span>,<span class="type">int</span> tag=<span class="number">0</span>,<span class="type">int</span> vall=<span class="number">0</span>,<span class="type">int</span> valr=<span class="number">0</span>,<span class="type">int</span> len=<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">maxn</span>(maxn),<span class="built_in">maxl</span>(maxl),<span class="built_in">maxr</span>(maxr),<span class="built_in">tag</span>(tag),<span class="built_in">vall</span>(vall),<span class="built_in">valr</span>(valr),<span class="built_in">len</span>(len)&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> Seg <span class="keyword">operator</span>+(<span class="type">const</span> Seg &amp;a,<span class="type">const</span> Seg &amp;b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a.len) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(!b.len) <span class="keyword">return</span> a;</span><br><span class="line">        Seg res;</span><br><span class="line">        res.maxn=<span class="built_in">max</span>(a.maxn,b.maxn);</span><br><span class="line">        res.maxl=a.maxl,res.maxr=b.maxr;</span><br><span class="line">        res.vall=a.vall,res.valr=b.valr;</span><br><span class="line">        res.len=a.len+b.len;</span><br><span class="line">        <span class="keyword">if</span>(a.valr==b.vall)&#123;</span><br><span class="line">            res.maxn=<span class="built_in">max</span>(res.maxn,a.maxr+b.maxl);</span><br><span class="line">            <span class="keyword">if</span>(a.maxl==a.len) res.maxl+=b.maxl;</span><br><span class="line">            <span class="keyword">if</span>(b.maxr==b.len) res.maxr+=a.maxr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="built_in">read</span>(val);</span><br><span class="line">        tree[u]=<span class="built_in">Seg</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,val,val,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    tree[u]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[u].tag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> lenl=tree[ls].len,lenr=tree[rs].len,val=tree[u].tag;</span><br><span class="line">    tree[ls]=<span class="built_in">Seg</span>(lenl,lenl,lenl,val,val,val,lenl);</span><br><span class="line">    tree[rs]=<span class="built_in">Seg</span>(lenr,lenr,lenr,val,val,val,lenr);</span><br><span class="line">    tree[u].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> len=tree[u].len;</span><br><span class="line">        tree[u]=<span class="built_in">Seg</span>(len,len,len,k,k,k,len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(ls,l,mid,x,y,k);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,x,y,k);</span><br><span class="line">    tree[u]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Seg <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r) <span class="keyword">return</span> tree[u];</span><br><span class="line">    Seg res;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) res=res+<span class="built_in">query</span>(ls,l,mid,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) res=res+<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x,y,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(ch!=<span class="string">&#x27;R&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;Q&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">read</span>(x,y,k);</span><br><span class="line">        <span class="keyword">if</span>(ch^<span class="string">&#x27;Q&#x27;</span>) <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y).maxn);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Seg temp=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">            <span class="type">int</span> res=temp.maxn;</span><br><span class="line">            <span class="keyword">if</span>(temp.vall==temp.valr) res=<span class="built_in">max</span>(res,temp.maxl+temp.maxr);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">min</span>(res,temp.len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="noip-2004-提高组-合并果子-加强版"><a
href="https://www.luogu.com.cn/problem/P6033"
title="[NOIP 2004 提高组] 合并果子 加强版">[NOIP 2004 提高组] 合并果子
加强版</a></h3>
<p>传统做法中堆的 <span class="math inline">\(O(n\log n)\)</span>
复杂度太高了，我们使用两个队列，先桶排，然后按顺序插入队列 <span
class="math inline">\(q_1\)</span> 中，之后每合并一次就将结果插入队列
<span class="math inline">\(q_2\)</span> 中，容易发现，<span
class="math inline">\(q_1\)</span> 和 <span
class="math inline">\(q_2\)</span>
都具有单调性，所以每次只需从两个队列的队头取出 <span
class="math inline">\(2\)</span> 个最小的数即可。时间复杂度 <span
class="math inline">\(O(n)\)</span>。注意读入的常数。 使用这种思路，做
<a href="https://www.luogu.com.cn/problem/P2827"
title="[NOIP 2016 提高组] 蚯蚓">[NOIP 2016 提高组] 蚯蚓</a>。</p>
<details>
<summary>
code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getchar getchar_unlocked</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a,b[M];</span><br><span class="line">queue&lt;ll&gt; q1,q2;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="function">ll <span class="title">get_min</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q<span class="number">1.</span><span class="built_in">empty</span>())&#123;</span><br><span class="line">        ll x=q<span class="number">2.f</span>ront();</span><br><span class="line">        q<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q<span class="number">2.</span><span class="built_in">empty</span>())&#123;</span><br><span class="line">        ll x=q<span class="number">1.f</span>ront();</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q<span class="number">1.f</span>ront()&lt;q<span class="number">2.f</span>ront())&#123;</span><br><span class="line">        ll x=q<span class="number">1.f</span>ront();</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x=q<span class="number">2.f</span>ront();</span><br><span class="line">    q<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a),b[a]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1e5</span>;i++)</span><br><span class="line">        <span class="keyword">while</span>(b[i]--)</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ll x=<span class="built_in">get_min</span>(),y=<span class="built_in">get_min</span>();</span><br><span class="line">        q<span class="number">2.</span><span class="built_in">push</span>(x+y);</span><br><span class="line">        sum+=x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="多人背包"><a href="https://www.luogu.com.cn/problem/P1858"
title="多人背包">多人背包</a></h3>
<p>也是很久以前的题，之前好几次想写都觉得太抽象写不了，今天静下心来想一想其实并不难。
<span class="math inline">\(dp_{j,k}\)</span> 表示容量为 <span
class="math inline">\(j\)</span> 时的第 <span
class="math inline">\(k\)</span>
优解。我们直接双指针枚举选或不选当前物品，枚举出当前的前 <span
class="math inline">\(k\)</span>
优，将它们存入队列中然后直接转移。时间复杂度 <span
class="math inline">\(O(nvk)\)</span>，空间复杂度 <span
class="math inline">\(O(vk)\)</span>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> k,v,n,a[<span class="number">210</span>],b[<span class="number">210</span>],dp[<span class="number">5010</span>][<span class="number">60</span>],temp[<span class="number">60</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;v&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=a[i];j--)&#123;</span><br><span class="line">            <span class="type">int</span> p1=<span class="number">1</span>,p2=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(cnt&lt;=k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][p1]&gt;dp[j-a[i]][p2]+b[i])</span><br><span class="line">                    temp[++cnt]=dp[j][p1++];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    temp[++cnt]=dp[j-a[i]][p2++]+b[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=k;t++)</span><br><span class="line">                dp[j][t]=temp[t];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        ans+=dp[v][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>题目合集</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/2025/07/04/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p>我们发现：在树上维护一些信息不方便我们套用一些数据结构，但树链剖分可以将树分割为若干条链。树链剖分的方式有很多种，在算法竞赛中，应用最广泛的是重链剖分。
一般使用线段树维护。 定义：
重子节点为当前节点的所有儿子中子树最大的子节点，从这个节点到重子节点的边叫做重边，重边相连构成重链。与之对应地，有轻子节点，轻边。
<img
src="https://github.com/headless-piston/blog_images/blob/main/heavy-light%20decomposition.png?raw=true"
alt="image" /></p>
<p>树链剖分的实现使用了 2 遍 dfs，分别记录了不同信息。 ### dfs1
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	dep[u]=dep[f]<span class="number">+1</span>;<span class="comment">//深度 </span></span><br><span class="line">	siz[u]=<span class="number">1</span>;<span class="comment">//子树大小 </span></span><br><span class="line">	fa[u]=f;<span class="comment">//父节点 </span></span><br><span class="line">	<span class="type">int</span> maxson=<span class="number">-1</span>;<span class="comment">//子节点中最大的siz，也就是重儿子所对的siz </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v!=f)&#123;</span><br><span class="line">			<span class="built_in">dfs1</span>(v,u);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			<span class="keyword">if</span>(siz[v]&gt;maxson)&#123;</span><br><span class="line">				son[u]=v;<span class="comment">//重儿子 </span></span><br><span class="line">				maxson=siz[v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这里，维护了每个节点的深度，父节点和子树大小最大的子节点。
### dfs2 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">	dfn[u]=++cnt;<span class="comment">//dfn序，也就是线段树上的编号 </span></span><br><span class="line">	top[u]=topf;<span class="comment">//当前树链的最顶端节点 </span></span><br><span class="line">	w1[cnt]=w[u];<span class="comment">//新的权值 </span></span><br><span class="line">	<span class="keyword">if</span>(!son[u])</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">dfs2</span>(son[u],topf);<span class="comment">//重儿子的处理 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v!=fa[u]&amp;&amp;v!=son[u])<span class="comment">//轻儿子的处理 </span></span><br><span class="line">			<span class="built_in">dfs2</span>(v,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这里，维护了每个节点的
dfn，每个节点所在重链的链顶和使用 dfn 编号的点权。 使用 dfn 的原因是 dfn
可以保证同一子树内的点在一个连续的区间内，方便使用数据结构进行维护。</p>
<h3 id="查询操作">查询操作</h3>
<p>树链剖分完毕后，我们就可以借助数据结构求任意点 <span
class="math inline">\(x\)</span> 的子树的相关信息。
例如，查询子树所有节点权值之和。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//维护区间和的线段树</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="number">-1</span>));</span><br></pre></td></tr></table></figure> 可以证明，<span
class="math inline">\(x\)</span> 的子树所对的区间是 <span
class="math inline">\(x\)</span> 的 dfn 到 <span
class="math inline">\(x\)</span> 的 dfn 加 <span
class="math inline">\(x\)</span> 的子树大小减 <span
class="math inline">\(1\)</span>。</p>
<p>树链剖分还有一个强大的功能：求 LCA。
不断向上跳重链，当跳到同一条重链上时，深度较小的结点即为 LCA。
向上跳重链时需要先跳所在重链顶端深度较大的那个。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[u]]&gt;dep[top[v]])</span><br><span class="line">			u=fa[top[u]];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			v=fa[top[v]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[u]&gt;dep[v]?v:u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
类似地，我们就可以对任意点 <span class="math inline">\(x\)</span> 到
<span class="math inline">\(y\)</span> 路径上的点权进行查询和修改。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tree_sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//x到y路径上的和 </span></span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">			std::<span class="built_in">swap</span>(x,y);</span><br><span class="line">		ans=(ans+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x]))%p;</span><br><span class="line">		x=fa[top[x]];<span class="comment">//跳到链顶的父节点 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&gt;dep[y])</span><br><span class="line">		std::<span class="built_in">swap</span>(x,y);</span><br><span class="line">	ans=(ans+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y]))%p;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree_add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;<span class="comment">//x到y最短路径上所有节点值加k </span></span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">			std::<span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x],k);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&gt;dep[y])</span><br><span class="line">		std::<span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y],k);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> *注：对 <span class="math inline">\(p\)</span>
取模是题目要求。</p>
<p>如果边权下放点权维护边信息，不想累加 LCA 处的贡献，可以这么写：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        res+=<span class="built_in">query</span>(dfn[top[x]],dfn[x]);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) res+=<span class="built_in">query</span>(dfn[x]<span class="number">+1</span>,dfn[y]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>树链剖分的复杂度为 <span class="math inline">\(O(\log
n)\)</span>。而且一般情况下跑不满且常数极小。</p>
<p><a href="https://www.luogu.com.cn/problem/P3384"
title="模板">模板</a></p>
<p><a href="https://oi-wiki.org/graph/hld/"
title="参考资料">参考资料</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>概率与期望</title>
    <url>/2025/07/04/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/</url>
    <content><![CDATA[<p>引入：一个普通骰子，求投出点数的期望。 <span
class="math display">\[E=\sum_i p_i w_i\]</span> 其中，<span
class="math inline">\(p_i\)</span> 表示事件 <span
class="math inline">\(i\)</span> 发生的概率，<span
class="math inline">\(w_i\)</span> 表示事件 <span
class="math inline">\(i\)</span> 发生的收益，<span
class="math inline">\(E\)</span> 为收益期望。 在这个题中，<span
class="math inline">\(E=\dfrac{1}{6}\times1+\dfrac{1}{6}\times2+\cdots+\dfrac{1}{6}\times6=3.5\)</span>。
### 期望的线性性 现有 <span class="math inline">\(3\)</span>
个骰子，求投一次这 <span class="math inline">\(3\)</span>
个骰子的点数之和的期望。对于本题，只要分别求出这 <span
class="math inline">\(3\)</span>
个骰子的期望并加起来就可以了。这就是期望的线性性。 <span
class="math display">\[E(x+y)=E(x)+E(y)\]</span> 若 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 相互独立，则 <span
class="math display">\[E(x)E(y)=E(xy)\]</span> 对于常数 <span
class="math inline">\(k\)</span> ，有 <span
class="math display">\[E(kx)=kE(x)\]</span> ### 解题方式
解决期望问题一般使用 DP 或高斯消元。 ### 例题 1 现有 <span
class="math inline">\(1\)</span> 个按钮，每按一次就会等概率返回 Yes 或
No，期望按多少次会返回 Yes？ 答案为 <span
class="math inline">\(2\)</span>。 考虑第一次返回 Yes 的概率为 <span
class="math inline">\(\dfrac{1}{2}\)</span>，第二次返回 Yes 的概率为
<span class="math inline">\(\dfrac{1}{4}\)</span>，第三次为 <span
class="math inline">\(\dfrac{1}{8}\)</span>…… 则 <span
class="math inline">\(E=\dfrac{1}{2}\times 1+\dfrac{1}{4}\times
2+\dfrac{1}{8}\times 3+\cdots=2\)</span>。 ### 例题 2 有 <span
class="math inline">\(n\)</span>
种不同的邮票，想收集所有种类的邮票，每次只能买一张，且买到任何一种邮票是等概率的，为
<span class="math inline">\(\dfrac{1}{n}\)</span>。每次购买花费 <span
class="math inline">\(1\)</span>
元钱。现手中没有邮票，求买到所有种类邮票所花费钱数的期望。 考虑 DP。设
<span class="math inline">\(f_x\)</span> 表示已集齐 <span
class="math inline">\(x\)</span> 张时的期望次数。对于第 <span
class="math inline">\(i\)</span> 次购买，有 <span
class="math inline">\(\dfrac{i}{n}\)</span> 的概率买重，<span
class="math inline">\(\dfrac{n-i}{n}\)</span> 的概率不重。 <span
class="math display">\[f_i=1+f_i\times \dfrac{i}{n}+f_{i+1}\times
\dfrac{n-i}{n}\]</span> 化简，得 <span
class="math display">\[f_{i+1}=\dfrac{n}{n-i}-f_i\]</span> ### 例题 3 有
<span class="math inline">\(n\)</span> 个奖品，<span
class="math inline">\(m\)</span>
个人排队选礼物。对于每个人，他打开的盒子可能有礼物，也可能已经被之前的人取走。如果有礼物，取走礼物并放回盒子。求所有人期望取走多少个礼物。
考虑 DP。设 <span class="math inline">\(f_i\)</span> 表示前 <span
class="math inline">\(i\)</span> 个人取走礼物个数的期望，则有 <span
class="math display">\[f_1=1,f_i=f_{i-1}+\dfrac{n-f_{i-1}}{n}\]</span>
或者考虑 <span class="math inline">\(1\)</span> 个礼物被拿走的概率，用
<span class="math inline">\(n\)</span>
乘上它即为答案。一个礼物被一个人拿走的概率为 <span
class="math inline">\(\dfrac{n-1}{n}\)</span>，进行 <span
class="math inline">\(m\)</span> 轮，为 <span
class="math inline">\((\dfrac{n-1}{n})^m\)</span>，则答案为 <span
class="math inline">\(n\times [1-{(\dfrac{n-1}{n})}^m]\)</span>。 ### <a
href="https://www.luogu.com.cn/problem/P1654" title="例题 4">例题 4</a>
假设第 <span class="math inline">\(i\)</span> 位之前有 <span
class="math inline">\(q\)</span> 个连续 <span
class="math inline">\(1\)</span>，则这个位置的贡献为 <span
class="math inline">\((q+1)^3-q^3=3q^2+3q+1\)</span>。 所以我们需要维护
<span class="math inline">\(q\)</span> 和 <span
class="math inline">\(q^2\)</span> 的期望。 <span
class="math display">\[E_i(q)=p_i(E_{i-1}(q)+1)\]</span> <span
class="math display">\[E_i(q^2)=p_i(E_{i-1}(q^2)+2E_{i-1}(q)+1)\]</span>
总式子 <span
class="math display">\[f_i=f_{i-1}+p_i(3E_{i-1}(q^2)+3E_{i-1}(q)+1)\]</span>
已经很详细了就不放代码了。 ### <a
href="https://www.luogu.com.cn/problem/P1850" title="例题 5">例题 5</a>
解决任意两个教室之间的体力消耗最小值，容易想到最短路算法，因本题需要多次查询不同两点间的最短路且
<span class="math inline">\(v\)</span> 较小，考虑使用 Floyd。 之后就是
DP，对每种情况进行分类讨论，设 <span
class="math inline">\(f_{i,j,0/1}\)</span> 表示对于前 <span
class="math inline">\(i\)</span> 门课，选择了 <span
class="math inline">\(j\)</span> 门，最后选择的那门课否/是更换。<span
class="math inline">\(dis_{u,v}\)</span> 表示 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 两点之间的最短路。 那么进行分类讨论
对于 <span
class="math inline">\(f_{i,j,0}\)</span>，若其之前的换了，则有 <span
class="math inline">\(f_{i-1,j,1}+k_{i-1}\times
dis_{d_{i-1},c_i}\)</span>（换成功的期望）<span
class="math inline">\(+(1-k_{i-1})\times
dis_{c_{i-1},c_i}\)</span>（换失败的期望），若之前的没换，则有 <span
class="math inline">\(f_{i-1,j,0}+dis_{c_{i-1},c_i}\)</span>（二者都不换）。
对于 <span class="math inline">\(f_{i,j,1}\)</span>，情况复杂些 -
之前的不换 - 当前换成功 <span class="math inline">\(k_i\times
dis_{c_{i-1},d_i}\)</span> - 当前换失败 <span
class="math inline">\((1-k_i)\times dis_{c_{i-1},c_i}\)</span> -
之前的换 - 之前与当前均成功 <span class="math inline">\(k_{i-1}\times
k_i\times dis_{d_{i-1},d_i}\)</span> - 之前与当前均失败 <span
class="math inline">\((1-k_{i-1})\times (1-k_i)\times
dis_{c_{i-1},c_i}\)</span> - 之前成功当前失败 <span
class="math inline">\(k_{i-1}\times (1-k_i)\times
dis_{d_{i-1},c_i}\)</span> - 之前失败当前成功 <span
class="math inline">\((1-k_{i-1})\times k_i\times
dis_{c_{i-1},d_i}\)</span> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2010</span>,M=<span class="number">90010</span>;</span><br><span class="line"><span class="type">int</span> n,m,v,e;</span><br><span class="line"><span class="type">int</span> c[N],d[N],edge[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"><span class="type">double</span> k[N],dp[<span class="number">2010</span>][<span class="number">2010</span>][<span class="number">2</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(edge,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(edge));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;v,&amp;e);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">			dp[i][j][<span class="number">0</span>]=dp[i][j][<span class="number">1</span>]=<span class="number">1145141919810</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,c+i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,d+i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,k+i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=e;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a,b,w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">		edge[a][b]=<span class="built_in">min</span>(edge[a][b],w);</span><br><span class="line">		edge[b][a]=<span class="built_in">min</span>(edge[b][a],w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=v;i++)</span><br><span class="line">		edge[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k1=<span class="number">1</span>;k1&lt;=v;k1++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=v;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)</span><br><span class="line">				edge[i][j]=<span class="built_in">min</span>(edge[i][j],edge[i][k1]+edge[k1][j]);</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			dp[i][j][<span class="number">0</span>]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+k[i<span class="number">-1</span>]*edge[d[i<span class="number">-1</span>]][c[i]]+</span><br><span class="line">								(<span class="number">1</span>-k[i<span class="number">-1</span>])*edge[c[i<span class="number">-1</span>]][c[i]],</span><br><span class="line">							dp[i<span class="number">-1</span>][j][<span class="number">0</span>]+edge[c[i<span class="number">-1</span>]][c[i]]);</span><br><span class="line">			<span class="keyword">if</span>(j)&#123;</span><br><span class="line">				dp[i][j][<span class="number">1</span>]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+k[i<span class="number">-1</span>]*k[i]*edge[d[i<span class="number">-1</span>]][d[i]]+</span><br><span class="line">									k[i<span class="number">-1</span>]*(<span class="number">1</span>-k[i])*edge[d[i<span class="number">-1</span>]][c[i]]+</span><br><span class="line">									(<span class="number">1</span>-k[i<span class="number">-1</span>])*k[i]*edge[c[i<span class="number">-1</span>]][d[i]]+</span><br><span class="line">									(<span class="number">1</span>-k[i<span class="number">-1</span>])*(<span class="number">1</span>-k[i])*edge[c[i<span class="number">-1</span>]][c[i]],</span><br><span class="line">								dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]+k[i]*edge[c[i<span class="number">-1</span>]][d[i]]+</span><br><span class="line">									(<span class="number">1</span>-k[i])*edge[c[i<span class="number">-1</span>]][c[i]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	ans=<span class="number">1145141919810</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,<span class="built_in">min</span>(dp[n][i][<span class="number">0</span>],dp[n][i][<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### <a
href="https://www.luogu.com.cn/problem/P1297" title="例题 6">例题 6</a>
考虑第 <span class="math inline">\(i\)</span> 道题和第 <span
class="math inline">\(i+1\)</span> 道题。 若 <span
class="math inline">\(a_i=a_{i+1}\)</span>，则本题期望显然为 <span
class="math inline">\(\dfrac{1}{a_i}=\dfrac{1}{a_{i+1}}\)</span>。 若
<span class="math inline">\(a_i&gt;a_{i+1}\)</span>，则 <span
class="math inline">\(a_i\)</span> 的答案在 <span
class="math inline">\(a_{i+1}\)</span> 范围内的概率为 <span
class="math inline">\(\dfrac{a_{i+1}}{a_i}\)</span>，期望为 <span
class="math inline">\(\dfrac{a_{i+1}}{a_i}\times
\dfrac{1}{a_{i+1}}=\dfrac{1}{a_i}\)</span>。 若 <span
class="math inline">\(a_i&lt;a_{i+1}\)</span>，正确答案在 <span
class="math inline">\(a_{i}\)</span> 范围内的概率为 <span
class="math inline">\(\dfrac{a_i}{a_{i+1}}\)</span>，期望为 <span
class="math inline">\(\dfrac{a_i}{a_{i+1}}\times
\dfrac{1}{a_i}=\dfrac{1}{a_{i+1}}\)</span>。 综上，第 <span
class="math inline">\(i\)</span> 道题的期望为 <span
class="math inline">\(\dfrac{1}{\max(a_i,a_{i+1})}\)</span>。求出每题期望累加即可。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>]=a[n];<span class="comment">//第一项的上一个是第n项</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	ans+=<span class="number">1.0</span>/<span class="built_in">max</span>(a[i<span class="number">-1</span>],a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.3lf&quot;</span>,ans);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>珂朵莉树·颜色段均摊</title>
    <url>/2025/07/04/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91%C2%B7%E9%A2%9C%E8%89%B2%E6%AE%B5%E5%9D%87%E6%91%8A/</url>
    <content><![CDATA[<p>这玩意名字也是真多，珂朵莉树，ODT（Old Driver
Tree），颜色段均摊都是它。其实我觉得硬说这是一种数据结构（尤其是“树”）是不恰当的，这更多应该是一种技巧。
与线段树等传统数据结构的区别在于：它可以更方便地维护每个被覆盖区间的值。如模板题中的操作
4：求 <span class="math inline">\(\sum_{i=l}^ra_i^x\bmod y\)</span>。
我很喜欢这个东西，它比线段树好写且在随机数据下表现十分优异。 ### 实现
一般用 <code>std::set</code> 实现。似乎用链表可以省下一个 <span
class="math inline">\(\log\)</span>？不过能用到 ODT
的题应该不差这点时间。 #### 节点 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> l,<span class="type">int</span> r=<span class="number">0</span>,<span class="type">int</span> val=<span class="number">0</span>):<span class="built_in">l</span>(l),<span class="built_in">r</span>(r),<span class="built_in">val</span>(val)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;x.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;node&gt; odt;</span><br></pre></td></tr></table></figure> <span
class="math inline">\(l\)</span> 和 <span
class="math inline">\(r\)</span> 表示这一段的区间，<span
class="math inline">\(val\)</span> 表示这一段的权值，使用
<code>mutable</code> 修饰是为了使得结构体或函数在被 <code>const</code>
修饰后仍能修改 <span class="math inline">\(val\)</span>
的值，这样，我们就可以直接修改在 <code>set</code> 内部的元素的 <span
class="math inline">\(val\)</span>。 #### split 用于将一个区间为 <span
class="math inline">\([l,r]\)</span> 的区间分裂为 <span
class="math inline">\([l,pos)\)</span> 和 <span
class="math inline">\([pos,r]\)</span>，并返回指向后者的迭代器的函数。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">split</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it=odt.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(pos));</span><br><span class="line">    <span class="keyword">if</span>(it!=odt.<span class="built_in">end</span>()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;<span class="comment">//pos已是左端点，无需分割</span></span><br><span class="line">    it--;<span class="comment">//从上一个分割</span></span><br><span class="line">    <span class="type">int</span> l=it-&gt;l,r=it-&gt;r,val=it-&gt;val;</span><br><span class="line">    odt.<span class="built_in">erase</span>(it);<span class="comment">//删除原区间</span></span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,pos<span class="number">-1</span>,val));<span class="comment">//左区间</span></span><br><span class="line">    <span class="keyword">return</span> odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(pos,r,val)).first;<span class="comment">//右区间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>std::set::insert()</code> 返回一个
<code>std::pair&lt;iterator,bool&gt;</code>，表示插入元素的迭代器及插入是否成功。
现代编译器应当都可以将 <code>auto</code> 识别为
<code>std::set&lt;node&gt;::iterator</code>。 #### assign
用于区间赋值。同时也是时间复杂度的保证，以模板题为例，大约 <span
class="math inline">\(\dfrac{1}{4}\)</span> 的操作调用了
<code>assign</code>，而这个操作可以大幅减小 <code>set</code> 的大小。
<strong>特别注意：在截取 <span class="math inline">\([l,r]\)</span>
时一定要先调用 <code>split(r+1)</code> 再调用
<code>split(l)</code>，否则可能导致 RE。</strong> 具体原因可以看<a
href="https://oi-wiki.org/misc/odt/#assign-%E6%93%8D%E4%BD%9C"
title="这里">这里</a>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr=<span class="built_in">split</span>(r<span class="number">+1</span>),itl=<span class="built_in">split</span>(l);<span class="comment">//截取[l,r]</span></span><br><span class="line">    odt.<span class="built_in">erase</span>(itl,itr);<span class="comment">//删除[l,r]</span></span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,r,val));<span class="comment">//插入新值</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### <a
href="https://codeforces.com/problemset/problem/896/C"
title="模板题">模板题</a> 对于 1 操作，3 操作和 4
操作，直接分离出对应区间后暴力求解。2 操作直接用 <code>assign</code>。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> ll val;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> l,<span class="type">int</span> r=<span class="number">0</span>,ll val=<span class="number">0</span>):<span class="built_in">l</span>(l),<span class="built_in">r</span>(r),<span class="built_in">val</span>(val)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;x.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="type">int</span> b,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    a%=mod;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">set&lt;node&gt; odt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">split</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it=odt.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(pos));</span><br><span class="line">    <span class="keyword">if</span>(it!=odt.<span class="built_in">end</span>()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    it--;</span><br><span class="line">    <span class="type">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class="line">    ll val=it-&gt;val;</span><br><span class="line">    odt.<span class="built_in">erase</span>(it);</span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,pos<span class="number">-1</span>,val));</span><br><span class="line">    <span class="keyword">return</span> odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(pos,r,val)).first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr=(<span class="built_in">split</span>(r<span class="number">+1</span>)),itl=<span class="built_in">split</span>(l);</span><br><span class="line">    odt.<span class="built_in">erase</span>(itl,itr);</span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,r,val));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr=<span class="built_in">split</span>(r<span class="number">+1</span>),itl=<span class="built_in">split</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;itl++)</span><br><span class="line">        itl-&gt;val+=val;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">kth</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr=<span class="built_in">split</span>(r<span class="number">+1</span>),itl=<span class="built_in">split</span>(l);</span><br><span class="line">    vector&lt;pair&lt;ll,<span class="type">int</span>&gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;itl++)</span><br><span class="line">        b.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(itl-&gt;val,itl-&gt;r-itl-&gt;l<span class="number">+1</span>));</span><br><span class="line">    <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:b)&#123;</span><br><span class="line">        k-=t.second;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> t.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> itr=<span class="built_in">split</span>(r<span class="number">+1</span>),itl=<span class="built_in">split</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;itl++)</span><br><span class="line">        res=(res+(<span class="built_in">qpow</span>(itl-&gt;val,x,mod)*(itl-&gt;r-itl-&gt;l<span class="number">+1</span>))%mod)%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m,seed,vmax,a[N],op,x,y,l,r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=seed;</span><br><span class="line">    seed=(seed*<span class="number">7ll</span><span class="number">+13</span>)%<span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;seed&gt;&gt;vmax;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=(<span class="built_in">rnd</span>()%vmax)<span class="number">+1</span>;</span><br><span class="line">        odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(i,i,a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        op=(<span class="built_in">rnd</span>()%<span class="number">4</span>)<span class="number">+1</span>;</span><br><span class="line">        l=(<span class="built_in">rnd</span>()%n)<span class="number">+1</span>;</span><br><span class="line">        r=(<span class="built_in">rnd</span>()%n)<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">            <span class="built_in">swap</span>(l,r);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>)</span><br><span class="line">            x=(<span class="built_in">rnd</span>()%(r-l<span class="number">+1</span>))<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x=(<span class="built_in">rnd</span>()%vmax)<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">4</span>)</span><br><span class="line">            y=(<span class="built_in">rnd</span>()%vmax)<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">add</span>(l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">assign</span>(l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)</span><br><span class="line">            cout&lt;&lt;<span class="built_in">kth</span>(l,r,x)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="built_in">sum</span>(l,r,x,y)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <del>十年 OI 一场空，不开 long long 见祖宗。</del> ###
复杂度分析
我们可以从模板题中发现，这玩意除区间赋值外都需要暴力，所以是一种暴力数据结构。对于模板题，均摊时间复杂度
<span class="math inline">\(O(m\log
n)\)</span>。其时间复杂度保证完全依赖于
<code>assign</code>，所以仅适用于数据随机生成且带区间赋值操作的题。比如区间染色问题。
### 参考资料 https://oi-wiki.org/misc/odt/</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数入门</title>
    <url>/2025/07/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="矩阵">矩阵</h3>
<h4 id="运算法则">运算法则</h4>
<h5 id="加法">加法</h5>
<p>两个矩阵 <span class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 相加，要求它们的维度相同。结果矩阵
<span class="math inline">\(C=A+B\)</span> 的每个元素是 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 对应元素的和。<span
class="math inline">\(C_{i,j}=A_{i,j}+B_{i,j}\)</span> ##### 数乘 矩阵
<span class="math inline">\(A\)</span> 与标量 <span
class="math inline">\(k\)</span> 相乘，结果矩阵 <span
class="math inline">\(B=kA\)</span> 的每个元素是 <span
class="math inline">\(A\)</span> 的对应元素乘以 <span
class="math inline">\(k\)</span>。<span
class="math inline">\(B_{i,j}=k\cdot A_{i,j}\)</span> ##### 乘法 矩阵
<span class="math inline">\(A\)</span> 与矩阵 <span
class="math inline">\(B\)</span> 相乘，要求 <span
class="math inline">\(A\)</span> 的列数等于 <span
class="math inline">\(B\)</span> 的行数。结果矩阵 <span
class="math inline">\(C=AB\)</span> 的每个元素是 <span
class="math inline">\(A\)</span> 的行向量与 <span
class="math inline">\(B\)</span> 的列向量的点积。<span
class="math inline">\(C_{i,j}=\sum_{k=1}^nA_{i,k}\cdot B_{k,j}\)</span>
<strong>注意：矩阵乘法不满足交换律</strong> #### 矩阵快速幂
其实和普通快速幂几乎一样。 我们要使用单位矩阵 <span
class="math display">\[I=\begin{bmatrix}
1&amp;0&amp;\cdots&amp;0\\
0&amp;1&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;1
\end{bmatrix}\]</span>
作为初始矩阵。因为它乘任何矩阵还得跟它乘的那个矩阵，类似于 <span
class="math inline">\(1\)</span> 在普通快速幂中的作用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">	<span class="built_in">matrix</span>()&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">	&#125;</span><br><span class="line">	matrix <span class="keyword">operator</span>*(<span class="type">const</span> matrix &amp;b)<span class="type">const</span>&#123;</span><br><span class="line">		matrix res;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">					res.a[i][j]=(res.a[i][j]+a[i][k]*b.a[k][j]%mod)%mod;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;ans,base,a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		base.a[i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">qpow</span><span class="params">(matrix a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">	matrix res=base;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">			res=res*a;</span><br><span class="line">		a=a*a;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a.a[i][j]);</span><br><span class="line">	ans=<span class="built_in">qpow</span>(a,k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans.a[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
#### 矩阵加速线性递推 例如斐波那契数列，<span
class="math inline">\(F_1=F_2=1\)</span>，<span
class="math inline">\(F_i=F_{i-1}+F_{i-2}\)</span>，矩阵递推形式为 <span
class="math display">\[\begin{bmatrix}F_{n-1}&amp;F_{n-2}\end{bmatrix}
\begin{bmatrix}1&amp;1\\
1&amp;0\end{bmatrix}=
\begin{bmatrix}F_n&amp;F_{n-1}\end{bmatrix}\]</span> 则 <span
class="math inline">\(F_n\)</span> 就是 <span
class="math inline">\(\begin{bmatrix}1&amp;1\end{bmatrix}\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^{n-2}\)</span>
的第一行第一列的元素。用矩阵快速幂即可。</p>
<h3 id="高斯消元">高斯消元</h3>
<p>现有线性方程组 <span
class="math display">\[\begin{cases}a_{1,1}x_1+a_{1,2}x_2+\cdots+a_{1,n}x_n=b_1\\
a_{2,1}x_1+a_{2,2}x_2+\cdots+a_{2,n}x_n=b_2\\
\cdots\\
a_{n,1}x_1+a_{n,2}x_2+\cdots+a_{n,n}x_n=b_n
\end{cases}\]</span> 求解该方程组。 为了方便起见，我们用矩阵表示方程组：
<span
class="math display">\[\left[\begin{matrix}a_{1,1}&amp;a_{1,2}&amp;a_{1,3}&amp;\cdots&amp;a_{1,n}\\
a_{2,1}&amp;a_{2,2}&amp;a_{2,3}&amp;\cdots&amp;a_{2,n}\\
a_{3,1}&amp;a_{3,2}&amp;a_{3,3}&amp;\cdots&amp;a_{3,n}\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
a_{n,1}&amp;a_{n,2}&amp;a_{n,3}&amp;\cdots&amp;a_{n,n}
\end{matrix}\middle|
\begin{matrix}
b_{1}\\
b_{2}\\
b_{3}\\
\vdots\\
b_{n}
\end{matrix}\right]\]</span> 首先消去除 <span
class="math inline">\(1\)</span> 式以外所有式子中的 <span
class="math inline">\(x_1\)</span>，然后消去除 <span
class="math inline">\(1\)</span> 式和 <span
class="math inline">\(2\)</span> 式外所有式子中的 <span
class="math inline">\(x_2\)</span>……最后式子变为一个三角形的结构 <span
class="math display">\[\left[\begin{matrix}a_{1,1}&#39;&amp;a_{1,2}&#39;&amp;a_{1,3}&#39;&amp;\cdots&amp;a_{1,n}&#39;\\
0&amp;a_{2,2}&#39;&amp;a_{2,3}&#39;&amp;\cdots&amp;a_{2,n}&#39;\\
0&amp;0&amp;a_{3,3}&#39;&amp;\cdots&amp;a_{3,n}&#39;\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;0&amp;\cdots&amp;a_{n,n}&#39;
\end{matrix}\middle|
\begin{matrix}
b_{1}&#39;\\
b_{2}&#39;\\
b_{3}&#39;\\
\vdots\\
b_{n}&#39;
\end{matrix}\right]\]</span> 之后再一点点代回求解，时间复杂度 <span
class="math inline">\(O(n^3)\)</span>。 对于无解的判断：某一行前 <span
class="math inline">\(n\)</span> 个数均为 <span
class="math inline">\(0\)</span>，最后的结果却不为 <span
class="math inline">\(0\)</span>。 对于无数解的判断：某一行 <span
class="math inline">\(n+1\)</span> 个数均为 <span
class="math inline">\(0\)</span>。 <a
href="https://www.luogu.com.cn/problem/P3389" title="模板">模板</a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="type">int</span> r=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(matrix[r][i])&lt;<span class="built_in">fabs</span>(matrix[j][i]))</span><br><span class="line">			r=j;<span class="comment">//寻找主元 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(matrix[r][i])&lt;eps)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;No Solution&quot;</span>);<span class="comment">//若主元为0，方程组无解或无穷多解 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i!=r)</span><br><span class="line">		<span class="built_in">swap</span>(matrix[i],matrix[r]);</span><br><span class="line">	<span class="type">double</span> div=matrix[i][i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n<span class="number">+1</span>;j++)</span><br><span class="line">		matrix[i][j]/=div;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">		div=matrix[j][i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=n<span class="number">+1</span>;k++)</span><br><span class="line">			matrix[j][k]-=matrix[i][k]*div;</span><br><span class="line">	&#125;<span class="comment">//消元</span></span><br><span class="line">&#125;</span><br><span class="line">ans[n]=matrix[n][n<span class="number">+1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i;i--)&#123;</span><br><span class="line">	ans[i]=matrix[i][n<span class="number">+1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">		ans[i]-=matrix[i][j]*ans[j];</span><br><span class="line">&#125;<span class="comment">//回代</span></span><br></pre></td></tr></table></figure> <a href="https://www.luogu.com.cn/problem/P2455"
title="加强版">加强版</a> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="type">int</span> pivot=rank1<span class="number">+1</span>;<span class="comment">//rank1为矩阵的秩 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=rank1<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(matrix[pivot][i])&lt;<span class="built_in">fabs</span>(matrix[j][i]))</span><br><span class="line">			pivot=j;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(matrix[pivot][i])&lt;eps)</span><br><span class="line">		<span class="keyword">continue</span>;<span class="comment">//全为零</span></span><br><span class="line">	<span class="keyword">if</span>(pivot!=rank1<span class="number">+1</span>)</span><br><span class="line">		<span class="built_in">swap</span>(matrix[pivot],matrix[rank1<span class="number">+1</span>]);</span><br><span class="line">	<span class="type">double</span> div=matrix[rank1<span class="number">+1</span>][i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n<span class="number">+1</span>;j++)</span><br><span class="line">		matrix[rank1<span class="number">+1</span>][j]/=div;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==rank1<span class="number">+1</span>||<span class="built_in">fabs</span>(matrix[j][i])&lt;eps)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		div=matrix[j][i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=n<span class="number">+1</span>;k++)</span><br><span class="line">			matrix[j][k]-=matrix[rank1<span class="number">+1</span>][k]*div;</span><br><span class="line">	&#125;<span class="comment">//消元</span></span><br><span class="line">	rank1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=rank1<span class="number">+1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(matrix[i][n<span class="number">+1</span>])&gt;eps)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//无解</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">if</span>(rank1&lt;n)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//无数解</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)&#123;</span><br><span class="line">	ans[i]=matrix[i][n<span class="number">+1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">		ans[i]-=matrix[i][j]*ans[j];</span><br><span class="line">&#125;<span class="comment">//回代</span></span><br></pre></td></tr></table></figure> ### 高斯-约旦消元 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,line=<span class="number">1</span>,cur;i&lt;=n;i++)&#123;</span><br><span class="line">    cur=line;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=line<span class="number">+1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i])&gt;<span class="built_in">fabs</span>(a[cur][i]))</span><br><span class="line">            cur=j;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[cur][i])&lt;eps) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">double</span> temp=a[cur][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n<span class="number">+1</span>;j++)</span><br><span class="line">        <span class="built_in">swap</span>(a[cur][j],a[line][j]),a[line][j]/=temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">if</span>(j!=line)&#123;</span><br><span class="line">            temp=a[j][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">+1</span>;k++)</span><br><span class="line">                a[j][k]-=a[line][k]*temp;</span><br><span class="line">        &#125;</span><br><span class="line">    ++line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### 线性基 引入：有 <span class="math inline">\(n\)</span>
个数，选出其中任意一些数，求其异或和，一共有多少种可能的异或值。 ####
性质 1. 原序列里面的任意一个数都可以表示为线性基的一个子集的异或和。 1.
线性基任意一个子集的异或和都不能等于 <span
class="math inline">\(0\)</span>。 1.
线性基里面的数的个数唯一，并且在保持性质 1 的前提下，数的个数是最少的。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LBase</span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> d[<span class="number">61</span>];</span><br><span class="line">	<span class="built_in">LBase</span>()&#123;</span><br><span class="line">		<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(x&amp;<span class="number">1ll</span>&lt;&lt;i)&#123;</span><br><span class="line">				<span class="keyword">if</span>(d[i])</span><br><span class="line">					x^=d[i];</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					d[i]=x;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query_max</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> x=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">			<span class="keyword">if</span>(d[i]&amp;&amp;(x^d[i])&gt;x)</span><br><span class="line">				x^=d[i];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> LBase &amp;a)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">			<span class="keyword">if</span>(a.d[i])</span><br><span class="line">				<span class="built_in">insert</span>(a.d[i]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>组合</title>
    <url>/2025/07/04/%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h3 id="排列组合的定义">排列组合的定义</h3>
<h4 id="排列">排列</h4>
<p>从 <span class="math inline">\(n\)</span> 个不同元素中，任取 <span
class="math inline">\(m\)</span>
个不同的元素按照一定的顺序排成一列，所有可能的情况种数叫做排列数，记作
<span class="math inline">\(A_n^m\)</span>。 <span
class="math display">\[A_n^m=\frac{n!}{(n-m)!}\]</span> #### 组合 从
<span class="math inline">\(n\)</span> 个不同元素中，任取 <span
class="math inline">\(m\)</span>
个元素并成一组，所有可能的情况种数叫做组合数，记作 <span
class="math inline">\(C_n^m\)</span>，也记作 <span
class="math inline">\(\dbinom{n}{m}\)</span> <span
class="math display">\[C_n^m=\binom{n}{m}=\frac{A_n^m}{m!}=\frac{n!}{m!(n-m)!}\]</span>
对于二者的区别最直观的理解就前者考虑顺序，而后者不考虑。 #### 加法原理
做一件事，完成它可以有 <span class="math inline">\(n\)</span>
类方法，在第一类方法中有 <span class="math inline">\(m_1\)</span>
种不同方法，在第二类方法中有 <span class="math inline">\(m_2\)</span>
种不同方法，……，在第 <span class="math inline">\(n\)</span> 类方法中有
<span class="math inline">\(m_n\)</span> 种不同方法，那么完成这件事共有
<span class="math inline">\(\sum_{i=1}^n m_i\)</span> 种不同的方法。
#### 乘法原理 做一件事，完成它需要分成 <span
class="math inline">\(n\)</span> 个步骤，做第一步有 <span
class="math inline">\(m_1\)</span> 种不同的方法，做第二步有 <span
class="math inline">\(m_2\)</span> 种不同的方法，……，做第 <span
class="math inline">\(n\)</span> 步有 <span
class="math inline">\(m_n\)</span> 种不同的方法。那么完成这件事共有
<span class="math inline">\(\prod_{i=1}^n m_i\)</span> 种不同的方法。
### 二项式定理 <span
class="math display">\[(a+b)^n=\sum_{i=0}^n\binom{n}{i}a^ib^{n-i}\]</span>
变形： <span
class="math display">\[(a-b)^n=\sum_{i=0}^n(-1)^{n-i}\binom{n}{i}a^ib^{n-i}\]</span>
<span
class="math display">\[\frac{(a+b)^n+(a-b)^n}{2}=\sum_{i为偶数}^n\binom{n}{i}a^{n-i}b^i\]</span>
性质： -
杨辉三角与二项式系数有对应关系，所以根据杨辉三角的性质，我们可以得到递推关系：<span
class="math inline">\(\dbinom{n}{k}=\dbinom{n-1}{k}+\dbinom{n-1}{k-1}\)</span>。
- 在 <span class="math inline">\(n\)</span> 个里面选 <span
class="math inline">\(k\)</span> 个，就相当于不选 <span
class="math inline">\(n-k\)</span> 个，这与选 <span
class="math inline">\(n-k\)</span> 个相等，<span
class="math inline">\(\dbinom{n}{k}=\dbinom{n}{n-k}\)</span>。 - 令
<span class="math inline">\(a=b=1\)</span>，<span
class="math inline">\(2^n=\sum_{i=0}^n\dbinom{n}{i}\)</span>。 - <span
class="math inline">\(\sum_{i为奇数}\dbinom{n}{i}=\sum_{i为偶数}\dbinom{n}{i}=2^{n-1}\)</span>
### 快速计算组合数的方法 - 预处理逆元，定义法计算 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		fact[i]=fact[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv_fact[n]=<span class="built_in">qpow</span>(fact[n],mod<span class="number">-2</span>,mod);<span class="comment">//费马小定理，当然也可以用其他方式</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		inv_fact[i]=inv_fact[i<span class="number">+1</span>]*(i<span class="number">+1</span>)%mod;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">comb</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fact[n]*inv_fact[k]%mod*inv_fact[n-k]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> -
将杨辉三角打表 - 模数较小的时候使用 Lucas 定理和 exLucas 定理 Lucas 定理
<span class="math inline">\(\dbinom{n}{k}=\dbinom{n\bmod p}{k\bmod
p}\times
\dbinom{\lfloor\frac{n}{p}\rfloor}{\lfloor\frac{k}{p}\rfloor}\)</span>，可以持续展开。<strong>注意，<span
class="math inline">\(p\)</span> 必须是质数</strong>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">	a%=mod;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">			res=res*a%mod;</span><br><span class="line">		a=a*a%mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m&gt;n)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(m&gt;n-m)</span><br><span class="line">		m=n-m;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		a=(a*(n-i))%p;</span><br><span class="line">		b=(b*(i<span class="number">+1</span>))%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a*<span class="built_in">qpow</span>(b,p<span class="number">-2</span>,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">lucas</span>(n/p,m/p,p)*<span class="built_in">C</span>(n%p,m%p,p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ###
范德蒙德卷积 <span
class="math display">\[\sum_{i=0}^k\binom{n}{i}\binom{m}{k-i}=\binom{n+m}{k}\]</span>
组合意义：在一个大小为 <span class="math inline">\(n+m\)</span>
的集合中取出 <span class="math inline">\(k\)</span>
个数，可以等于把大小为 <span class="math inline">\(n+m\)</span>
的集合拆成两个集合，大小分别为 <span class="math inline">\(n\)</span> 与
<span class="math inline">\(m\)</span>，然后从 <span
class="math inline">\(n\)</span> 中取出 <span
class="math inline">\(i\)</span> 个数，从 <span
class="math inline">\(m\)</span> 中取出 <span
class="math inline">\(k-i\)</span> 个数的方案数。由于我们有了对于 <span
class="math inline">\(i\)</span>
的枚举，于是只需要考虑一种拆法，因为不同的拆法之间是等价的。 变式： -
<span
class="math inline">\(\sum_{i=1}^n\dbinom{n}{i}\dbinom{n}{n-1}=\dbinom{2n}{n-1}\)</span>
- <span
class="math inline">\(\sum_{i=0}^n{\dbinom{n}{i}}^2=\dbinom{2n}{n}\)</span>
- <span
class="math inline">\(\sum_{i=0}^m\dbinom{n}{i}\dbinom{m}{i}=\dbinom{n+m}{m}\)</span>
### 隔板法 模型一：将 <span class="math inline">\(n\)</span>
个相同苹果放入 <span class="math inline">\(m\)</span>
个不同的箱子里的方案数（可以限制是否为空）。 考虑箱子里至少放 <span
class="math inline">\(1\)</span> 个苹果的情况，将这 <span
class="math inline">\(n\)</span> 个苹果排成一列，形成 <span
class="math inline">\(n-1\)</span> 个空隙，在这 <span
class="math inline">\(n-1\)</span> 个空隙中插入 <span
class="math inline">\(m-1\)</span> 个板子，就形成了一种解。所以解为
<span class="math inline">\(\dbinom{n-1}{m-1}\)</span>。
箱子可以为空时解为 <span
class="math inline">\(\dbinom{n-1+m}{m-1}\)</span>，假设每个箱子里多出了一个虚拟苹果，我们就又回到了刚才的问题。
模型二：求方程 <span class="math inline">\(x_1+x_2+\cdots+x_m=n\)</span>
的正整数解或自然数解的方案数。 变式：上式中 <span
class="math inline">\(=\)</span> 变为 <span
class="math inline">\(\le\)</span> 或 <span
class="math inline">\(&lt;\)</span>，我们可以虚拟一个 <span
class="math inline">\(x_0\)</span> 令其加上后面的 <span
class="math inline">\(x\)</span> 等于 <span
class="math inline">\(n\)</span>。 ### 一些模型 #### 可重组合 有 <span
class="math inline">\(m\)</span> 种球，每种球足够多，<span
class="math inline">\(n\)</span>
个相同的盒子，一种球可以用多次，把盒子塞满，有多少种方案？<span
class="math display">\[\binom{m+n-1}{m}\]</span> #### 不相邻组合 有
<span class="math inline">\(m\)</span> 个球，<span
class="math inline">\(n\)</span>
个盒子，选出的球不能相邻，有多少种组合方式？<span
class="math display">\[\binom{n-m+1}{m}\]</span> #### 格路模型
从坐标原点走到 <span
class="math inline">\((n,m)\)</span>，每次只能向右或向上移动，方案数是<span
class="math display">\[\binom{n+m}{n}=\binom{n+m}{m}\]</span> ###
容斥原理 引入：有 <span class="math inline">\(n\)</span> 个人，都参加过
WC、CTSC 和 APIO。问拿过至少一个比赛金牌的有多少人。 首先我们定义 <span
class="math inline">\(3\)</span> 个集合 <span
class="math inline">\(A\)</span>，<span
class="math inline">\(B\)</span>，<span
class="math inline">\(C\)</span>，分别表示在这三个比赛中拿过金牌的人，显然我们可以画出
Venn 图 <img
src="https://github.com/headless-piston/blog_images/blob/main/inclusion-exclusion.png?raw=true"
alt="image" /> 首先，我们把 <span
class="math inline">\(A\)</span>，<span
class="math inline">\(B\)</span>，<span class="math inline">\(C\)</span>
的元素数相加，显然多算了集合之间的交集，然后我们减去 <span
class="math inline">\(A\cap B\)</span>，<span
class="math inline">\(B\cap C\)</span>，<span
class="math inline">\(A\cap C\)</span> 的元素数，我们发现多减了 <span
class="math inline">\(A\cap B\cap C\)</span>，再把它加回去，
总的式子就是<span class="math display">\[|A\cup B\cup
C|=|A|+|B|+|C|-|A\cap B|-|B\cap C|-|A\cap C|+|A\cap B\cap C|\]</span>
将这个规律推广，也类似这样一加一减交替，这就是容斥原理。 ### 斯特林数
#### 第二类斯特林数 表示将 <span class="math inline">\(n\)</span>
个两两不同的元素，划分为 <span class="math inline">\(k\)</span>
个互不区分的非空子集的方案数。记作 <span
class="math inline">\(S(n,k)\)</span>， 递推式 <span
class="math display">\[S(n,k)=S(n−1,k−1)+k⋅S(n−1,k)\]</span> 边界条件：
- <span
class="math inline">\(S(n,n)=1\)</span>（每个元素单独成一个子集）。 -
<span
class="math inline">\(S(n,1)=1\)</span>（所有元素放在一个子集中）。 -
<span class="math inline">\(S(n,k)=0\)</span> 当 <span
class="math inline">\(k&gt;n\)</span> 或 <span
class="math inline">\(k=0\)</span> 且 <span
class="math inline">\(n&gt;0\)</span>。 #### 第一类斯特林数 示将 <span
class="math inline">\(n\)</span> 个两两不同的元素，划分为 <span
class="math inline">\(k\)</span> 个互不区分的非空轮换的方案数。记作
<span class="math inline">\(s(n,k)\)</span>，递推式 <span
class="math display">\[s(n,k)=s(n−1,k−1)+(n−1)⋅s(n−1,k)\]</span>
边界条件； - <span
class="math inline">\(s(n,n)=1\)</span>（每个元素单独成一个轮换）。 -
<span
class="math inline">\(s(n,1)=(n-1)!\)</span>（所有元素放在一个轮换中）。
- <span class="math inline">\(s(n,0)=0\)</span> 当 <span
class="math inline">\(n&gt;0\)</span>。 ### 卡特兰数 -
一个栈（无穷大）的进栈序列为 <span class="math inline">\(1,2,3, \cdots
,n\)</span> 有多少个不同的出栈序列？ - 有一个大小为 <span
class="math inline">\(n\times n\)</span> 的方格图左下角为 <span
class="math inline">\((0, 0)\)</span> 右上角为 <span
class="math inline">\((n,
n)\)</span>，从左下角开始每次都只能向右或者向上走一单位，不走到对角线
<span class="math inline">\(y=x\)</span>
上方（但可以触碰）的情况下到达右上角有多少可能的路径？ - 由 <span
class="math inline">\(n\)</span> 对括号组成的合法序列的数量。</p>
<p>这些问题的答案都是卡特兰数列 <span
class="math inline">\(H_n\)</span>。 公式： <span
class="math display">\[H_n=\frac{\binom{2n}{n}}{n+1}\]</span> <span
class="math display">\[H_n=\binom{2n}{n}-\binom{2n}{n-1}\]</span> 边界：
<span
class="math display">\[H_0=H_1=1,H_2=2,H_3=5,H_4=14,\cdots\]</span></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流</title>
    <url>/2025/07/04/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<h3 id="定义">定义</h3>
<p>网络是有向图的一种，不同于其他有向图，一个网络有两个特殊的点<strong>源点（一般记作
<span
class="math inline">\(s\)</span>）</strong>和<strong>汇点（一般记作
<span
class="math inline">\(t\)</span>）</strong>，顾名思义，源点只有出边而汇点只有入边。同时，每条边有边权
<span
class="math inline">\(c\)</span>，表示<strong>容量</strong>，同时还映射一个值
<span
class="math inline">\(flow\)</span>，叫做<strong>流量</strong>。一种容易的理解方式是将边想象成不同大小的管道。值得注意的是，流量可以为负，这一般表示反向流动以及在一些算法中对先前流量分配的“撤销”。
残量网络：将容量已满的边删去，剩下的边构成的图就是残量网络。
增广路：从源点到汇点的一条路径，其中每条边都有剩余容量。 ### 最大流问题
对于一个网络，找到最大的流量。 ### 最小割问题
我们将网络上的一些边进行分割，使之分为两部分，一部分包含 <span
class="math inline">\(s\)</span>，另一部分包含 <span
class="math inline">\(t\)</span>，所有切割的边的容量和叫做网络的最小割。
例：现有网络</p>
<figure>
<img
src="https://github.com/headless-piston/blog_images/blob/main/network-flows_1.png?raw=true"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>其最小割为</p>
<figure>
<img
src="https://github.com/headless-piston/blog_images/blob/main/network-flows_2.png?raw=true"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>即 <span class="math inline">\(3=2+1\)</span>。 ### 最大流最小割定理
对于一个网络，最大流总等于最小割。这个定理看似显然，实则并不好证。<a
href="https://oi-wiki.org/graph/flow/max-flow/#%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E5%AE%9A%E7%90%86"
title="证明">证明</a>。</p>
<hr />
<p>接下来以<a href="https://www.luogu.com.cn/problem/P3376"
title="最大流模板题">最大流模板题</a>为例讲解一些算法。 ### Edmonds-Karp
算法 流程： - 从 <span class="math inline">\(s\)</span> 出发进行 BFS
尝试走到 <span class="math inline">\(t\)</span>，即寻找增广路。 -
找到增广路后计算增广路上剩余容量的最小值 <span
class="math inline">\(f\)</span>，给增广路上每条边加上 <span
class="math inline">\(f\)</span> 容量，并将它们的反向边退掉 <span
class="math inline">\(f\)</span> 容量。 -
在新图上重复以上操作直到增广路不存在。</p>
<p>时间复杂度 <span class="math inline">\(O(nm^2)\)</span>。
关于反向边，有个小技巧，就是直接将正反两边的编号设为 <span
class="math inline">\(2n\)</span> 和 <span
class="math inline">\(2n+1\)</span>，这样可以通过异或 <span
class="math inline">\(1\)</span> 的操作快速完成正反边的转换。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e18</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">210</span>,M=<span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> head[N],tot=<span class="number">1</span>;<span class="comment">//因为要异或1所以初始化为1</span></span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line"><span class="type">int</span> pre[N];<span class="comment">//路径的前驱节点</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> flow[N];<span class="comment">//各边剩余容量最小值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> c;<span class="comment">//剩余容量</span></span><br><span class="line">&#125;e[M*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> flag[N][N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> c)</span></span>&#123;</span><br><span class="line">	e[++tot].to=v;</span><br><span class="line">	e[tot].c=c;</span><br><span class="line">	e[tot].nxt=head[u];</span><br><span class="line">	head[u]=tot;<span class="comment">//正向边</span></span><br><span class="line">	e[++tot].to=u;</span><br><span class="line">	e[tot].c=<span class="number">0</span>;</span><br><span class="line">	e[tot].nxt=head[v];</span><br><span class="line">	head[v]=tot;<span class="comment">//反向边</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	pre[s]=s;</span><br><span class="line">	flow[s]=inf;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(e[i].c==<span class="number">0</span>||pre[v])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			flow[v]=<span class="built_in">min</span>(flow[u],e[i].c);</span><br><span class="line">			pre[v]=i;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">			<span class="keyword">if</span>(v==t)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		<span class="keyword">if</span>(!flag[u][v])&#123;<span class="comment">//去重边</span></span><br><span class="line">			<span class="built_in">add_edge</span>(u,v,w);</span><br><span class="line">			flag[u][v]=tot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			e[flag[u][v]^<span class="number">1</span>].c+=w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u=t;u!=s;u=e[pre[u]^<span class="number">1</span>].to)&#123;</span><br><span class="line">			e[pre[u]].c-=flow[t];</span><br><span class="line">			e[pre[u]^<span class="number">1</span>].c+=flow[t];</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=flow[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### Dinic 算法 个人认为这个更难理解一些。 流程： -
在残量网络中进行 BFS 构建分层图。 - 使用 DFS，每次找到 <span
class="math inline">\(t\)</span> 后直接回溯更新边权。</p>
<p>使用分层图的原因是因为分层图是 DAG，进行 DFS
时不会走回头路或环路，保证了算法的正确性和高效性。 时间复杂度 <span
class="math inline">\(O(n^2m)\)</span>，优于 Edmonds-Karp 算法。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e18</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">210</span>,M=<span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,t,tot=<span class="number">1</span>,head[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> c;</span><br><span class="line">&#125;e[M*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> c)</span></span>&#123;</span><br><span class="line">	e[++tot].to=v;</span><br><span class="line">	e[tot].c=c;</span><br><span class="line">	e[tot].nxt=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	e[++tot].to=u;</span><br><span class="line">	e[tot].c=<span class="number">0</span>;</span><br><span class="line">	e[tot].nxt=head[v];</span><br><span class="line">	head[v]=tot;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> level[N];<span class="comment">//层级</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(level,<span class="number">-1</span>,<span class="built_in">sizeof</span>(level));</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	level[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(e[i].c==<span class="number">0</span>||level[v]!=<span class="number">-1</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			level[v]=level[u]<span class="number">+1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> level[t]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">long</span> <span class="type">long</span> flow)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==t)</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(e[i].c==<span class="number">0</span>||level[v]!=level[u]<span class="number">+1</span>)<span class="comment">//按层dfs</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> temp=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(flow-res,e[i].c));</span><br><span class="line">		e[i].c-=temp;</span><br><span class="line">		e[i^<span class="number">1</span>].c+=temp;</span><br><span class="line">		res+=temp;</span><br><span class="line">		<span class="keyword">if</span>(res==flow)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(res==<span class="number">0</span>)</span><br><span class="line">		level[u]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		<span class="built_in">add_edge</span>(u,v,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">		ans+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 优化：当前弧优化。减少 DFS
对边的重复检查。若某边剩余容量已为 <span
class="math inline">\(0\)</span>，则不再处理这条边。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">int</span> cur[N];<span class="comment">//当前弧优化</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">long</span> <span class="type">long</span> flow)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==t)</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=e[i].nxt)&#123;</span><br><span class="line">		cur[u]=i;<span class="comment">//当前弧优化</span></span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(e[i].c==<span class="number">0</span>||level[v]!=level[u]<span class="number">+1</span>)<span class="comment">//按层dfs</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> temp=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(flow-res,e[i].c));</span><br><span class="line">		e[i].c-=temp;</span><br><span class="line">		e[i^<span class="number">1</span>].c+=temp;</span><br><span class="line">		res+=temp;</span><br><span class="line">		<span class="keyword">if</span>(res==flow)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(res==<span class="number">0</span>)</span><br><span class="line">		level[u]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));<span class="comment">//重置当前弧</span></span><br><span class="line">	ans+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure> ###
最小费用最大流
费用流定义：对于一个网络的每条边，我们再加一个边权称为一个单位流量的费用，记作
<span class="math inline">\(w(u,v)\)</span>，则这条边的费用为 <span
class="math inline">\(f(u,v)\times
w(u,v)\)</span>。与上文中提到的反向边回退流量相同，费用也可以这样操作。
与普通最大流问题不同，最小费用最大流的求解过程不用 BFS
而用最短路算法寻找增广路，这样就保证了最小费用。 这里给出 Edmonds-Karp +
SPFA 的做法。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span><span class="number">+10</span>,M=<span class="number">5e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt,c,w;</span><br><span class="line">&#125;e[M*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,head[N],n,m,s,t;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> c,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	e[++tot].to=v;</span><br><span class="line">	e[tot].nxt=head[u];</span><br><span class="line">	e[tot].c=c;</span><br><span class="line">	e[tot].w=w;</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	e[++tot].to=u;</span><br><span class="line">	e[tot].nxt=head[v];</span><br><span class="line">	e[tot].c=<span class="number">0</span>;</span><br><span class="line">	e[tot].w=-w;</span><br><span class="line">	head[v]=tot;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> min_flow[N],dis[N],pre[N],flow,cost;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(min_flow,<span class="number">0</span>,<span class="built_in">sizeof</span>(min_flow));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	vis[s]=<span class="number">1</span>;</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	min_flow[s]=<span class="number">2e9</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,c=e[i].c,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(c&amp;&amp;dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">				dis[v]=dis[u]+w;</span><br><span class="line">				pre[v]=i;</span><br><span class="line">				min_flow[v]=<span class="built_in">min</span>(min_flow[u],c);</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					vis[v]=<span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min_flow[t]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v,c,w;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;c&gt;&gt;w;</span><br><span class="line">		<span class="built_in">add_edge</span>(u,v,c,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">		<span class="type">int</span> minf=min_flow[t];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=t;i!=s;i=e[pre[i]^<span class="number">1</span>].to)&#123;</span><br><span class="line">			e[pre[i]].c-=minf;</span><br><span class="line">			e[pre[i]^<span class="number">1</span>].c+=minf;</span><br><span class="line">		&#125;</span><br><span class="line">		flow+=minf;</span><br><span class="line">		cost+=minf*dis[t];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;flow&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;cost;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 网络流建模 <a
href="https://www.luogu.com.cn/problem/P3356" title="例题">例题</a></p>
<p>考虑拆点。将点 <span class="math inline">\((x,y)\)</span> 拆为 <span
class="math inline">\((x,y)_1\)</span> 和 <span
class="math inline">\((x,y)_2\)</span>。 对于 <span
class="math inline">\(0\)</span>（平坦无障碍），建 <span
class="math inline">\((x,y)_1\to(x,y)_2\)</span>，容量 <span
class="math inline">\(inf\)</span>，费用 <span
class="math inline">\(0\)</span>，表示可以无限通过但无收益。同时，建
<span class="math inline">\((x,y)_2\to(x+1,y)_1\)</span> 和 <span
class="math inline">\((x,y)_2\to(x,y+1)_1\)</span>，容量与费用同上，表示向南和向东走。
对于 <span class="math inline">\(1\)</span>（障碍），不建立节点。 对于
<span class="math inline">\(2\)</span>（石块），先建 <span
class="math inline">\(0\)</span>（平坦无障碍）的 <span
class="math inline">\(3\)</span> 条边，然后再建一条 <span
class="math inline">\((x,y)_1\to(x,y)_2\)</span>，容量 <span
class="math inline">\(1\)</span>，费用 <span
class="math inline">\(1\)</span>，表示只能走 <span
class="math inline">\(1\)</span> 次且贡献为 <span
class="math inline">\(1\)</span>。 然后跑最大费用最大流就可以了。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2e9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">35</span>*<span class="number">35</span>*<span class="number">2</span><span class="number">+10</span>,M=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> p,q,nodecnt,node[N][N],tot=<span class="number">1</span>,head[N],n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt,c,w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> c,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	e[++tot].to=v;</span><br><span class="line">	e[tot].nxt=head[u];</span><br><span class="line">	e[tot].c=c;</span><br><span class="line">	e[tot].w=w;</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> c,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="built_in">add_edge1</span>(u,v,c,w);</span><br><span class="line">	<span class="built_in">add_edge1</span>(v,u,<span class="number">0</span>,-w);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pre[N],dis[N],s,t,flow[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(flow,<span class="number">0</span>,<span class="built_in">sizeof</span>(flow));</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	vis[s]=<span class="number">1</span>;</span><br><span class="line">	flow[s]=inf;</span><br><span class="line">	que.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		vis[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,c=e[i].c,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(c&amp;&amp;dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">				dis[v]=dis[u]+w;</span><br><span class="line">				pre[v]=i;</span><br><span class="line">				flow[v]=<span class="built_in">min</span>(flow[u],c);</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					vis[v]=<span class="number">1</span>;</span><br><span class="line">					que.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow[t]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;p&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=p;j++)</span><br><span class="line">			node[i][j]=++nodecnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,c;i&lt;=q;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=p;j++)&#123;</span><br><span class="line">			cin&gt;&gt;c;</span><br><span class="line">			<span class="keyword">if</span>(c==<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">add_edge</span>(node[i][j],node[i][j]+nodecnt,inf,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(c==<span class="number">2</span>)</span><br><span class="line">				<span class="built_in">add_edge</span>(node[i][j],node[i][j]+nodecnt,<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span>(i&lt;q)</span><br><span class="line">				<span class="built_in">add_edge</span>(node[i][j]+nodecnt,node[i<span class="number">+1</span>][j],inf,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(j&lt;p)</span><br><span class="line">				<span class="built_in">add_edge</span>(node[i][j]+nodecnt,node[i][j<span class="number">+1</span>],inf,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s=<span class="number">0</span>,t=nodecnt*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">	<span class="built_in">add_edge</span>(s,node[<span class="number">1</span>][<span class="number">1</span>],n,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">add_edge</span>(node[q][p]+nodecnt,t,n,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">		<span class="type">int</span> minf=flow[t];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=t,cnt=<span class="number">0</span>;i!=s;i=e[pre[i]^<span class="number">1</span>].to,cnt++)&#123;</span><br><span class="line">			e[pre[i]].c-=minf;</span><br><span class="line">			e[pre[i]^<span class="number">1</span>].c+=minf;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=p;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=head[node[i][j]];k;k=e[k].nxt)&#123;</span><br><span class="line">				<span class="type">int</span> v=e[k].to;</span><br><span class="line">				<span class="keyword">if</span>(v==node[i][j]+nodecnt)</span><br><span class="line">					cnt[i][j]+=e[k^<span class="number">1</span>].c;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="number">1</span>,y=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(x!=q||y!=p)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cnt[x<span class="number">+1</span>][y])&#123;</span><br><span class="line">				cout&lt;&lt;i&lt;&lt;<span class="string">&quot; 0\n&quot;</span>;</span><br><span class="line">				cnt[x<span class="number">+1</span>][y]--;</span><br><span class="line">				x++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				cout&lt;&lt;i&lt;&lt;<span class="string">&quot; 1\n&quot;</span>;</span><br><span class="line">				cnt[x][y<span class="number">+1</span>]--;</span><br><span class="line">				y++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 其他 参考资料：</p>
<p><a href="https://oi-wiki.org/graph/flow/max-flow/" title="OI Wiki">OI
Wiki</a></p>
<p><a href="https://www.luogu.com.cn/article/ei4nw9cm"
title="题解 P3376 【【模板】网络最大流】">题解 P3376
【【模板】网络最大流】</a></p>
<p><a href="https://www.luogu.com.cn/article/k6hmo167"
title="【题解】P3356 火星探险问题">【题解】P3356 火星探险问题</a></p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>自我介绍</title>
    <url>/2025/07/04/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>HE 高二 OIer。没实力还爱狗叫。贺题解高手。文化课菜逼。
<strong>我真不是二次元！</strong></p>
<hr />
<p>Welcome to my blog!<br />
欢迎大家阅读文章，如文章有错误之处请联系我进行修正。</p>
]]></content>
  </entry>
  <entry>
    <title>莫队</title>
    <url>/2025/07/04/%E8%8E%AB%E9%98%9F/</url>
    <content><![CDATA[<h3 id="引入">引入</h3>
<p>莫队的实现依赖于离线，将查询操作记录下来并按一定规则排序，然后使用双指针暴力求解答案，是一种<strong>优雅的暴力</strong>。
关于离线思想，可以做<a href="https://www.luogu.com.cn/problem/P1972"
title="这一道题">这一道题</a>体验一下。<del>（但是这题卡莫队）</del> ###
例题 所以看这题的<a href="https://www.luogu.com.cn/problem/SP3267"
title="弱化版">弱化版</a>。
莫队的关键在于优化了暴力枚举的顺序，联系分块思想，将长度为 <span
class="math inline">\(n\)</span> 的原序列分成长为 <span
class="math inline">\(\sqrt{n}\)</span>
的块，以<strong>区间左端点所在的块的编号</strong>为第一关键字，<strong>区间右端点</strong>为第二关键字升序排序。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,id;</span><br><span class="line">&#125;query[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Query x,Query y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> belong[x.l]==belong[y.l]?x.r&lt;y.r:belong[x.l]&lt;belong[y.l];</span><br><span class="line">&#125;<span class="comment">//一定注意左端点要belong[]而右端点不用</span></span><br></pre></td></tr></table></figure> 对答案的获取，我们每次从区间 <span
class="math inline">\([l,r]\)</span> 移动到 <span
class="math inline">\([l-1,r]\)</span>，<span
class="math inline">\([l+1,r]\)</span>，<span
class="math inline">\([l,r-1]\)</span> 和 <span
class="math inline">\([l,r+1]\)</span>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b[a[x]])</span><br><span class="line">        now++;</span><br><span class="line">    b[a[x]]++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    b[a[x]]--;</span><br><span class="line">    <span class="keyword">if</span>(!b[a[x]])</span><br><span class="line">        now--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">l=<span class="number">1</span>,r=<span class="number">0</span>,now=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(r&lt;query[i].r)</span><br><span class="line">        <span class="built_in">add</span>(++r);</span><br><span class="line">    <span class="keyword">while</span>(r&gt;query[i].r)</span><br><span class="line">        <span class="built_in">del</span>(r--);</span><br><span class="line">    <span class="keyword">while</span>(l&lt;query[i].l)</span><br><span class="line">        <span class="built_in">del</span>(l++);</span><br><span class="line">    <span class="keyword">while</span>(l&gt;query[i].l)</span><br><span class="line">        <span class="built_in">add</span>(--l);</span><br><span class="line">    ans[query[i].id]=now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
易错点：一定注意自增自减符的位置，对于 add 操作应写在前面，而 delete
操作应写在后面。<br />
<strong>注意：一定要先写右指针的移动，不然对于一些特殊的题目容易死掉。比如<a
href="https://www.luogu.com.cn/problem/P12598">这道题</a>。</strong><br />
时间复杂度 <span class="math inline">\(O(n\sqrt
n)\)</span>。每次查询左指针在块内最多移动 <span
class="math inline">\(O(\sqrt n)\)</span>，总体 <span
class="math inline">\(O(q\cdot\sqrt n)\)</span>，每个块内右指针最多移动
<span class="math inline">\(O(n)\)</span>，总体 <span
class="math inline">\(O(n\cdot\sqrt n)\)</span>，总时间复杂度 <span
class="math inline">\(O(q\cdot\sqrt{n}+n\cdot\sqrt{n})\)</span>，<span
class="math inline">\(q\)</span> 与 <span
class="math inline">\(n\)</span> 同阶，故总时间复杂度 <span
class="math inline">\(O(n\sqrt n)\)</span>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30010</span>,M=<span class="number">200010</span>,MAXN=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],ans[M],b[MAXN],q,belong[N],block,l,r,now;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,id;</span><br><span class="line">&#125;query[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Query x,Query y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> belong[x.l]==belong[y.l]?x.r&lt;y.r:belong[x.l]&lt;belong[y.l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b[a[x]])</span><br><span class="line">        now++;</span><br><span class="line">    b[a[x]]++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    b[a[x]]--;</span><br><span class="line">    <span class="keyword">if</span>(!b[a[x]])</span><br><span class="line">        now--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        belong[i]=(i<span class="number">-1</span>)/block<span class="number">+1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;query[i].l,&amp;query[i].r);</span><br><span class="line">        query[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(query<span class="number">+1</span>,query<span class="number">+1</span>+q,cmp);</span><br><span class="line">    l=<span class="number">1</span>,r=<span class="number">0</span>,now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;query[i].r)</span><br><span class="line">            <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;query[i].r)</span><br><span class="line">            <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;query[i].l)</span><br><span class="line">            <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;query[i].l)</span><br><span class="line">            <span class="built_in">add</span>(--l);</span><br><span class="line">        ans[query[i].id]=now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 优化
奇偶排序优化。<br />
与普通莫队排序区别是：对于左端点在一个块内的时候，若在奇块内，则右端点升序排序，反之则降序排序。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Query x,Query y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(belong[x.l]!=belong[y.l])</span><br><span class="line">        <span class="keyword">return</span> belong[x.l]&lt;belong[y.l];</span><br><span class="line">    <span class="keyword">return</span> (belong[x.l]&amp;<span class="number">1</span>)?(x.r&lt;y.r):(x.r&gt;y.r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 理论大约能减少 <span class="math inline">\(30\%\)</span>
的指针移动次数。
我们考虑奇块因为右端点升序，到达块末尾时右指针应当较为靠后，而偶数块是降序，起始右指针也较为靠后，偶块转奇块同理，体现了一种“自然衔接”。<br />
可以看看模板题：<a
href="https://www.luogu.com.cn/problem/P1494">[国家集训队] 小 Z
的袜子</a><br />
设区间 <span class="math inline">\([l,r]\)</span> 中某颜色袜子数为 <span
class="math inline">\(x_i\)</span>，则选出两只这种袜子的概率为 <span
class="math display">\[\frac{x_i}{r-l+1}\cdot \frac{x_i-1}{r-l}\]</span>
则对于所有 <span class="math inline">\(i\)</span>，总的概率为 <span
class="math display">\[\frac{\sum x_i^2+\sum x_i}{(r-l+1)(r-l)}\]</span>
<span class="math inline">\(\sum x_i\)</span> 和 <span
class="math inline">\(\sum x_i^2\)</span> 都可以用脚维护。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> f=<span class="number">0</span>;x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) x=~x<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> n,m,c[N],belong[N],block,sum,cnt[N];</span><br><span class="line">ll sum2;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> query &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(belong[l]^belong[x.l])</span><br><span class="line">            <span class="keyword">return</span> belong[l]&lt;belong[x.l];</span><br><span class="line">        <span class="keyword">return</span> belong[l]&amp;<span class="number">1</span>?r&lt;x.r:r&gt;x.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ans</span>&#123;</span><br><span class="line">    ll a,b;</span><br><span class="line">    <span class="built_in">Ans</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Ans</span>(ll a,ll b):<span class="built_in">a</span>(a),<span class="built_in">b</span>(b)&#123;&#125;</span><br><span class="line">&#125;ans[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    sum2-=(ll)cnt[x]*cnt[x];</span><br><span class="line">    ++cnt[x],++sum;</span><br><span class="line">    sum2+=(ll)cnt[x]*cnt[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    sum2-=(ll)cnt[x]*cnt[x];</span><br><span class="line">    --cnt[x],--sum;</span><br><span class="line">    sum2+=(ll)cnt[x]*cnt[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) belong[i]=(i<span class="number">-1</span>)/block<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">read</span>(q[i].l,q[i].r);</span><br><span class="line">        q[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q<span class="number">+1</span>,q<span class="number">+1</span>+m);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i].l==q[i].r)&#123;</span><br><span class="line">            ans[q[i].id]=<span class="built_in">Ans</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) <span class="built_in">add</span>(c[++r]);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) <span class="built_in">del</span>(c[r--]);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) <span class="built_in">del</span>(c[l++]);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) <span class="built_in">add</span>(c[--l]);</span><br><span class="line">        ll a=sum2-sum,b=(r-l<span class="number">+1ll</span>)*(r-l),c=__gcd(a,b);</span><br><span class="line">        ans[q[i].id]=<span class="built_in">Ans</span>(a/c,b/c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>,ans[i].a,ans[i].b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### 带修莫队
考虑把修改操作和查询操作同时记录下来，把每个查询操作额外记录距离当次查询最近的一次修改的位置，同时跑莫队时记录当前已经进行了几次修改，这样回答查询时可以顺次进行修改或“时光倒流”回退修改。
排序方式：
以<strong>左端点所在块的编号</strong>为第一关键字，<strong>右端点所在块的编号</strong>为第二关键字，<strong>当前操作的时间戳</strong>为第三关键字排序。注意：这里的第二关键字是<strong>右端点所在块的编号</strong>。<br />
经<a
href="https://oi-wiki.org/misc/modifiable-mo-algo/">证明</a>，块长取
<span class="math inline">\(n^{\frac{2}{3}}\)</span>
较优。总体时间复杂度 <span
class="math inline">\(O(n^{\frac{5}{3}})\)</span>。<br />
<a href="https://www.luogu.com.cn/problem/P1903">模板题</a>。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">133353</span>,M=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">char</span> op;</span><br><span class="line"><span class="type">int</span> n,m,tot,block,belong[N],qcnt,mcnt,b[M],sum,a[N],ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,t,id;</span><br><span class="line">    <span class="built_in">query</span>(<span class="type">int</span> l=<span class="number">0</span>,<span class="type">int</span> r=<span class="number">0</span>,<span class="type">int</span> t=<span class="number">0</span>,<span class="type">int</span> id=<span class="number">0</span>):<span class="built_in">l</span>(l),<span class="built_in">r</span>(r),<span class="built_in">t</span>(t),<span class="built_in">id</span>(id)&#123;&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> query &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(belong[l]^belong[x.l]) <span class="keyword">return</span> belong[l]&lt;belong[x.l];</span><br><span class="line">        <span class="keyword">if</span>(belong[r]^belong[x.r]) <span class="keyword">return</span> belong[r]&lt;belong[x.r];</span><br><span class="line">        <span class="keyword">return</span> t&lt;x.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">modify</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,k;</span><br><span class="line">    <span class="built_in">modify</span>(<span class="type">int</span> x=<span class="number">0</span>,<span class="type">int</span> k=<span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">k</span>(k)&#123;&#125;</span><br><span class="line">&#125;mo[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span></span>&#123;<span class="keyword">if</span>(<span class="number">0</span>==b[x]++) ++sum;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span></span>&#123;<span class="keyword">if</span>(<span class="number">0</span>==--b[x]) --sum;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q[x].l&lt;=mo[t].x&amp;&amp;q[x].r&gt;=mo[t].x)&#123;</span><br><span class="line">        <span class="built_in">del</span>(a[mo[t].x]);</span><br><span class="line">        <span class="built_in">add</span>(mo[t].k);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(a[mo[t].x],mo[t].k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    block=<span class="built_in">pow</span>(n,<span class="number">2.0</span>/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) belong[i]=(i<span class="number">-1</span>)/block<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(op^<span class="string">&#x27;R&#x27;</span>) ++qcnt,q[qcnt]=<span class="built_in">query</span>(x,y,mcnt,qcnt);</span><br><span class="line">        <span class="keyword">else</span> mo[++mcnt]=<span class="built_in">modify</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(q<span class="number">+1</span>,q<span class="number">+1</span>+qcnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l=<span class="number">1</span>,r=<span class="number">0</span>,t=<span class="number">0</span>;i&lt;=qcnt;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) <span class="built_in">add</span>(a[--l]);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) <span class="built_in">add</span>(a[++r]);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) <span class="built_in">del</span>(a[l++]);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) <span class="built_in">del</span>(a[r--]);</span><br><span class="line">        <span class="keyword">while</span>(t&lt;q[i].t) <span class="built_in">update</span>(i,++t);</span><br><span class="line">        <span class="keyword">while</span>(t&gt;q[i].t) <span class="built_in">update</span>(i,t--);</span><br><span class="line">        ans[q[i].id]=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=qcnt;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度整数类 v1.5</title>
    <url>/2025/06/23/%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%95%B4%E6%95%B0%E7%B1%BB%20v1.5/</url>
    <content><![CDATA[<h3 id="背景">背景</h3>
<p>我们痛恨高精度。 ### 介绍
不想写高精度怎么办？提前写好模板，要用时直接复制粘贴就好啦！以下是一个高精度类，实现了除除法、取模和位运算外的所有整形运算。（先咕着这些，以后会添加的）。</p>
<details>
<summary>
bigint
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bigint</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BIGINT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIGINT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE 10000ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> PI2=<span class="number">6.283185307179586231995927</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">complex</span>&#123;</span><br><span class="line">    <span class="type">double</span> real,imag;</span><br><span class="line">    <span class="built_in">complex</span>(<span class="type">double</span> real=<span class="number">0</span>,<span class="type">double</span> imag=<span class="number">0</span>):<span class="built_in">real</span>(real),<span class="built_in">imag</span>(imag)&#123;&#125;</span><br><span class="line">    complex <span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">complex</span>(real+x.real,imag+x.imag);&#125;</span><br><span class="line">    complex <span class="keyword">operator</span>-(<span class="type">const</span> complex &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">complex</span>(real-x.real,imag-x.imag);&#125;</span><br><span class="line">    complex <span class="keyword">operator</span>*(<span class="type">const</span> complex &amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">complex</span>(real*x.real-imag*x.imag,real*x.imag+x.real*imag);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">complex omega[(<span class="number">1</span>&lt;&lt;<span class="number">21</span>)<span class="number">+10</span>];</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> Size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bigint</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_omega</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(i&gt;&gt;<span class="number">1</span>);j++)&#123;</span><br><span class="line">                <span class="type">double</span> arg=PI2*j/i;</span><br><span class="line">                omega[(i&gt;&gt;<span class="number">1</span>)+j]=<span class="built_in">complex</span>(<span class="built_in">cos</span>(arg),<span class="built_in">sin</span>(arg));</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FFT</span><span class="params">(std::vector&lt;complex&gt; &amp;a,<span class="type">int</span> n,<span class="type">bool</span> inv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j) std::<span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=n&gt;&gt;<span class="number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(len&gt;&gt;<span class="number">1</span>);j++)&#123;</span><br><span class="line">                    complex w=inv?<span class="built_in">complex</span>(omega[(len&gt;&gt;<span class="number">1</span>)+j].real,-omega[(len&gt;&gt;<span class="number">1</span>)+j].imag):omega[(len&gt;&gt;<span class="number">1</span>)+j];</span><br><span class="line">                    complex x=a[i+j],y=a[i+j+(len&gt;&gt;<span class="number">1</span>)]*w;</span><br><span class="line">                    a[i+j]=x+y,a[i+j+(len&gt;&gt;<span class="number">1</span>)]=x-y;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span>(inv) <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i].real/=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num[Size];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(len<span class="number">+2</span>));</span><br><span class="line">        len=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bigint</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">        len=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">bigint</span><span class="params">(<span class="type">const</span> T &amp;x)</span></span>&#123;*<span class="keyword">this</span>=x;&#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;out,<span class="type">const</span> bigint &amp;x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.num[<span class="number">0</span>]) out&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        out&lt;&lt;x.num[x.len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x.len<span class="number">-1</span>;i;i--)</span><br><span class="line">            out&lt;&lt;std::<span class="built_in">setw</span>(<span class="number">4</span>)&lt;&lt;std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>)&lt;&lt;x.num[i];</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;in,bigint &amp;x)&#123;</span><br><span class="line">        std::string s;</span><br><span class="line">        in&gt;&gt;s;x=s;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>=(<span class="type">const</span> T &amp;a)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        T x=a;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) num[<span class="number">0</span>]=<span class="number">1</span>,x=~x<span class="number">+1</span>;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            num[++len]=x%BASE;</span><br><span class="line">            x/=BASE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>=(<span class="type">const</span> std::string &amp;a);</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> bigint &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>]!=a.num[<span class="number">0</span>]) <span class="keyword">return</span> num[<span class="number">0</span>]&gt;a.num[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> num[<span class="number">0</span>]?len&gt;a.len:len&lt;a.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len;i;i--)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=a.num[i])</span><br><span class="line">                <span class="keyword">return</span> num[<span class="number">0</span>]?num[i]&gt;a.num[i]:num[i]&lt;a.num[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> bigint &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>]!=a.num[<span class="number">0</span>]) <span class="keyword">return</span> num[<span class="number">0</span>]&lt;a.num[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> num[<span class="number">0</span>]?len&lt;a.len:len&gt;a.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len;i;i--)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=a.num[i])</span><br><span class="line">                <span class="keyword">return</span> num[<span class="number">0</span>]?num[i]&lt;a.num[i]:num[i]&gt;a.num[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> bigint &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>]!=a.num[<span class="number">0</span>]) <span class="keyword">return</span> num[<span class="number">0</span>]&gt;a.num[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> num[<span class="number">0</span>]?len&gt;a.len:len&lt;a.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len;i;i--)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=a.num[i])</span><br><span class="line">                <span class="keyword">return</span> num[<span class="number">0</span>]?num[i]&gt;a.num[i]:num[i]&lt;a.num[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> bigint &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>]!=a.num[<span class="number">0</span>]) <span class="keyword">return</span> num[<span class="number">0</span>]&lt;a.num[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> num[<span class="number">0</span>]?len&lt;a.len:len&gt;a.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len;i;i--)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=a.num[i])</span><br><span class="line">                <span class="keyword">return</span> num[<span class="number">0</span>]?num[i]&lt;a.num[i]:num[i]&gt;a.num[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> bigint &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=a.num[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> bigint &amp;a)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len!=a.len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=a.num[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> bigint &amp;a)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>]==a.num[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> temp=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> old_len=len;</span><br><span class="line">            len=std::<span class="built_in">max</span>(len,a.len);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> sum=temp;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=old_len) sum+=num[i];</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=a.len) sum+=a.num[i];</span><br><span class="line">                num[i]=(<span class="type">int</span>)(sum%BASE);</span><br><span class="line">                temp=sum/BASE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp)</span><br><span class="line">                num[++len]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">bool</span> this_large=<span class="keyword">this</span>-&gt;<span class="built_in">abs</span>()&gt;=a.<span class="built_in">abs</span>();</span><br><span class="line">            <span class="type">const</span> bigint &amp;larger=this_large?*<span class="keyword">this</span>:a;</span><br><span class="line">            <span class="type">const</span> bigint &amp;smaller=this_large?a:*<span class="keyword">this</span>;</span><br><span class="line">            <span class="type">int</span> new_len=larger.len;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> temp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=new_len;i++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> diff=(<span class="type">long</span> <span class="type">long</span>)larger.num[i]-temp;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=smaller.len) diff-=smaller.num[i];</span><br><span class="line">                <span class="keyword">if</span>(diff&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    diff+=BASE;</span><br><span class="line">                    temp=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> temp=<span class="number">0</span>;</span><br><span class="line">                num[i]=diff;</span><br><span class="line">            &#125;</span><br><span class="line">            len=new_len;</span><br><span class="line">            <span class="keyword">while</span>(len&gt;<span class="number">1</span>&amp;&amp;num[len]==<span class="number">0</span>) len--;</span><br><span class="line">            num[<span class="number">0</span>]=this_large?num[<span class="number">0</span>]:a.num[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">1</span>&amp;&amp;num[<span class="number">1</span>]==<span class="number">0</span>) num[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> bigint &amp;a)&#123;</span><br><span class="line">        bigint temp=a;</span><br><span class="line">        temp.num[<span class="number">0</span>]^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> bigint &amp;a)&#123;</span><br><span class="line">        <span class="keyword">if</span>((len==<span class="number">1</span>&amp;&amp;num[<span class="number">1</span>]==<span class="number">0</span>)||(a.len==<span class="number">1</span>&amp;&amp;a.num[<span class="number">1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="built_in">init</span>();</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> old_len=len;</span><br><span class="line">        <span class="type">int</span> old_num[Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(old_num,num,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(len<span class="number">+10</span>));</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        num[<span class="number">0</span>]=old_num[<span class="number">0</span>]^a.num[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> len_sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len_sum&lt;old_len+a.len)</span><br><span class="line">            len_sum&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="function">std::vector&lt;complex&gt; <span class="title">fa</span><span class="params">(len_sum<span class="number">+10</span>)</span>,<span class="title">fb</span><span class="params">(len_sum<span class="number">+10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;old_len;i++)</span><br><span class="line">            fa[i]=<span class="built_in">complex</span>((<span class="type">double</span>)old_num[i<span class="number">+1</span>],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)</span><br><span class="line">            fb[i]=<span class="built_in">complex</span>((<span class="type">double</span>)a.num[i<span class="number">+1</span>],<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">init_omega</span>(len_sum);</span><br><span class="line">        <span class="built_in">FFT</span>(fa,len_sum,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">FFT</span>(fb,len_sum,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len_sum;i++)</span><br><span class="line">            fa[i]=fa[i]*fb[i];</span><br><span class="line">        <span class="built_in">FFT</span>(fa,len_sum,<span class="literal">true</span>);</span><br><span class="line">        len=old_len+a.len;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> val=(<span class="type">long</span> <span class="type">long</span>)<span class="built_in">round</span>(fa[i].real)+temp;</span><br><span class="line">            num[i<span class="number">+1</span>]=(<span class="type">int</span>)(val%BASE);</span><br><span class="line">            temp=val/BASE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp) num[++len]=temp;</span><br><span class="line">        <span class="keyword">while</span>(len&gt;<span class="number">1</span>&amp;&amp;num[len]==<span class="number">0</span>) len--;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>++()&#123;</span><br><span class="line">        *<span class="keyword">this</span>+=<span class="built_in">bigint</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint &amp;<span class="keyword">operator</span>--()&#123;</span><br><span class="line">        *<span class="keyword">this</span>-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    bigint <span class="keyword">operator</span>++(T)&#123;</span><br><span class="line">        bigint res=*<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    bigint <span class="keyword">operator</span>--(T)&#123;</span><br><span class="line">        bigint res=*<span class="keyword">this</span>;</span><br><span class="line">        --*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> bigint <span class="keyword">operator</span>+(<span class="type">const</span> bigint &amp;a,<span class="type">const</span> bigint &amp;b)&#123;<span class="keyword">return</span> <span class="built_in">bigint</span>(a)+=b;&#125;</span><br><span class="line">    <span class="keyword">friend</span> bigint <span class="keyword">operator</span>-(<span class="type">const</span> bigint &amp;a,<span class="type">const</span> bigint &amp;b)&#123;<span class="keyword">return</span> <span class="built_in">bigint</span>(a)-=b;&#125;</span><br><span class="line">    <span class="keyword">friend</span> bigint <span class="keyword">operator</span>*(<span class="type">const</span> bigint &amp;a,<span class="type">const</span> bigint &amp;b)&#123;<span class="keyword">return</span> <span class="built_in">bigint</span>(a)*=b;&#125;</span><br><span class="line">    <span class="function">bigint <span class="title">abs</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        bigint res=*<span class="keyword">this</span>;</span><br><span class="line">        res.num[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> Size&gt;</span><br><span class="line">bigint&lt;Size&gt; &amp;bigint&lt;Size&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> std::string &amp;a)&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> slen=a.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span>(slen&gt;<span class="number">0</span>&amp;&amp;a[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>) num[<span class="number">0</span>]=f=<span class="number">1</span>;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=slen<span class="number">-1</span>;i&gt;=f;i--)&#123;</span><br><span class="line">        temp+=(a[i]^<span class="number">48</span>)*w;</span><br><span class="line">        w=(w&lt;&lt;<span class="number">1</span>)+(w&lt;&lt;<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(w==BASE||i==f)&#123;</span><br><span class="line">            num[++len]=(<span class="type">int</span>)temp;</span><br><span class="line">            temp=<span class="number">0</span>;</span><br><span class="line">            w=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp||len==<span class="number">0</span>) num[++len]=temp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> BASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</details>
<h3 id="使用说明">使用说明</h3>
<h4 id="前言">前言</h4>
<p>这份高精度模板使用压位实现常数优化，实现过程中为了保证乘法运算的精度，最终选择了压
<span class="math inline">\(4\)</span> 位，可以保证 <span
class="math inline">\(10^{1000000}\)</span> 以内的精度。 #### 声明
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bigint&lt;/*length_of_number*/&gt; a;</span><br><span class="line"><span class="comment">//因为压位，所以可以只开四分之一大小，但一般建议开大些</span></span><br></pre></td></tr></table></figure> 无需任何命名空间。 #### I/O 方式 为方便使用，接入了
<code>iostream</code> 的 I/O。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bigint&lt;<span class="number">114514</span>&gt; a;</span><br><span class="line">std::cin&gt;&gt;a;</span><br><span class="line">std::cout&lt;&lt;a;</span><br></pre></td></tr></table></figure> #### 数值运算符
加法与减法使用 <span class="math inline">\(O(n)\)</span> 算法，乘法使用
<span class="math inline">\(O(n\log n)\)</span> 算法（FFT），也写了一份
NTT 实现，实测表现优于 FFT，但暂无法处理较大的数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bigint&lt;<span class="number">114514</span>&gt; a,b;</span><br><span class="line">a+b;</span><br><span class="line">a-b;</span><br><span class="line">a*b;</span><br><span class="line">a+=b;</span><br><span class="line">a-=b;</span><br><span class="line">a*=b;</span><br><span class="line">a++;</span><br><span class="line">a--;</span><br><span class="line">++a;</span><br><span class="line">--a;</span><br></pre></td></tr></table></figure> ####
赋值运算符 支持所有<strong>整形</strong>，同时对
<code>std::string</code>
进行特化，支持将一个<strong>格式符合正常数字</strong>的
<code>std::string</code> 转为高精度整形。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bigint&lt;<span class="number">114514</span>&gt; a,b;</span><br><span class="line">std::string c;</span><br><span class="line">c=<span class="string">&quot;-1919810&quot;</span>;</span><br><span class="line">a=<span class="number">-1919810</span>,b=c;</span><br><span class="line"><span class="comment">//a和b所存的值均为-1919810</span></span><br></pre></td></tr></table></figure> #### 关系符
除三路比较运算符（C++20）外的所有常用大小关系符。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bigint&lt;<span class="number">114514</span>&gt; a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line">a&lt;b;<span class="comment">//此表达式为true</span></span><br><span class="line">a!=b;<span class="comment">//此表达式为true</span></span><br><span class="line">a==b;<span class="comment">//此表达式为false</span></span><br></pre></td></tr></table></figure> ####
其他 成员函数 <code>abs()</code>，以 <code>bigint</code>
类型返回该数的绝对值。 ### 关于 FFT/NTT
与压位对于高精度乘法的性能优化比对数据 <a
href="https://github.com/headless-piston/bigint/tree/test_data"
title="data">data</a>（洛谷 P1919 #1 数据） code <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">bigint&lt;<span class="number">2145141</span>&gt; a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;1.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    cout&lt;&lt;a*b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 数据取
<span class="math inline">\(5\)</span> 次运行平均值。 评测环境：S2
四机房（Intel(R) Core(TM) i5-10400 CPU @ 2.90GHz 2.90 GHz）。MinGW-W64
GCC 11.4.0 64-bit Debug。 编译选项： <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-std=c++14 -O2 -Wl,--stack=268435456</span><br></pre></td></tr></table></figure> | | FFT | NTT | |
:————: | :————: | :————: | | 不压位 | 0.5712 | 0.5112 | | 压 <span
class="math inline">\(2\)</span> 位 | 0.2718 | - | | 压 <span
class="math inline">\(4\)</span> 位 | 0.1546 | - |</p>
<p>单位：<span class="math inline">\(\text{s}\)</span>。 数据来自
RedPandaIDE
程序运行窗口自带的用时显示，真实评测时用时应会比表中数据略小。 单模数
NTT 压 <span class="math inline">\(2\)</span> 位/<span
class="math inline">\(4\)</span> 位在数据范围内无法得到正确答案。 ###
Upd v1.1：增加了 NTT 命名空间，但因为一些原因暂不使用。
v1.2：改了改码风。 v1.3：使用 C++ 标准库中的 <code>std::complex</code>
代替手写的复数类。修复了初始化错误的问题。
v1.4：<code>std::complex</code> 跑的太慢啦，换回手写的复数类。
v1.5：改用预处理单位根计算，提高了精度。现在可以压 <span
class="math inline">\(4\)</span> 位啦，效率大提升！</p>
]]></content>
  </entry>
</search>
